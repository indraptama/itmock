{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/isarray/index.js","node_modules/node-vibrant/lib/browser.js","node_modules/node-vibrant/lib/filter/default.js","node_modules/node-vibrant/lib/filter/index.js","node_modules/node-vibrant/lib/generator/default.js","node_modules/node-vibrant/lib/generator/index.js","node_modules/node-vibrant/lib/image/browser.js","node_modules/node-vibrant/lib/image/index.js","node_modules/node-vibrant/lib/quantizer/baseline.js","node_modules/node-vibrant/lib/quantizer/color-cut.js","node_modules/node-vibrant/lib/quantizer/impl/color-cut.js","node_modules/node-vibrant/lib/quantizer/impl/mmcq.js","node_modules/node-vibrant/lib/quantizer/impl/pqueue.js","node_modules/node-vibrant/lib/quantizer/impl/vbox.js","node_modules/node-vibrant/lib/quantizer/index.js","node_modules/node-vibrant/lib/quantizer/mmcq.js","node_modules/node-vibrant/lib/quantizer/nocopy.js","node_modules/node-vibrant/lib/swatch.js","node_modules/node-vibrant/lib/util.js","node_modules/node-vibrant/lib/vibrant.js","node_modules/node-vibrant/vendor-mod/quantize.js","node_modules/page/index.js","node_modules/page/node_modules/path-to-regexp/index.js","node_modules/process/browser.js","node_modules/quantize/quantize.js","node_modules/whatwg-fetch/fetch.js","src/index.js","src/js/figure-bg.js","src/js/tabs.js","src/js/vendor/imgfill.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtXA,yBAAU,CAAC;;AAIX,SAAS,SAAS,GAAG;AACpB,KAAM,SAAS,GAAG,QAAQ,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC;AAC1D,KAAM,SAAS,GAAG,QAAQ,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;AACvD,KAAM,cAAc,GAAG,QAAQ,CAAC,aAAa,CAAC,oBAAoB,CAAC,CAAC;;AAEpE,UAAS,CAAC,gBAAgB,CAAC,OAAO,EAAE,UAAS,GAAG,EAAE;AACjD,KAAG,CAAC,cAAc,EAAE,CAAC;AACrB,WAAS,CAAC,SAAS,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;EACrC,EAAE,KAAK,CAAC,CAAC;;AAEV,eAAc,CAAC,gBAAgB,CAAC,OAAO,EAAE,UAAS,GAAG,EAAE;AACtD,KAAG,CAAC,cAAc,EAAE,CAAC;AACrB,WAAS,CAAC,SAAS,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;EACxC,EAAE,KAAK,CAAC,CAAC;CACV;;AAED,SAAS,EAAE,CAAC;AACZ,uBAAQ,UAAU,EAAE,aAAa,CAAC,CAAC;;;;;;;;;;;;;;;AC1BnC,IAAM,QAAQ,GAAG,SAAX,QAAQ,GAAS;AACrB,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,CAAC,CAAC;;;;;;;UACnE,MAAM;;AACb,UAAM,MAAM,GAAG,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;AAC/D,UAAM,UAAU,GAAG,MAAM,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;;AAEtD,UAAM,OAAO,GAAG,0BAAY,MAAM,CAAC,CAAC;AACpC,aAAO,CAAC,UAAU,CAAC,UAAE,GAAG,EAAE,OAAO,EAAM;AACrC,YAAI,GAAG,EAAE;AACP,oBAAU,CAAC,KAAK,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;SAC7C,MAAM;AACL,cAAM,QAAQ,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;AAC5C,cAAM,SAAS,GAAG,OAAO,CAAC,OAAO,CAAC,iBAAiB,EAAE,CAAC;AACtD,oBAAU,CAAC,KAAK,CAAC,eAAe,GAAG,OAAO,GAAG,QAAQ,GAAG,MAAM,CAAC;AAC/D,oBAAU,CAAC,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC;SACpC;OACF,CAAC,CAAC;;;AAdL,yBAAmB,OAAO,8HAAE;;KAe3B;;;;;;;;;;;;;;;CACF,CAAC;;kBAEa,QAAQ;;;;;;;;;ACrBvB,IAAM,WAAW,GAAG,SAAd,WAAW,CAAI,EAAE,EAAK;AAC1B,MAAM,QAAQ,GAAG,QAAQ,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;AAC/C,OAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACxC,YAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,GAAG,MAAM,CAAC;GACpC;CACF,CAAC;;AAGF,IAAM,IAAI,GAAG,SAAP,IAAI,GAAS;AACjB,MAAM,GAAG,GAAG,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;AAC3C,MAAM,QAAQ,GAAG,GAAG,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;AAChD,MAAM,UAAU,GAAG,GAAG,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;CAGrD,CAAA;;kBAEc,IAAI;;;ACjBnB,YAAY;;;;;;AAAC;;;AAQb,IAAM,MAAM,GAAG,SAAT,MAAM,CAAI,OAAO,EAAK;AAC1B,MAAI,GAAG,GAAG;AACR,kBAAc,EAAE,OAAO;AACvB,sBAAkB,EAAE,QAAQ;AAC5B,oBAAgB,EAAE,WAAW;GAC9B;;AAAC,AAEF,OAAK,IAAI,CAAC,IAAI,GAAG,EAAE;AACjB,WAAO,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;GAC3B;CACF,CAAC;;AAEF,IAAM,OAAO,GAAG,SAAV,OAAO,CAAI,MAAM,EAAE,QAAQ,EAAK;AACpC,MAAI,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC;;;;;;AAC7D,yBAAgB,QAAQ,8HAAE;UAAjB,GAAG;;;AAGV,UAAI,MAAM,GAAG,GAAG,CAAC,aAAa,CAAC,QAAQ,CAAC;;;AAAC,AAGzC,UAAI,SAAS,GAAG,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC;;;AAAC,AAG3C,YAAM,CAAC,KAAK,CAAC,OAAO,GAAG,MAAM;;AAAC,AAE9B,SAAG,CAAC,KAAK,CAAC,eAAe,GAAG,MAAM,GAAG,SAAS,GAAG,GAAG,CAAC;AACrD,YAAM,CAAC,GAAG,CAAC,CAAC;KACb;;;;;;;;;;;;;;;CACF,CAAC;;kBAEa,OAAO","file":"app.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","var Vibrant;\n\nVibrant = require('./vibrant');\n\nVibrant.DefaultOpts.Image = require('./image/browser');\n\nmodule.exports = Vibrant;\n","module.exports = function(r, g, b, a) {\n  return a >= 125 && !(r > 250 && g > 250 && b > 250);\n};\n","module.exports.Default = require('./default');\n","var DefaultGenerator, DefaultOpts, Generator, Swatch, util,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\nSwatch = require('../swatch');\n\nutil = require('../util');\n\nGenerator = require('./index');\n\nDefaultOpts = {\n  targetDarkLuma: 0.26,\n  maxDarkLuma: 0.45,\n  minLightLuma: 0.55,\n  targetLightLuma: 0.74,\n  minNormalLuma: 0.3,\n  targetNormalLuma: 0.5,\n  maxNormalLuma: 0.7,\n  targetMutesSaturation: 0.3,\n  maxMutesSaturation: 0.4,\n  targetVibrantSaturation: 1.0,\n  minVibrantSaturation: 0.35,\n  weightSaturation: 3,\n  weightLuma: 6,\n  weightPopulation: 1\n};\n\nmodule.exports = DefaultGenerator = (function(superClass) {\n  extend(DefaultGenerator, superClass);\n\n  DefaultGenerator.prototype.HighestPopulation = 0;\n\n  function DefaultGenerator(opts) {\n    this.opts = util.defaults(opts, DefaultOpts);\n    this.VibrantSwatch = null;\n    this.LightVibrantSwatch = null;\n    this.DarkVibrantSwatch = null;\n    this.MutedSwatch = null;\n    this.LightMutedSwatch = null;\n    this.DarkMutedSwatch = null;\n  }\n\n  DefaultGenerator.prototype.generate = function(swatches) {\n    this.swatches = swatches;\n    this.maxPopulation = this.findMaxPopulation;\n    this.generateVarationColors();\n    return this.generateEmptySwatches();\n  };\n\n  DefaultGenerator.prototype.getVibrantSwatch = function() {\n    return this.VibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getLightVibrantSwatch = function() {\n    return this.LightVibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getDarkVibrantSwatch = function() {\n    return this.DarkVibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getMutedSwatch = function() {\n    return this.MutedSwatch;\n  };\n\n  DefaultGenerator.prototype.getLightMutedSwatch = function() {\n    return this.LightMutedSwatch;\n  };\n\n  DefaultGenerator.prototype.getDarkMutedSwatch = function() {\n    return this.DarkMutedSwatch;\n  };\n\n  DefaultGenerator.prototype.generateVarationColors = function() {\n    this.VibrantSwatch = this.findColorVariation(this.opts.targetNormalLuma, this.opts.minNormalLuma, this.opts.maxNormalLuma, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.LightVibrantSwatch = this.findColorVariation(this.opts.targetLightLuma, this.opts.minLightLuma, 1, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.DarkVibrantSwatch = this.findColorVariation(this.opts.targetDarkLuma, 0, this.opts.maxDarkLuma, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.MutedSwatch = this.findColorVariation(this.opts.targetNormalLuma, this.opts.minNormalLuma, this.opts.maxNormalLuma, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n    this.LightMutedSwatch = this.findColorVariation(this.opts.targetLightLuma, this.opts.minLightLuma, 1, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n    return this.DarkMutedSwatch = this.findColorVariation(this.opts.targetDarkLuma, 0, this.opts.maxDarkLuma, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n  };\n\n  DefaultGenerator.prototype.generateEmptySwatches = function() {\n    var hsl;\n    if (this.VibrantSwatch === null) {\n      if (this.DarkVibrantSwatch !== null) {\n        hsl = this.DarkVibrantSwatch.getHsl();\n        hsl[2] = this.opts.targetNormalLuma;\n        this.VibrantSwatch = new Swatch(util.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);\n      }\n    }\n    if (this.DarkVibrantSwatch === null) {\n      if (this.VibrantSwatch !== null) {\n        hsl = this.VibrantSwatch.getHsl();\n        hsl[2] = this.opts.targetDarkLuma;\n        return this.DarkVibrantSwatch = new Swatch(util.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);\n      }\n    }\n  };\n\n  DefaultGenerator.prototype.findMaxPopulation = function() {\n    var j, len, population, ref, swatch;\n    population = 0;\n    ref = this.swatches;\n    for (j = 0, len = ref.length; j < len; j++) {\n      swatch = ref[j];\n      population = Math.max(population, swatch.getPopulation());\n    }\n    return population;\n  };\n\n  DefaultGenerator.prototype.findColorVariation = function(targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation) {\n    var j, len, luma, max, maxValue, ref, sat, swatch, value;\n    max = null;\n    maxValue = 0;\n    ref = this.swatches;\n    for (j = 0, len = ref.length; j < len; j++) {\n      swatch = ref[j];\n      sat = swatch.getHsl()[1];\n      luma = swatch.getHsl()[2];\n      if (sat >= minSaturation && sat <= maxSaturation && luma >= minLuma && luma <= maxLuma && !this.isAlreadySelected(swatch)) {\n        value = this.createComparisonValue(sat, targetSaturation, luma, targetLuma, swatch.getPopulation(), this.HighestPopulation);\n        if (max === null || value > maxValue) {\n          max = swatch;\n          maxValue = value;\n        }\n      }\n    }\n    return max;\n  };\n\n  DefaultGenerator.prototype.createComparisonValue = function(saturation, targetSaturation, luma, targetLuma, population, maxPopulation) {\n    return this.weightedMean(this.invertDiff(saturation, targetSaturation), this.opts.weightSaturation, this.invertDiff(luma, targetLuma), this.opts.weightLuma, population / maxPopulation, this.opts.weightPopulation);\n  };\n\n  DefaultGenerator.prototype.invertDiff = function(value, targetValue) {\n    return 1 - Math.abs(value - targetValue);\n  };\n\n  DefaultGenerator.prototype.weightedMean = function() {\n    var i, sum, sumWeight, value, values, weight;\n    values = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    sum = 0;\n    sumWeight = 0;\n    i = 0;\n    while (i < values.length) {\n      value = values[i];\n      weight = values[i + 1];\n      sum += value * weight;\n      sumWeight += weight;\n      i += 2;\n    }\n    return sum / sumWeight;\n  };\n\n  DefaultGenerator.prototype.isAlreadySelected = function(swatch) {\n    return this.VibrantSwatch === swatch || this.DarkVibrantSwatch === swatch || this.LightVibrantSwatch === swatch || this.MutedSwatch === swatch || this.DarkMutedSwatch === swatch || this.LightMutedSwatch === swatch;\n  };\n\n  return DefaultGenerator;\n\n})(Generator);\n","var Generator;\n\nmodule.exports = Generator = (function() {\n  function Generator() {}\n\n  Generator.prototype.generate = function(swatches) {};\n\n  Generator.prototype.getVibrantSwatch = function() {};\n\n  Generator.prototype.getLightVibrantSwatch = function() {};\n\n  Generator.prototype.getDarkVibrantSwatch = function() {};\n\n  Generator.prototype.getMutedSwatch = function() {};\n\n  Generator.prototype.getLightMutedSwatch = function() {};\n\n  Generator.prototype.getDarkMutedSwatch = function() {};\n\n  return Generator;\n\n})();\n\nmodule.exports.Default = require('./default');\n","var BrowserImage, Image,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nImage = require('./index');\n\nmodule.exports = BrowserImage = (function(superClass) {\n  extend(BrowserImage, superClass);\n\n  function BrowserImage(path, cb) {\n    this.img = document.createElement('img');\n    this.img.crossOrigin = 'anonymous';\n    this.img.src = path;\n    this.img.onload = (function(_this) {\n      return function() {\n        _this._initCanvas();\n        return typeof cb === \"function\" ? cb(null, _this) : void 0;\n      };\n    })(this);\n    this.img.onerror = (function(_this) {\n      return function(e) {\n        var err;\n        err = new Error(\"Fail to load image: \" + path);\n        err.raw = e;\n        return typeof cb === \"function\" ? cb(err) : void 0;\n      };\n    })(this);\n  }\n\n  BrowserImage.prototype._initCanvas = function() {\n    this.canvas = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n    document.body.appendChild(this.canvas);\n    this.width = this.canvas.width = this.img.width;\n    this.height = this.canvas.height = this.img.height;\n    return this.context.drawImage(this.img, 0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.clear = function() {\n    return this.context.clearRect(0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.getWidth = function() {\n    return this.width;\n  };\n\n  BrowserImage.prototype.getHeight = function() {\n    return this.height;\n  };\n\n  BrowserImage.prototype.resize = function(w, h, r) {\n    this.width = this.canvas.width = w;\n    this.height = this.canvas.height = h;\n    this.context.scale(r, r);\n    return this.context.drawImage(this.img, 0, 0);\n  };\n\n  BrowserImage.prototype.update = function(imageData) {\n    return this.context.putImageData(imageData, 0, 0);\n  };\n\n  BrowserImage.prototype.getPixelCount = function() {\n    return this.width * this.height;\n  };\n\n  BrowserImage.prototype.getImageData = function() {\n    return this.context.getImageData(0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.removeCanvas = function() {\n    return this.canvas.parentNode.removeChild(this.canvas);\n  };\n\n  return BrowserImage;\n\n})(Image);\n","var Image;\n\nmodule.exports = Image = (function() {\n  function Image() {}\n\n  Image.prototype.clear = function() {};\n\n  Image.prototype.update = function(imageData) {};\n\n  Image.prototype.getWidth = function() {};\n\n  Image.prototype.getHeight = function() {};\n\n  Image.prototype.scaleDown = function(opts) {\n    var height, maxSide, ratio, width;\n    width = this.getWidth();\n    height = this.getHeight();\n    ratio = 1;\n    if (opts.maxDimension != null) {\n      maxSide = Math.max(width, height);\n      if (maxSide > opts.maxDimension) {\n        ratio = opts.maxDimension / maxSide;\n      }\n    } else {\n      ratio = 1 / opts.quality;\n    }\n    if (ratio < 1) {\n      return this.resize(width * ratio, height * ratio, ratio);\n    }\n  };\n\n  Image.prototype.resize = function(w, h, r) {};\n\n  Image.prototype.getPixelCount = function() {};\n\n  Image.prototype.getImageData = function() {};\n\n  Image.prototype.removeCanvas = function() {};\n\n  return Image;\n\n})();\n","var BaselineQuantizer, Quantizer, Swatch, quantize,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nquantize = require('quantize');\n\nmodule.exports = BaselineQuantizer = (function(superClass) {\n  extend(BaselineQuantizer, superClass);\n\n  function BaselineQuantizer() {\n    return BaselineQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  BaselineQuantizer.prototype.initialize = function(pixels, opts) {\n    var a, allPixels, b, cmap, g, i, offset, pixelCount, r;\n    this.opts = opts;\n    pixelCount = pixels.length / 4;\n    allPixels = [];\n    i = 0;\n    while (i < pixelCount) {\n      offset = i * 4;\n      r = pixels[offset + 0];\n      g = pixels[offset + 1];\n      b = pixels[offset + 2];\n      a = pixels[offset + 3];\n      if (a >= 125) {\n        if (!(r > 250 && g > 250 && b > 250)) {\n          allPixels.push([r, g, b]);\n        }\n      }\n      i = i + this.opts.quality;\n    }\n    cmap = quantize(allPixels, this.opts.colorCount);\n    return this.swatches = cmap.vboxes.map((function(_this) {\n      return function(vbox) {\n        return new Swatch(vbox.color, vbox.vbox.count());\n      };\n    })(this));\n  };\n\n  BaselineQuantizer.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return BaselineQuantizer;\n\n})(Quantizer);\n","var ColorCut, ColorCutQuantizer, Quantizer, Swatch,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nColorCut = require('./impl/color-cut');\n\nmodule.exports = ColorCutQuantizer = (function(superClass) {\n  extend(ColorCutQuantizer, superClass);\n\n  function ColorCutQuantizer() {\n    return ColorCutQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  ColorCutQuantizer.prototype.initialize = function(pixels, opts) {\n    var buf, buf8, data;\n    this.opts = opts;\n    buf = new ArrayBuffer(pixels.length);\n    buf8 = new Uint8ClampedArray(buf);\n    data = new Uint32Array(buf);\n    buf8.set(pixels);\n    return this.quantizer = new ColorCut(data, this.opts);\n  };\n\n  ColorCutQuantizer.prototype.getQuantizedColors = function() {\n    return this.quantizer.getQuantizedColors();\n  };\n\n  return ColorCutQuantizer;\n\n})(Quantizer);\n","var ABGRColor, COMPONENT_BLUE, COMPONENT_GREEN, COMPONENT_RED, Color, ColorCutQuantizer, QUANTIZE_WORD_MASK, QUANTIZE_WORD_WIDTH, RGBAColor, Swatch, Vbox, approximateToRgb888, isLittleEndian, modifySignificantOctet, modifyWordWidth, quantizeFromRgb888, quantizedBlue, quantizedGreen, quantizedRed, sort;\n\nSwatch = require('../../swatch');\n\nsort = function(arr, lower, upper) {\n  var partition, pivot, swap;\n  swap = function(a, b) {\n    var t;\n    t = arr[a];\n    arr[a] = arr[b];\n    return arr[b] = t;\n  };\n  partition = function(pivot, left, right) {\n    var index, j, ref, ref1, v, value;\n    index = left;\n    value = arr[pivot];\n    swap(pivot, right);\n    for (v = j = ref = left, ref1 = right - 1; ref <= ref1 ? j <= ref1 : j >= ref1; v = ref <= ref1 ? ++j : --j) {\n      if (arr[v] > value) {\n        swap(v, index);\n        index++;\n      }\n    }\n    swap(right, index);\n    return index;\n  };\n  if (lower < upper) {\n    pivot = lower + Math.ceil((upper - lower) / 2);\n    pivot = partition(pivot, lower, upper);\n    sort(arr, lower, pivot - 1);\n    return sort(arr, pivot + 1, upper);\n  }\n};\n\nCOMPONENT_RED = -3;\n\nCOMPONENT_GREEN = -2;\n\nCOMPONENT_BLUE = -1;\n\nQUANTIZE_WORD_WIDTH = 5;\n\nQUANTIZE_WORD_MASK = (1 << QUANTIZE_WORD_WIDTH) - 1;\n\nRGBAColor = {\n  red: function(c) {\n    return c >> 24;\n  },\n  green: function(c) {\n    return c << 8 >> 24;\n  },\n  blue: function(c) {\n    return c << 16 >> 24;\n  },\n  alpha: function(c) {\n    return c << 24 >> 24;\n  }\n};\n\nABGRColor = {\n  red: function(c) {\n    return c << 24 >> 24;\n  },\n  green: function(c) {\n    return c << 16 >> 24;\n  },\n  blue: function(c) {\n    return c << 8 >> 24;\n  },\n  alpha: function(c) {\n    return c >> 24;\n  }\n};\n\nisLittleEndian = function() {\n  var a, b, c;\n  a = new ArrayBuffer(4);\n  b = new Uint8Array(a);\n  c = new Uint32Array(a);\n  b[0] = 0xa1;\n  b[1] = 0xb2;\n  b[2] = 0xc3;\n  b[3] = 0xd4;\n  if (c[0] === 0xd4c3b2a1) {\n    return true;\n  }\n  if (c[0] === 0xa1b2c3d4) {\n    return false;\n  }\n  throw new Error(\"Failed to determin endianness\");\n};\n\nColor = isLittleEndian() ? ABGRColor : RGBAColor;\n\nmodifyWordWidth = function(value, current, target) {\n  var newValue;\n  newValue = 0;\n  if (target > current) {\n    newValue = value << (target - current);\n  } else {\n    newValue = value >> (current - target);\n  }\n  return newValue & ((1 << target) - 1);\n};\n\nmodifySignificantOctet = function(a, dimension, lower, upper) {\n  var color, i, j, k, ref, ref1, ref2, ref3;\n  switch (dimension) {\n    case COMPONENT_RED:\n      break;\n    case COMPONENT_GREEN:\n      for (i = j = ref = lower, ref1 = upper; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n        color = a[i];\n        a[i] = quantizedGreen(color) << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | quantizedRed(color) << QUANTIZE_WORD_WIDTH | quantizedBlue(color);\n      }\n      break;\n    case COMPONENT_BLUE:\n      for (i = k = ref2 = lower, ref3 = upper; ref2 <= ref3 ? k <= ref3 : k >= ref3; i = ref2 <= ref3 ? ++k : --k) {\n        color = a[i];\n        a[i] = quantizedBlue(color) << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | quantizedGreen(color) << QUANTIZE_WORD_WIDTH | quantizedRed(color);\n      }\n      break;\n  }\n};\n\nquantizeFromRgb888 = function(color) {\n  var b, g, r;\n  r = modifyWordWidth(Color.red(color), 8, QUANTIZE_WORD_WIDTH);\n  g = modifyWordWidth(Color.green(color), 8, QUANTIZE_WORD_WIDTH);\n  b = modifyWordWidth(Color.blue(color), 8, QUANTIZE_WORD_WIDTH);\n  return r << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | g << QUANTIZE_WORD_WIDTH | b;\n};\n\napproximateToRgb888 = function(r, g, b) {\n  var color;\n  if (!((g != null) && (b != null))) {\n    color = r;\n    r = quantizedRed(color);\n    g = quantizedGreen(color);\n    b = quantizedBlue(color);\n  }\n  return [modifyWordWidth(r, QUANTIZE_WORD_WIDTH, 8), modifyWordWidth(g, QUANTIZE_WORD_WIDTH, 8), modifyWordWidth(b, QUANTIZE_WORD_WIDTH, 8)];\n};\n\nquantizedRed = function(color) {\n  return color >> (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) & QUANTIZE_WORD_MASK;\n};\n\nquantizedGreen = function(color) {\n  return color >> QUANTIZE_WORD_WIDTH & QUANTIZE_WORD_MASK;\n};\n\nquantizedBlue = function(color) {\n  return color & QUANTIZE_WORD_MASK;\n};\n\nmodule.exports = ColorCutQuantizer = (function() {\n  function ColorCutQuantizer(data, opts) {\n    var c, color, distinctColorCount, distinctColorIndex, i, j, k, l, m, quantizedColor, ref, ref1, ref2, ref3;\n    this.opts = opts;\n    this.hist = new Uint32Array(1 << (QUANTIZE_WORD_WIDTH * 3));\n    this.pixels = new Uint32Array(data.length);\n    for (i = j = 0, ref = data.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {\n      this.pixels[i] = quantizedColor = quantizeFromRgb888(data[i]);\n      this.hist[quantizedColor]++;\n    }\n    distinctColorCount = 0;\n    for (color = k = 0, ref1 = this.hist.length - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; color = 0 <= ref1 ? ++k : --k) {\n      if (this.hist[color] > 0) {\n        distinctColorCount++;\n      }\n    }\n    this.colors = new Uint32Array(distinctColorCount);\n    distinctColorIndex = 0;\n    for (color = l = 0, ref2 = this.hist.length - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; color = 0 <= ref2 ? ++l : --l) {\n      if (this.hist[color] > 0) {\n        this.colors[distinctColorIndex++] = color;\n      }\n    }\n    if (distinctColorCount <= this.opts.colorCount) {\n      this.quantizedColors = [];\n      for (i = m = 0, ref3 = this.colors.length - 1; 0 <= ref3 ? m <= ref3 : m >= ref3; i = 0 <= ref3 ? ++m : --m) {\n        c = this.colors[i];\n        this.quantizedColors.push(new Swatch(approximateToRgb888(c), this.hist[c]));\n      }\n    } else {\n      this.quantizedColors = this.quantizePixels(this.opts.colorCount);\n    }\n  }\n\n  ColorCutQuantizer.prototype.getQuantizedColors = function() {\n    return this.quantizedColors;\n  };\n\n  ColorCutQuantizer.prototype.quantizePixels = function(maxColors) {\n    var pq;\n    pq = new PriorityQueue({\n      comparator: Vbox.comparator\n    });\n    pq.queue(new Vbox(this.colors, this.hist, 0, this.colors.length - 1));\n    this.splitBoxes(pq, maxColors);\n    return this.generateAverageColors(pq);\n  };\n\n  ColorCutQuantizer.prototype.splitBoxes = function(queue, maxSize) {\n    var vbox;\n    while (queue.length < maxSize) {\n      vbox = queue.dequeue();\n      if (vbox != null ? vbox.canSplit() : void 0) {\n        queue.queue(vbox.splitBox());\n        queue.queue(vbox);\n      } else {\n        return;\n      }\n    }\n  };\n\n  ColorCutQuantizer.prototype.generateAverageColors = function(vboxes) {\n    var colors;\n    colors = [];\n    while (vboxes.length > 0) {\n      colors.push(vboxes.dequeue().getAverageColor());\n    }\n    return colors;\n  };\n\n  return ColorCutQuantizer;\n\n})();\n\nVbox = (function() {\n  Vbox.comparator = function(lhs, rhs) {\n    return lhs.getVolume() - rhs.getVolume();\n  };\n\n  function Vbox(colors1, hist, lowerIndex, upperIndex) {\n    this.colors = colors1;\n    this.hist = hist;\n    this.lowerIndex = lowerIndex;\n    this.upperIndex = upperIndex;\n    this.fitBox();\n  }\n\n  Vbox.prototype.getVolume = function() {\n    return (this.maxRed - this.minRed + 1) * (this.maxGreen - this.minGreen + 1) * (this.maxBlue - this.minBlue + 1);\n  };\n\n  Vbox.prototype.canSplit = function() {\n    return this.getColorCount() > 1;\n  };\n\n  Vbox.prototype.getColorCount = function() {\n    return 1 + this.upperIndex - this.lowerIndex;\n  };\n\n  Vbox.prototype.fitBox = function() {\n    var b, color, count, g, i, j, r, ref, ref1;\n    this.minRed = this.minGreen = this.minBlue = Number.MAX_VALUE;\n    this.maxRed = this.maxGreen = this.maxBlue = Number.MIN_VALUE;\n    this.population = 0;\n    count = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      color = this.colors[i];\n      count += this.hist[color];\n      r = quantizedRed(color);\n      g = quantizedGreen(color);\n      b = quantizedBlue(color);\n      if (r > this.maxRed) {\n        this.maxRed = r;\n      }\n      if (r < this.minRed) {\n        this.minRed = r;\n      }\n      if (g > this.maxGreen) {\n        this.maxGreen = g;\n      }\n      if (g < this.minGreen) {\n        this.minGreen = g;\n      }\n      if (b > this.maxBlue) {\n        this.maxRed = b;\n      }\n      if (b < this.minBlue) {\n        this.minRed = b;\n      }\n    }\n    return this.population = count;\n  };\n\n  Vbox.prototype.splitBox = function() {\n    var newBox, splitPoint;\n    if (!this.canSplit()) {\n      throw new Error(\"Cannot split a box with only 1 color\");\n    }\n    splitPoint = this.findSplitPoint();\n    newBox = new Vbox(this.colors, this.hist, splitPoint + 1, this.upperIndex);\n    this.upperIndex = splitPoint;\n    this.fitBox();\n    return newBox;\n  };\n\n  Vbox.prototype.getLongestColorDimension = function() {\n    var blueLength, greenLength, redLength;\n    redLength = this.maxRed - this.minRed;\n    greenLength = this.maxGreen - this.minGreen;\n    blueLength = this.maxBlue - this.minBlue;\n    if (redLength >= greenLength && redLength >= blueLength) {\n      return COMPONENT_RED;\n    }\n    if (greenLength >= redLength && greenLength >= blueLength) {\n      return COMPONENT_GREEN;\n    }\n    return COMPONENT_BLUE;\n  };\n\n  Vbox.prototype.findSplitPoint = function() {\n    var count, i, j, longestDimension, midPoint, ref, ref1;\n    longestDimension = this.getLongestColorDimension();\n    modifySignificantOctet(this.colors, longestDimension, this.lowerIndex, this.upperIndex);\n    sort(this.colors, this.lowerIndex, this.upperIndex + 1);\n    modifySignificantOctet(this.colors, longestDimension, this.lowerIndex, this.upperIndex);\n    midPoint = this.population / 2;\n    count = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      count += this.hist[this.colors[i]];\n      if (count >= midPoint) {\n        return i;\n      }\n    }\n    return this.lowerIndex;\n  };\n\n  Vbox.prototype.getAverageColor = function() {\n    var blueMean, blueSum, color, colorPopulation, greenMean, greenSum, i, j, redMean, redSum, ref, ref1, totalPopulation;\n    redSum = greenSum = blueSum = 0;\n    totalPopulation = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      color = this.colors[i];\n      colorPopulation = this.hist[color];\n      totalPopulation += colorPopulation;\n      redSum += colorPopulation * quantizedRed(color);\n      greenSum += colorPopulation * quantizedGreen(color);\n      blueSum += colorPopulation * quantizedBlue(color);\n    }\n    redMean = Math.round(redSum / totalPopulation);\n    greenMean = Math.round(greenSum / totalPopulation);\n    blueMean = Math.round(blueSum / totalPopulation);\n    return new Swatch(approximateToRgb888(redMean, greenMean, blueMean), totalPopulation);\n  };\n\n  return Vbox;\n\n})();\n","var MMCQ, PQueue, RSHIFT, SIGBITS, Swatch, VBox, getColorIndex, ref, util;\n\nref = util = require('../../util'), getColorIndex = ref.getColorIndex, SIGBITS = ref.SIGBITS, RSHIFT = ref.RSHIFT;\n\nSwatch = require('../../swatch');\n\nVBox = require('./vbox');\n\nPQueue = require('./pqueue');\n\nmodule.exports = MMCQ = (function() {\n  MMCQ.DefaultOpts = {\n    maxIterations: 1000,\n    fractByPopulations: 0.75\n  };\n\n  function MMCQ(opts) {\n    this.opts = util.defaults(opts, this.constructor.DefaultOpts);\n  }\n\n  MMCQ.prototype.quantize = function(pixels, opts) {\n    var color, colorCount, hist, pq, pq2, shouldIgnore, swatches, v, vbox;\n    if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n      throw new Error(\"Wrong MMCQ parameters\");\n    }\n    shouldIgnore = function() {\n      return false;\n    };\n    if (Array.isArray(opts.filters) && opts.filters.length > 0) {\n      shouldIgnore = function(r, g, b, a) {\n        var f, i, len, ref1;\n        ref1 = opts.filters;\n        for (i = 0, len = ref1.length; i < len; i++) {\n          f = ref1[i];\n          if (!f(r, g, b, a)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    vbox = VBox.build(pixels, shouldIgnore);\n    hist = vbox.hist;\n    colorCount = Object.keys(hist).length;\n    pq = new PQueue(function(a, b) {\n      return a.count() - b.count();\n    });\n    pq.push(vbox);\n    this._splitBoxes(pq, this.opts.fractByPopulations * opts.colorCount);\n    pq2 = new PQueue(function(a, b) {\n      return a.count() * a.volume() - b.count() * b.volume();\n    });\n    pq2.contents = pq.contents;\n    this._splitBoxes(pq2, opts.colorCount - pq2.size());\n    swatches = [];\n    this.vboxes = [];\n    while (pq2.size()) {\n      v = pq2.pop();\n      color = v.avg();\n      if (!(typeof shouldIgnore === \"function\" ? shouldIgnore(color[0], color[1], color[2], 255) : void 0)) {\n        this.vboxes.push(v);\n        swatches.push(new Swatch(color, v.count()));\n      }\n    }\n    return swatches;\n  };\n\n  MMCQ.prototype._splitBoxes = function(pq, target) {\n    var colorCount, iteration, maxIterations, ref1, vbox, vbox1, vbox2;\n    colorCount = 1;\n    iteration = 0;\n    maxIterations = this.opts.maxIterations;\n    while (iteration < maxIterations) {\n      iteration++;\n      vbox = pq.pop();\n      if (!vbox.count()) {\n        continue;\n      }\n      ref1 = vbox.split(), vbox1 = ref1[0], vbox2 = ref1[1];\n      pq.push(vbox1);\n      if (vbox2) {\n        pq.push(vbox2);\n        colorCount++;\n      }\n      if (colorCount >= target || iteration > maxIterations) {\n        return;\n      }\n    }\n  };\n\n  return MMCQ;\n\n})();\n","var PQueue;\n\nmodule.exports = PQueue = (function() {\n  function PQueue(comparator) {\n    this.comparator = comparator;\n    this.contents = [];\n    this.sorted = false;\n  }\n\n  PQueue.prototype._sort = function() {\n    this.contents.sort(this.comparator);\n    return this.sorted = true;\n  };\n\n  PQueue.prototype.push = function(o) {\n    this.contents.push(o);\n    return this.sorted = false;\n  };\n\n  PQueue.prototype.peek = function(index) {\n    if (!this.sorted) {\n      this._sort();\n    }\n    if (index == null) {\n      index = this.contents.length - 1;\n    }\n    return this.contents[index];\n  };\n\n  PQueue.prototype.pop = function() {\n    if (!this.sorted) {\n      this._sort();\n    }\n    return this.contents.pop();\n  };\n\n  PQueue.prototype.size = function() {\n    return this.contents.length;\n  };\n\n  PQueue.prototype.map = function(f) {\n    if (!this.sorted) {\n      this._sort();\n    }\n    return this.contents.map(f);\n  };\n\n  return PQueue;\n\n})();\n","var RSHIFT, SIGBITS, VBox, getColorIndex, ref, util;\n\nref = util = require('../../util'), getColorIndex = ref.getColorIndex, SIGBITS = ref.SIGBITS, RSHIFT = ref.RSHIFT;\n\nmodule.exports = VBox = (function() {\n  VBox.build = function(pixels, shouldIgnore) {\n    var a, b, bmax, bmin, g, gmax, gmin, hist, hn, i, index, n, offset, r, rmax, rmin;\n    hn = 1 << (3 * SIGBITS);\n    hist = new Uint32Array(hn);\n    rmax = gmax = bmax = 0;\n    rmin = gmin = bmin = Number.MAX_VALUE;\n    n = pixels.length / 4;\n    i = 0;\n    while (i < n) {\n      offset = i * 4;\n      i++;\n      r = pixels[offset + 0];\n      g = pixels[offset + 1];\n      b = pixels[offset + 2];\n      a = pixels[offset + 3];\n      if (shouldIgnore(r, g, b, a)) {\n        continue;\n      }\n      r = r >> RSHIFT;\n      g = g >> RSHIFT;\n      b = b >> RSHIFT;\n      index = getColorIndex(r, g, b);\n      hist[index] += 1;\n      if (r > rmax) {\n        rmax = r;\n      }\n      if (r < rmin) {\n        rmin = r;\n      }\n      if (g > gmax) {\n        gmax = g;\n      }\n      if (g < gmin) {\n        gmin = g;\n      }\n      if (b > bmax) {\n        bmax = b;\n      }\n      if (b < bmin) {\n        bmin = b;\n      }\n    }\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, hist);\n  };\n\n  function VBox(r1, r2, g1, g2, b1, b2, hist1) {\n    this.r1 = r1;\n    this.r2 = r2;\n    this.g1 = g1;\n    this.g2 = g2;\n    this.b1 = b1;\n    this.b2 = b2;\n    this.hist = hist1;\n  }\n\n  VBox.prototype.invalidate = function() {\n    delete this._count;\n    delete this._avg;\n    return delete this._volume;\n  };\n\n  VBox.prototype.volume = function() {\n    if (this._volume == null) {\n      this._volume = (this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1);\n    }\n    return this._volume;\n  };\n\n  VBox.prototype.count = function() {\n    var c, hist;\n    if (this._count == null) {\n      hist = this.hist;\n      c = 0;\n      \n      for (var r = this.r1; r <= this.r2; r++) {\n        for (var g = this.g1; g <= this.g2; g++) {\n          for (var b = this.b1; b <= this.b2; b++) {\n            var index = getColorIndex(r, g, b);\n            c += hist[index];\n          }\n        }\n      }\n      ;\n      this._count = c;\n    }\n    return this._count;\n  };\n\n  VBox.prototype.clone = function() {\n    return new VBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.hist);\n  };\n\n  VBox.prototype.avg = function() {\n    var bsum, gsum, hist, mult, ntot, rsum;\n    if (this._avg == null) {\n      hist = this.hist;\n      ntot = 0;\n      mult = 1 << (8 - SIGBITS);\n      rsum = gsum = bsum = 0;\n      \n      for (var r = this.r1; r <= this.r2; r++) {\n        for (var g = this.g1; g <= this.g2; g++) {\n          for (var b = this.b1; b <= this.b2; b++) {\n            var index = getColorIndex(r, g, b);\n            var h = hist[index];\n            ntot += h;\n            rsum += (h * (r + 0.5) * mult);\n            gsum += (h * (g + 0.5) * mult);\n            bsum += (h * (b + 0.5) * mult);\n          }\n        }\n      }\n      ;\n      if (ntot) {\n        this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n      } else {\n        this._avg = [~~(mult * (this.r1 + this.r2 + 1) / 2), ~~(mult * (this.g1 + this.g2 + 1) / 2), ~~(mult * (this.b1 + this.b2 + 1) / 2)];\n      }\n    }\n    return this._avg;\n  };\n\n  VBox.prototype.split = function() {\n    var accSum, bw, d, doCut, gw, hist, i, j, maxd, maxw, ref1, reverseSum, rw, splitPoint, sum, total, vbox;\n    hist = this.hist;\n    if (!this.count()) {\n      return null;\n    }\n    if (this.count() === 1) {\n      return [this.clone()];\n    }\n    rw = this.r2 - this.r1 + 1;\n    gw = this.g2 - this.g1 + 1;\n    bw = this.b2 - this.b1 + 1;\n    maxw = Math.max(rw, gw, bw);\n    accSum = null;\n    sum = total = 0;\n    maxd = null;\n    switch (maxw) {\n      case rw:\n        maxd = 'r';\n        accSum = new Uint32Array(this.r2 + 1);\n        \n        for (var r = this.r1; r <= this.r2; r++) {\n          sum = 0\n          for (var g = this.g1; g <= this.g2; g++) {\n            for (var b = this.b1; b <= this.b2; b++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[r] = total;\n        }\n        ;\n        break;\n      case gw:\n        maxd = 'g';\n        accSum = new Uint32Array(this.g2 + 1);\n        \n        for (var g = this.g1; g <= this.g2; g++) {\n          sum = 0\n          for (var r = this.r1; r <= this.r2; r++) {\n            for (var b = this.b1; b <= this.b2; b++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[g] = total;\n        }\n        ;\n        break;\n      case bw:\n        maxd = 'b';\n        accSum = new Uint32Array(this.b2 + 1);\n        \n        for (var b = this.b1; b <= this.b2; b++) {\n          sum = 0\n          for (var r = this.r1; r <= this.r2; r++) {\n            for (var g = this.g1; g <= this.g2; g++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[b] = total;\n        }\n        ;\n    }\n    splitPoint = -1;\n    reverseSum = new Uint32Array(accSum.length);\n    for (i = j = 0, ref1 = accSum.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n      d = accSum[i];\n      if (splitPoint < 0 && d > total / 2) {\n        splitPoint = i;\n      }\n      reverseSum[i] = total - d;\n    }\n    vbox = this;\n    doCut = function(d) {\n      var c2, d1, d2, dim1, dim2, left, right, vbox1, vbox2;\n      dim1 = d + \"1\";\n      dim2 = d + \"2\";\n      d1 = vbox[dim1];\n      d2 = vbox[dim2];\n      vbox1 = vbox.clone();\n      vbox2 = vbox.clone();\n      left = splitPoint - d1;\n      right = d2 - splitPoint;\n      if (left <= right) {\n        d2 = Math.min(d2 - 1, ~~(splitPoint + right / 2));\n        d2 = Math.max(0, d2);\n      } else {\n        d2 = Math.max(d1, ~~(splitPoint - 1 - left / 2));\n        d2 = Math.min(vbox[dim2], d2);\n      }\n      while (!accSum[d2]) {\n        d2++;\n      }\n      c2 = reverseSum[d2];\n      while (!c2 && accSum[d2 - 1]) {\n        c2 = reverseSum[--d2];\n      }\n      vbox1[dim2] = d2;\n      vbox2[dim1] = d2 + 1;\n      return [vbox1, vbox2];\n    };\n    return doCut(maxd);\n  };\n\n  VBox.prototype.contains = function(p) {\n    var b, g, r;\n    r = p[0] >> RSHIFT;\n    g = p[1] >> RSHIFT;\n    b = p[2] >> RSHIFT;\n    return r >= this.r1 && r <= this.r2 && g >= this.g1 && g <= this.g2 && b >= this.b1 && b <= this.b2;\n  };\n\n  return VBox;\n\n})();\n","var Quantizer;\n\nmodule.exports = Quantizer = (function() {\n  function Quantizer() {}\n\n  Quantizer.prototype.initialize = function(pixels, opts) {};\n\n  Quantizer.prototype.getQuantizedColors = function() {};\n\n  return Quantizer;\n\n})();\n\nmodule.exports.Baseline = require('./baseline');\n\nmodule.exports.NoCopy = require('./nocopy');\n\nmodule.exports.ColorCut = require('./color-cut');\n\nmodule.exports.MMCQ = require('./mmcq');\n","var MMCQ, MMCQImpl, Quantizer, Swatch,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nMMCQImpl = require('./impl/mmcq');\n\nmodule.exports = MMCQ = (function(superClass) {\n  extend(MMCQ, superClass);\n\n  function MMCQ() {\n    return MMCQ.__super__.constructor.apply(this, arguments);\n  }\n\n  MMCQ.prototype.initialize = function(pixels, opts) {\n    var mmcq;\n    this.opts = opts;\n    mmcq = new MMCQImpl();\n    return this.swatches = mmcq.quantize(pixels, this.opts);\n  };\n\n  MMCQ.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return MMCQ;\n\n})(Quantizer);\n","var NoCopyQuantizer, Quantizer, Swatch, quantize,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nquantize = require('../../vendor-mod/quantize');\n\nmodule.exports = NoCopyQuantizer = (function(superClass) {\n  extend(NoCopyQuantizer, superClass);\n\n  function NoCopyQuantizer() {\n    return NoCopyQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  NoCopyQuantizer.prototype.initialize = function(pixels, opts) {\n    var cmap;\n    this.opts = opts;\n    cmap = quantize(pixels, this.opts);\n    return this.swatches = cmap.vboxes.map((function(_this) {\n      return function(vbox) {\n        return new Swatch(vbox.color, vbox.vbox.count());\n      };\n    })(this));\n  };\n\n  NoCopyQuantizer.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return NoCopyQuantizer;\n\n})(Quantizer);\n","var Swatch, util;\n\nutil = require('./util');\n\n\n/*\n  From Vibrant.js by Jari Zwarts\n  Ported to node.js by AKFish\n\n  Swatch class\n */\n\nmodule.exports = Swatch = (function() {\n  Swatch.prototype.hsl = void 0;\n\n  Swatch.prototype.rgb = void 0;\n\n  Swatch.prototype.population = 1;\n\n  Swatch.prototype.yiq = 0;\n\n  function Swatch(rgb, population) {\n    this.rgb = rgb;\n    this.population = population;\n  }\n\n  Swatch.prototype.getHsl = function() {\n    if (!this.hsl) {\n      return this.hsl = util.rgbToHsl(this.rgb[0], this.rgb[1], this.rgb[2]);\n    } else {\n      return this.hsl;\n    }\n  };\n\n  Swatch.prototype.getPopulation = function() {\n    return this.population;\n  };\n\n  Swatch.prototype.getRgb = function() {\n    return this.rgb;\n  };\n\n  Swatch.prototype.getHex = function() {\n    return util.rgbToHex(this.rgb[0], this.rgb[1], this.rgb[2]);\n  };\n\n  Swatch.prototype.getTitleTextColor = function() {\n    this._ensureTextColors();\n    if (this.yiq < 200) {\n      return \"#fff\";\n    } else {\n      return \"#000\";\n    }\n  };\n\n  Swatch.prototype.getBodyTextColor = function() {\n    this._ensureTextColors();\n    if (this.yiq < 150) {\n      return \"#fff\";\n    } else {\n      return \"#000\";\n    }\n  };\n\n  Swatch.prototype._ensureTextColors = function() {\n    if (!this.yiq) {\n      return this.yiq = (this.rgb[0] * 299 + this.rgb[1] * 587 + this.rgb[2] * 114) / 1000;\n    }\n  };\n\n  return Swatch;\n\n})();\n","var DELTAE94, RSHIFT, SIGBITS;\n\nDELTAE94 = {\n  NA: 0,\n  PERFECT: 1,\n  CLOSE: 2,\n  GOOD: 10,\n  SIMILAR: 50\n};\n\nSIGBITS = 5;\n\nRSHIFT = 8 - SIGBITS;\n\nmodule.exports = {\n  clone: function(o) {\n    var _o, key, value;\n    if (typeof o === 'object') {\n      if (Array.isArray(o)) {\n        return o.map((function(_this) {\n          return function(v) {\n            return _this.clone(v);\n          };\n        })(this));\n      } else {\n        _o = {};\n        for (key in o) {\n          value = o[key];\n          _o[key] = this.clone(value);\n        }\n        return _o;\n      }\n    }\n    return o;\n  },\n  defaults: function() {\n    var _o, i, key, len, o, value;\n    o = {};\n    for (i = 0, len = arguments.length; i < len; i++) {\n      _o = arguments[i];\n      for (key in _o) {\n        value = _o[key];\n        if (o[key] == null) {\n          o[key] = this.clone(value);\n        }\n      }\n    }\n    return o;\n  },\n  hexToRgb: function(hex) {\n    var m;\n    m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (m != null) {\n      return [m[1], m[2], m[3]].map(function(s) {\n        return parseInt(s, 16);\n      });\n    }\n    return null;\n  },\n  rgbToHex: function(r, g, b) {\n    return \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);\n  },\n  rgbToHsl: function(r, g, b) {\n    var d, h, l, max, min, s;\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    h = void 0;\n    s = void 0;\n    l = (max + min) / 2;\n    if (max === min) {\n      h = s = 0;\n    } else {\n      d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0);\n          break;\n        case g:\n          h = (b - r) / d + 2;\n          break;\n        case b:\n          h = (r - g) / d + 4;\n      }\n      h /= 6;\n    }\n    return [h, s, l];\n  },\n  hslToRgb: function(h, s, l) {\n    var b, g, hue2rgb, p, q, r;\n    r = void 0;\n    g = void 0;\n    b = void 0;\n    hue2rgb = function(p, q, t) {\n      if (t < 0) {\n        t += 1;\n      }\n      if (t > 1) {\n        t -= 1;\n      }\n      if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n      }\n      if (t < 1 / 2) {\n        return q;\n      }\n      if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n      }\n      return p;\n    };\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      q = l < 0.5 ? l * (1 + s) : l + s - (l * s);\n      p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - (1 / 3));\n    }\n    return [r * 255, g * 255, b * 255];\n  },\n  rgbToXyz: function(r, g, b) {\n    var x, y, z;\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    r = r > 0.04045 ? Math.pow((r + 0.005) / 1.055, 2.4) : r / 12.92;\n    g = g > 0.04045 ? Math.pow((g + 0.005) / 1.055, 2.4) : g / 12.92;\n    b = b > 0.04045 ? Math.pow((b + 0.005) / 1.055, 2.4) : b / 12.92;\n    r *= 100;\n    g *= 100;\n    b *= 100;\n    x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n    y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n    z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n    return [x, y, z];\n  },\n  xyzToCIELab: function(x, y, z) {\n    var L, REF_X, REF_Y, REF_Z, a, b;\n    REF_X = 95.047;\n    REF_Y = 100;\n    REF_Z = 108.883;\n    x /= REF_X;\n    y /= REF_Y;\n    z /= REF_Z;\n    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n    L = 116 * y - 16;\n    a = 500 * (x - y);\n    b = 200 * (y - z);\n    return [L, a, b];\n  },\n  rgbToCIELab: function(r, g, b) {\n    var ref, x, y, z;\n    ref = this.rgbToXyz(r, g, b), x = ref[0], y = ref[1], z = ref[2];\n    return this.xyzToCIELab(x, y, z);\n  },\n  deltaE94: function(lab1, lab2) {\n    var L1, L2, WEIGHT_C, WEIGHT_H, WEIGHT_L, a1, a2, b1, b2, dL, da, db, xC1, xC2, xDC, xDE, xDH, xDL, xSC, xSH;\n    WEIGHT_L = 1;\n    WEIGHT_C = 1;\n    WEIGHT_H = 1;\n    L1 = lab1[0], a1 = lab1[1], b1 = lab1[2];\n    L2 = lab2[0], a2 = lab2[1], b2 = lab2[2];\n    dL = L1 - L2;\n    da = a1 - a2;\n    db = b1 - b2;\n    xC1 = Math.sqrt(a1 * a1 + b1 * b1);\n    xC2 = Math.sqrt(a2 * a2 + b2 * b2);\n    xDL = L2 - L1;\n    xDC = xC2 - xC1;\n    xDE = Math.sqrt(dL * dL + da * da + db * db);\n    if (Math.sqrt(xDE) > Math.sqrt(Math.abs(xDL)) + Math.sqrt(Math.abs(xDC))) {\n      xDH = Math.sqrt(xDE * xDE - xDL * xDL - xDC * xDC);\n    } else {\n      xDH = 0;\n    }\n    xSC = 1 + 0.045 * xC1;\n    xSH = 1 + 0.015 * xC1;\n    xDL /= WEIGHT_L;\n    xDC /= WEIGHT_C * xSC;\n    xDH /= WEIGHT_H * xSH;\n    return Math.sqrt(xDL * xDL + xDC * xDC + xDH * xDH);\n  },\n  rgbDiff: function(rgb1, rgb2) {\n    var lab1, lab2;\n    lab1 = this.rgbToCIELab.apply(this, rgb1);\n    lab2 = this.rgbToCIELab.apply(this, rgb2);\n    return this.deltaE94(lab1, lab2);\n  },\n  hexDiff: function(hex1, hex2) {\n    var rgb1, rgb2;\n    rgb1 = this.hexToRgb(hex1);\n    rgb2 = this.hexToRgb(hex2);\n    return this.rgbDiff(rgb1, rgb2);\n  },\n  DELTAE94_DIFF_STATUS: DELTAE94,\n  getColorDiffStatus: function(d) {\n    if (d < DELTAE94.NA) {\n      return \"N/A\";\n    }\n    if (d <= DELTAE94.PERFECT) {\n      return \"Perfect\";\n    }\n    if (d <= DELTAE94.CLOSE) {\n      return \"Close\";\n    }\n    if (d <= DELTAE94.GOOD) {\n      return \"Good\";\n    }\n    if (d < DELTAE94.SIMILAR) {\n      return \"Similar\";\n    }\n    return \"Wrong\";\n  },\n  SIGBITS: SIGBITS,\n  RSHIFT: RSHIFT,\n  getColorIndex: function(r, g, b) {\n    return (r << (2 * SIGBITS)) + (g << SIGBITS) + b;\n  }\n};\n","\n/*\n  From Vibrant.js by Jari Zwarts\n  Ported to node.js by AKFish\n\n  Color algorithm class that finds variations on colors in an image.\n\n  Credits\n  --------\n  Lokesh Dhakar (http://www.lokeshdhakar.com) - Created ColorThief\n  Google - Palette support library in Android\n */\nvar Builder, DefaultGenerator, Filter, Swatch, Vibrant, util,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nSwatch = require('./swatch');\n\nutil = require('./util');\n\nDefaultGenerator = require('./generator').Default;\n\nFilter = require('./filter');\n\nmodule.exports = Vibrant = (function() {\n  Vibrant.DefaultOpts = {\n    colorCount: 64,\n    quality: 5,\n    generator: new DefaultGenerator(),\n    Image: null,\n    Quantizer: require('./quantizer').MMCQ,\n    filters: []\n  };\n\n  Vibrant.from = function(src) {\n    return new Builder(src);\n  };\n\n  Vibrant.prototype.quantize = require('quantize');\n\n  Vibrant.prototype._swatches = [];\n\n  function Vibrant(sourceImage, opts) {\n    this.sourceImage = sourceImage;\n    if (opts == null) {\n      opts = {};\n    }\n    this.swatches = bind(this.swatches, this);\n    this.opts = util.defaults(opts, this.constructor.DefaultOpts);\n    this.generator = this.opts.generator;\n  }\n\n  Vibrant.prototype.getPalette = function(cb) {\n    var image;\n    return image = new this.opts.Image(this.sourceImage, (function(_this) {\n      return function(err, image) {\n        var error;\n        if (err != null) {\n          return cb(err);\n        }\n        try {\n          _this._process(image, _this.opts);\n          return cb(null, _this.swatches());\n        } catch (_error) {\n          error = _error;\n          return cb(error);\n        }\n      };\n    })(this));\n  };\n\n  Vibrant.prototype.getSwatches = function(cb) {\n    return this.getPalette(cb);\n  };\n\n  Vibrant.prototype._process = function(image, opts) {\n    var imageData, quantizer, swatches;\n    image.scaleDown(this.opts);\n    imageData = image.getImageData();\n    quantizer = new this.opts.Quantizer();\n    quantizer.initialize(imageData.data, this.opts);\n    swatches = quantizer.getQuantizedColors();\n    this.generator.generate(swatches);\n    return image.removeCanvas();\n  };\n\n  Vibrant.prototype.swatches = function() {\n    return {\n      Vibrant: this.generator.getVibrantSwatch(),\n      Muted: this.generator.getMutedSwatch(),\n      DarkVibrant: this.generator.getDarkVibrantSwatch(),\n      DarkMuted: this.generator.getDarkMutedSwatch(),\n      LightVibrant: this.generator.getLightVibrantSwatch(),\n      LightMuted: this.generator.getLightMutedSwatch()\n    };\n  };\n\n  return Vibrant;\n\n})();\n\nmodule.exports.Builder = Builder = (function() {\n  function Builder(src1, opts1) {\n    this.src = src1;\n    this.opts = opts1 != null ? opts1 : {};\n    this.opts.filters = util.clone(Vibrant.DefaultOpts.filters);\n  }\n\n  Builder.prototype.maxColorCount = function(n) {\n    this.opts.colorCount = n;\n    return this;\n  };\n\n  Builder.prototype.maxDimension = function(d) {\n    this.opts.maxDimension = d;\n    return this;\n  };\n\n  Builder.prototype.addFilter = function(f) {\n    if (typeof f === 'function') {\n      this.opts.filters.push(f);\n    }\n    return this;\n  };\n\n  Builder.prototype.removeFilter = function(f) {\n    var i;\n    if ((i = this.opts.filters.indexOf(f)) > 0) {\n      this.opts.filters.splice(i);\n    }\n    return this;\n  };\n\n  Builder.prototype.clearFilters = function() {\n    this.opts.filters = [];\n    return this;\n  };\n\n  Builder.prototype.quality = function(q) {\n    this.opts.quality = q;\n    return this;\n  };\n\n  Builder.prototype.useImage = function(image) {\n    this.opts.Image = image;\n    return this;\n  };\n\n  Builder.prototype.useGenerator = function(generator) {\n    this.opts.generator = generator;\n    return this;\n  };\n\n  Builder.prototype.useQuantizer = function(quantizer) {\n    this.opts.Quantizer = quantizer;\n    return this;\n  };\n\n  Builder.prototype.build = function() {\n    if (this.v == null) {\n      this.v = new Vibrant(this.src, this.opts);\n    }\n    return this.v;\n  };\n\n  Builder.prototype.getSwatches = function(cb) {\n    return this.build().getPalette(cb);\n  };\n\n  Builder.prototype.getPalette = function(cb) {\n    return this.build().getPalette(cb);\n  };\n\n  Builder.prototype.from = function(src) {\n    return new Vibrant(src, this.opts);\n  };\n\n  return Builder;\n\n})();\n\nmodule.exports.Util = util;\n\nmodule.exports.Swatch = Swatch;\n\nmodule.exports.Quantizer = require('./quantizer/');\n\nmodule.exports.Generator = require('./generator/');\n\nmodule.exports.Filter = require('./filter/');\n","/*\r\n * quantize.js Copyright 2008 Nick Rabinowitz\r\n * Ported to node.js by Olivier Lesnicki\r\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\r\n */\r\n\r\n// fill out a couple protovis dependencies\r\n/*\r\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\r\n * Copyright 2010 Stanford Visualization Group\r\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\r\n */\r\nif (!pv) {\r\n    var pv = {\r\n        map: function(array, f) {\r\n            var o = {};\r\n            return f ? array.map(function(d, i) {\r\n                o.index = i;\r\n                return f.call(o, d);\r\n            }) : array.slice();\r\n        },\r\n        naturalOrder: function(a, b) {\r\n            return a - b;\r\n        },\r\n        sum: function(array, f) {\r\n            var o = {};\r\n            return array.reduce(f ? function(p, d, i) {\r\n                o.index = i;\r\n                return p + f.call(o, d);\r\n            } : function(p, d) {\r\n                return p + d;\r\n            }, 0);\r\n        },\r\n        max: function(array, f) {\r\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Basic Javascript port of the MMCQ (modified median cut quantization)\r\n * algorithm from the Leptonica library (http://www.leptonica.com/).\r\n * Returns a color map you can use to map original pixels to the reduced\r\n * palette. Still a work in progress.\r\n *\r\n * @author Nick Rabinowitz\r\n * @example\r\n\r\n// array of pixels as [R,G,B] arrays\r\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\r\n                // etc\r\n                ];\r\nvar maxColors = 4;\r\n\r\nvar cmap = MMCQ.quantize(myPixels, maxColors);\r\nvar newPalette = cmap.palette();\r\nvar newPixels = myPixels.map(function(p) {\r\n    return cmap.map(p);\r\n});\r\n\r\n */\r\nvar MMCQ = (function() {\r\n    // private constants\r\n    var sigbits = 5,\r\n        rshift = 8 - sigbits,\r\n        maxIterations = 1000,\r\n        fractByPopulations = 0.75;\r\n\r\n    // get reduced-space color index for a pixel\r\n\r\n    function getColorIndex(r, g, b) {\r\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\r\n    }\r\n\r\n    // Simple priority queue\r\n\r\n    function PQueue(comparator) {\r\n        var contents = [],\r\n            sorted = false;\r\n\r\n        function sort() {\r\n            contents.sort(comparator);\r\n            sorted = true;\r\n        }\r\n\r\n        return {\r\n            push: function(o) {\r\n                contents.push(o);\r\n                sorted = false;\r\n            },\r\n            peek: function(index) {\r\n                if (!sorted) sort();\r\n                if (index === undefined) index = contents.length - 1;\r\n                return contents[index];\r\n            },\r\n            pop: function() {\r\n                if (!sorted) sort();\r\n                return contents.pop();\r\n            },\r\n            size: function() {\r\n                return contents.length;\r\n            },\r\n            map: function(f) {\r\n                return contents.map(f);\r\n            },\r\n            debug: function() {\r\n                if (!sorted) sort();\r\n                return contents;\r\n            }\r\n        };\r\n    }\r\n\r\n    // 3d color space box\r\n\r\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\r\n        var vbox = this;\r\n        vbox.r1 = r1;\r\n        vbox.r2 = r2;\r\n        vbox.g1 = g1;\r\n        vbox.g2 = g2;\r\n        vbox.b1 = b1;\r\n        vbox.b2 = b2;\r\n        vbox.histo = histo;\r\n    }\r\n    VBox.prototype = {\r\n        volume: function(force) {\r\n            var vbox = this;\r\n            if (!vbox._volume || force) {\r\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\r\n            }\r\n            return vbox._volume;\r\n        },\r\n        count: function(force) {\r\n            var vbox = this,\r\n                histo = vbox.histo;\r\n            if (!vbox._count_set || force) {\r\n                var npix = 0,\r\n                    i, j, k;\r\n                for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                            index = getColorIndex(i, j, k);\r\n                            npix += histo[index];\r\n                        }\r\n                    }\r\n                }\r\n                vbox._count = npix;\r\n                vbox._count_set = true;\r\n            }\r\n            return vbox._count;\r\n        },\r\n        copy: function() {\r\n            var vbox = this;\r\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\r\n        },\r\n        avg: function(force) {\r\n            var vbox = this,\r\n                histo = vbox.histo;\r\n            if (!vbox._avg || force) {\r\n                var ntot = 0,\r\n                    mult = 1 << (8 - sigbits),\r\n                    // mult = (8 - sigbits),\r\n                    rsum = 0,\r\n                    gsum = 0,\r\n                    bsum = 0,\r\n                    hval,\r\n                    i, j, k, histoindex;\r\n                for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                            histoindex = getColorIndex(i, j, k);\r\n                            hval = histo[histoindex];\r\n                            ntot += hval;\r\n                            rsum += (hval * (i + 0.5) * mult);\r\n                            gsum += (hval * (j + 0.5) * mult);\r\n                            bsum += (hval * (k + 0.5) * mult);\r\n                        }\r\n                    }\r\n                }\r\n                if (ntot) {\r\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\r\n                } else {\r\n                    //console.log('empty box');\r\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\r\n                }\r\n            }\r\n            return vbox._avg;\r\n        },\r\n        contains: function(pixel) {\r\n            var vbox = this,\r\n                rval = pixel[0] >> rshift;\r\n            gval = pixel[1] >> rshift;\r\n            bval = pixel[2] >> rshift;\r\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\r\n                gval >= vbox.g1 && gval <= vbox.g2 &&\r\n                bval >= vbox.b1 && bval <= vbox.b2);\r\n        }\r\n    };\r\n\r\n    // Color map\r\n\r\n    function CMap() {\r\n        this.vboxes = new PQueue(function(a, b) {\r\n            return pv.naturalOrder(\r\n                a.vbox.count() * a.vbox.volume(),\r\n                b.vbox.count() * b.vbox.volume()\r\n            )\r\n        });;\r\n    }\r\n    CMap.prototype = {\r\n        push: function(vbox) {\r\n            this.vboxes.push({\r\n                vbox: vbox,\r\n                color: vbox.avg()\r\n            });\r\n        },\r\n        palette: function() {\r\n            return this.vboxes.map(function(vb) {\r\n                return vb.color\r\n            });\r\n        },\r\n        size: function() {\r\n            return this.vboxes.size();\r\n        },\r\n        map: function(color) {\r\n            var vboxes = this.vboxes;\r\n            for (var i = 0; i < vboxes.size(); i++) {\r\n                if (vboxes.peek(i).vbox.contains(color)) {\r\n                    return vboxes.peek(i).color;\r\n                }\r\n            }\r\n            return this.nearest(color);\r\n        },\r\n        nearest: function(color) {\r\n            var vboxes = this.vboxes,\r\n                d1, d2, pColor;\r\n            for (var i = 0; i < vboxes.size(); i++) {\r\n                d2 = Math.sqrt(\r\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\r\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\r\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\r\n                );\r\n                if (d2 < d1 || d1 === undefined) {\r\n                    d1 = d2;\r\n                    pColor = vboxes.peek(i).color;\r\n                }\r\n            }\r\n            return pColor;\r\n        },\r\n        forcebw: function() {\r\n            // XXX: won't  work yet\r\n            var vboxes = this.vboxes;\r\n            vboxes.sort(function(a, b) {\r\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\r\n            });\r\n\r\n            // force darkest color to black if everything < 5\r\n            var lowest = vboxes[0].color;\r\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\r\n                vboxes[0].color = [0, 0, 0];\r\n\r\n            // force lightest color to white if everything > 251\r\n            var idx = vboxes.length - 1,\r\n                highest = vboxes[idx].color;\r\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\r\n                vboxes[idx].color = [255, 255, 255];\r\n        }\r\n    };\r\n\r\n\r\n    function getAll(pixels, shouldIgnore) {\r\n        var histosize = 1 << (3 * sigbits),\r\n            histo = new Uint32Array(histosize),\r\n            index, rval, gval, bval;\r\n        var rmin = 1000000,\r\n            rmax = 0,\r\n            gmin = 1000000,\r\n            gmax = 0,\r\n            bmin = 1000000,\r\n            bmax = 0;\r\n\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        } else {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        }\r\n\r\n        return {\r\n          histo: histo,\r\n          vbox: new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo)\r\n        };\r\n    }\r\n\r\n    // histo (1-d array, giving the number of pixels in\r\n    // each quantized region of color space), or null on error\r\n\r\n    function getHisto(pixels, shouldIgnore) {\r\n        var histosize = 1 << (3 * sigbits),\r\n            histo = new Uint32Array(histosize),\r\n            index, rval, gval, bval;\r\n\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n          }\r\n        } else {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n          }\r\n        }\r\n\r\n        return histo;\r\n    }\r\n\r\n    function vboxFromPixels(pixels, histo, shouldIgnore) {\r\n        var rmin = 1000000,\r\n            rmax = 0,\r\n            gmin = 1000000,\r\n            gmax = 0,\r\n            bmin = 1000000,\r\n            bmax = 0,\r\n            rval, gval, bval;\r\n        // find min/max\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        } else {\r\n            while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        }\r\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\r\n    }\r\n\r\n    function medianCutApply(histo, vbox) {\r\n        if (!vbox.count()) return;\r\n\r\n        var rw = vbox.r2 - vbox.r1 + 1,\r\n            gw = vbox.g2 - vbox.g1 + 1,\r\n            bw = vbox.b2 - vbox.b1 + 1,\r\n            maxw = pv.max([rw, gw, bw]);\r\n        // only one pixel, no split\r\n        if (vbox.count() == 1) {\r\n            return [vbox.copy()]\r\n        }\r\n        /* Find the partial sum arrays along the selected axis. */\r\n        var total = 0,\r\n            partialsum,\r\n            lookaheadsum,\r\n            i, j, k, sum, index;\r\n        // var D = ['r', 'g', 'b'],\r\n        //   indexer = getColorIndex;\r\n        // if (maxw == gw) {\r\n        //   D = ['g', 'r', 'b'];\r\n        //   indexer = function(g, r, b) { return getColorIndex(r, g, b); };\r\n        // } else if (maxw == bw) {\r\n        //   indexer = function(b, r, g) { return getColorIndex(r, g, b); };\r\n        //   D = ['b', 'r', 'g'];\r\n        // }\r\n        // partialsum = new Uint32Array(vbox[D[0] + \"2\"] + 1);\r\n        // console.log(vbox[D[0] + \"2\"])\r\n        // for (i = vbox[D[0] + \"1\"]; i <= vbox[D[0] + \"2\"]; i++) {\r\n        //     sum = 0;\r\n        //     for (j = vbox[D[1] + \"1\"]; j <= vbox[D[1] + \"2\"]; j++) {\r\n        //         for (k = vbox[D[2] + \"1\"]; k <= vbox[D[2] + \"2\"]; k++) {\r\n        //             index = indexer(i, j, k);\r\n        //             sum += histo[index];\r\n        //         }\r\n        //     }\r\n        //     total += sum;\r\n        //     console.log(i + \"->\" + total)\r\n        //     partialsum[i] = total;\r\n        // }\r\n        var maxd = 'b';\r\n        if (maxw == rw) {\r\n            maxd = 'r';\r\n            partialsum = new Uint32Array(vbox.r2 + 1);\r\n            for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                        index = getColorIndex(i, j, k);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        } else if (maxw == gw) {\r\n            maxd = 'g';\r\n            partialsum = new Uint32Array(vbox.g2 + 1);\r\n            for (i = vbox.g1; i <= vbox.g2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.r1; j <= vbox.r2; j++) {\r\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                        index = getColorIndex(j, i, k);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        } else { /* maxw == bw */\r\n            // maxd = 'b';\r\n            partialsum = new Uint32Array(vbox.b2 + 1);\r\n            for (i = vbox.b1; i <= vbox.b2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.r1; j <= vbox.r2; j++) {\r\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\r\n                        index = getColorIndex(j, k, i);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        }\r\n        var splitPoint = -1;\r\n        lookaheadsum = new Uint32Array(partialsum.length);\r\n        for (i = 0; i < partialsum.length; i++) {\r\n          var d = partialsum[i];\r\n          if (splitPoint < 0 && d > (total / 2)) splitPoint = i;\r\n          lookaheadsum[i] = total - d\r\n        }\r\n        // partialsum.forEach(function(d, i) {\r\n        //   if (splitPoint < 0 && d > (total / 2)) splitPoint = i\r\n        //     lookaheadsum[i] = total - d\r\n        // });\r\n\r\n        // console.log('cut')\r\n        function doCut(color) {\r\n            var dim1 = color + '1',\r\n                dim2 = color + '2',\r\n                left, right, vbox1, vbox2, d2, count2 = 0,\r\n                i = splitPoint;\r\n            vbox1 = vbox.copy();\r\n            vbox2 = vbox.copy();\r\n            left = i - vbox[dim1];\r\n            right = vbox[dim2] - i;\r\n            if (left <= right) {\r\n                d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\r\n                d2 = Math.max(0, d2);\r\n            } else {\r\n                d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\r\n                d2 = Math.min(vbox[dim2], d2);\r\n            }\r\n            // console.log(partialsum[d2])\r\n            // avoid 0-count boxes\r\n            while (!partialsum[d2]) d2++;\r\n            count2 = lookaheadsum[d2];\r\n            // console.log('-_-')\r\n            while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\r\n            // set dimensions\r\n            vbox1[dim2] = d2;\r\n            vbox2[dim1] = vbox1[dim2] + 1;\r\n            // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\r\n            return [vbox1, vbox2];\r\n\r\n        }\r\n        // determine the cut planes\r\n        return doCut(maxd);\r\n        // return maxw == rw ? doCut('r') :\r\n        //     maxw == gw ? doCut('g') :\r\n        //     doCut('b');\r\n    }\r\n\r\n    function quantize(pixels, opts) {\r\n        var maxcolors = opts.colorCount;\r\n        // short-circuit\r\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\r\n            // console.log('wrong number of maxcolors');\r\n            return false;\r\n        }\r\n\r\n        var hasFilters = Array.isArray(opts.filters) && opts.filters.length > 0;\r\n        function shouldIgnore(r, g, b, a) {\r\n          for (var i = 0; i < opts.filters.length; i++) {\r\n            var f = opts.filters[i];\r\n            if (!f(r, g, b, a)) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        }\r\n\r\n        var r = getAll(pixels, hasFilters ? houldIgnore : null);\r\n        // XXX: check color content and convert to grayscale if insufficient\r\n\r\n        // var histo = getHisto(pixels, hasFilters ? shouldIgnore : null),\r\n        var histo = r.histo,\r\n            histosize = 1 << (3 * sigbits);\r\n\r\n        // check that we aren't below maxcolors already\r\n        var nColors = Object.keys(histo).length;\r\n        if (nColors <= maxcolors) {\r\n            // XXX: generate the new colors from the histo and return\r\n        }\r\n\r\n        // get the beginning vbox from the colors\r\n        // var vbox = vboxFromPixels(pixels, histo, hasFilters ? shouldIgnore : null),\r\n        var vbox = r.vbox,\r\n            pq = new PQueue(function(a, b) {\r\n                return pv.naturalOrder(a.count(), b.count())\r\n            });\r\n        pq.push(vbox);\r\n\r\n        // inner function to do the iteration\r\n\r\n        function iter(lh, target) {\r\n            var ncolors = 1,\r\n                niters = 0,\r\n                vbox;\r\n            while (niters < maxIterations) {\r\n                vbox = lh.pop();\r\n                if (!vbox.count()) { /* just put it back */\r\n                    // lh.push(vbox); // Maybe not\r\n                    niters++;\r\n                    continue;\r\n                }\r\n                // do the cut\r\n                var vboxes = medianCutApply(histo, vbox),\r\n                    vbox1 = vboxes[0],\r\n                    vbox2 = vboxes[1];\r\n\r\n                if (!vbox1) {\r\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\r\n                    return;\r\n                }\r\n                lh.push(vbox1);\r\n                if (vbox2) { /* vbox2 can be null */\r\n                    lh.push(vbox2);\r\n                    ncolors++;\r\n                }\r\n                if (ncolors >= target) return;\r\n                if (niters++ > maxIterations) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // first set of colors, sorted by population\r\n        iter(pq, fractByPopulations * maxcolors);\r\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\r\n\r\n        // Re-sort by the product of pixel occupancy times the size in color space.\r\n        var pq2 = new PQueue(function(a, b) {\r\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\r\n        });\r\n        while (pq.size()) {\r\n            pq2.push(pq.pop());\r\n        }\r\n\r\n        // next set - generate the median cuts using the (npix * vol) sorting.\r\n        iter(pq2, maxcolors - pq2.size());\r\n\r\n        // calculate the actual colors\r\n        var cmap = new CMap();\r\n        while (pq2.size()) {\r\n            var v = pq2.pop(),\r\n              c = vbox.avg();\r\n            if (!hasFilters || !shouldIgnore(c[0], c[1], c[2], 255)) {\r\n              cmap.push(v);\r\n            }\r\n        }\r\n\r\n        return cmap;\r\n    }\r\n\r\n    return {\r\n        quantize: quantize,\r\n        getAll: getAll,\r\n        medianCutApply: medianCutApply\r\n    }\r\n})();\r\n\r\nmodule.exports = MMCQ.quantize\r\nmodule.exports.getAll = MMCQ.getAll\r\nmodule.exports.splitBox = MMCQ.medianCutApply\r\n","  /* globals require, module */\n\n  'use strict';\n\n  /**\n   * Module dependencies.\n   */\n\n  var pathtoRegexp = require('path-to-regexp');\n\n  /**\n   * Module exports.\n   */\n\n  module.exports = page;\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var location = ('undefined' !== typeof window) && (window.history.location || window.location);\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n\n  /**\n   * Decode URL components (query string, pathname, hash).\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\n   */\n  var decodeURLComponents = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * HashBang option\n   */\n\n  var hashbang = false;\n\n  /**\n   * Previous context, for capturing\n   * page exit events.\n   */\n\n  var prevContext;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {String|Function} path\n   * @param {Function} fn...\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(path);\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n  page.exits = [];\n\n  /**\n   * Current path being processed\n   * @type {String}\n   */\n  page.current = '';\n\n  /**\n   * Number of pages navigated to.\n   * @type {number}\n   *\n   *     page.len == 0;\n   *     page('/login');\n   *     page.len == 1;\n   */\n\n  page.len = 0;\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {String} path\n   * @api public\n   */\n\n  page.base = function(path) {\n    if (0 === arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options) {\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click) {\n      document.addEventListener(clickEvent, onclick, false);\n    }\n    if (true === options.hashbang) hashbang = true;\n    if (!dispatch) return;\n    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function() {\n    if (!running) return;\n    page.current = '';\n    page.len = 0;\n    running = false;\n    document.removeEventListener(clickEvent, onclick, false);\n    window.removeEventListener('popstate', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @param {Boolean} dispatch\n   * @return {Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    if (false !== dispatch) page.dispatch(ctx);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {String} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object} [state]\n   * @api public\n   */\n\n  page.back = function(path, state) {\n    if (page.len > 0) {\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      history.back();\n      page.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    }else{\n      setTimeout(function() {\n        page.show(base, state);\n      });\n    }\n  };\n\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {String} from - if param 'to' is undefined redirects to 'from'\n   * @param {String} [to]\n   * @api public\n   */\n  page.redirect = function(from, to) {\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page(from, function(e) {\n        setTimeout(function() {\n          page.replace(to);\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        page.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @return {Context}\n   * @api public\n   */\n\n\n  page.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) page.dispatch(ctx);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Object} ctx\n   * @api private\n   */\n\n  page.dispatch = function(ctx) {\n    var prev = prevContext,\n      i = 0,\n      j = 0;\n\n    prevContext = ctx;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled(ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n\n    if (hashbang) {\n      current = base + location.hash.replace('#!', '');\n    } else {\n      current = location.pathname + location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    location.href = ctx.canonicalPath;\n  }\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  page.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return page.exit('*', path);\n    }\n\n    var route = new Route(path);\n    for (var i = 1; i < arguments.length; ++i) {\n      page.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {str} URL component to decode\n   */\n  function decodeURLEncodedURIComponent(val) {\n    if (typeof val !== 'string') { return val; }\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = parts[0];\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    page.len++;\n    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @param {String} path\n   * @param {Object} options.\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(this.path,\n      this.keys = [],\n      options.sensitive,\n      options.strict);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {String} path\n   * @param {Object} params\n   * @return {Boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  var onpopstate = (function () {\n    var loaded = false;\n    if ('undefined' === typeof window) {\n      return;\n    }\n    if (document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else {\n        page.show(location.pathname + location.hash, undefined, undefined, false);\n      }\n    };\n  })();\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n\n    if (1 !== which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n\n\n    // ensure link\n    var el = e.target;\n    while (el && 'A' !== el.nodeName) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName) return;\n\n\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;\n\n\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    if (el.target) return;\n\n    // x-origin\n    if (!sameOrigin(el.href)) return;\n\n\n\n    // rebuild path\n    var path = el.pathname + el.search + (el.hash || '');\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n\n    if (path.indexOf(base) === 0) {\n      path = path.substr(base.length);\n    }\n\n    if (hashbang) path = path.replace('#!', '');\n\n    if (base && orig === path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null === e.which ? e.button : e.which;\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return (href && (0 === href.indexOf(origin)));\n  }\n\n  page.sameOrigin = sameOrigin;\n","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n\n// fill out a couple protovis dependencies\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nif (!pv) {\n    var pv = {\n        map: function(array, f) {\n            var o = {};\n            return f ? array.map(function(d, i) {\n                o.index = i;\n                return f.call(o, d);\n            }) : array.slice();\n        },\n        naturalOrder: function(a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function(array, f) {\n            var o = {};\n            return array.reduce(f ? function(p, d, i) {\n                o.index = i;\n                return p + f.call(o, d);\n            } : function(p, d) {\n                return p + d;\n            }, 0);\n        },\n        max: function(array, f) {\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    }\n}\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\nvar MMCQ = (function() {\n    // private constants\n    var sigbits = 5,\n        rshift = 8 - sigbits,\n        maxIterations = 1000,\n        fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n\n    function PQueue(comparator) {\n        var contents = [],\n            sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function(o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function(index) {\n                if (!sorted) sort();\n                if (index === undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function() {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function() {\n                return contents.length;\n            },\n            map: function(f) {\n                return contents.map(f);\n            },\n            debug: function() {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function(force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0,\n                    i, j, k;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            index = getColorIndex(i, j, k);\n                            npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function() {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0,\n                    mult = 1 << (8 - sigbits),\n                    rsum = 0,\n                    gsum = 0,\n                    bsum = 0,\n                    hval,\n                    i, j, k, histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            histoindex = getColorIndex(i, j, k);\n                            hval = histo[histoindex] || 0;\n                            ntot += hval;\n                            rsum += (hval * (i + 0.5) * mult);\n                            gsum += (hval * (j + 0.5) * mult);\n                            bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\n                } else {\n                    //console.log('empty box');\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function(pixel) {\n            var vbox = this,\n                rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                gval >= vbox.g1 && gval <= vbox.g2 &&\n                bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n\n    function CMap() {\n        this.vboxes = new PQueue(function(a, b) {\n            return pv.naturalOrder(\n                a.vbox.count() * a.vbox.volume(),\n                b.vbox.count() * b.vbox.volume()\n            )\n        });;\n    }\n    CMap.prototype = {\n        push: function(vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function() {\n            return this.vboxes.map(function(vb) {\n                return vb.color\n            });\n        },\n        size: function() {\n            return this.vboxes.size();\n        },\n        map: function(color) {\n            var vboxes = this.vboxes;\n            for (var i = 0; i < vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function(color) {\n            var vboxes = this.vboxes,\n                d1, d2, pColor;\n            for (var i = 0; i < vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function() {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function(a, b) {\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\n            });\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0, 0, 0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length - 1,\n                highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255, 255, 255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits),\n            histo = new Array(histosize),\n            index, rval, gval, bval;\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin = 1000000,\n            rmax = 0,\n            gmin = 1000000,\n            gmax = 0,\n            bmin = 1000000,\n            bmax = 0,\n            rval, gval, bval;\n        // find min/max\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax) bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1,\n            gw = vbox.g2 - vbox.g1 + 1,\n            bw = vbox.b2 - vbox.b1 + 1,\n            maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()]\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0,\n            partialsum = [],\n            lookaheadsum = [],\n            i, j, k, sum, index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i, j, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j, i, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else { /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j, k, i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function(d, i) {\n            lookaheadsum[i] = total - d\n        });\n\n        function doCut(color) {\n            var dim1 = color + '1',\n                dim2 = color + '2',\n                left, right, vbox1, vbox2, d2, count2 = 0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n                    // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n            doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n            // console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels),\n            histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function() {\n            nColors++\n        });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo),\n            pq = new PQueue(function(a, b) {\n                return pv.naturalOrder(a.count(), b.count())\n            });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n\n        function iter(lh, target) {\n            var ncolors = 1,\n                niters = 0,\n                vbox;\n            while (niters < maxIterations) {\n                vbox = lh.pop();\n                if (!vbox.count()) { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox),\n                    vbox1 = vboxes[0],\n                    vbox2 = vboxes[1];\n\n                if (!vbox1) {\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) { /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n                    // console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function(a, b) {\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors - pq2.size());\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    }\n})();\n\nmodule.exports = MMCQ.quantize\n","(function() {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this._initBody(bodyInit)\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      xhr.onload = function() {\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})();\n","import page from 'page';\r\nimport fetch from 'whatwg-fetch';\r\nimport Tabs from './js/tabs.js';\r\nimport Vibrant from 'node-vibrant';\r\nimport FigureBg from './js/figure-bg.js';\r\nimport imgFill from './js/vendor/imgfill.js';\r\n\r\nFigureBg();\r\n\r\n\r\n\r\nfunction ToggleNav() {\r\n\tconst navToggle = document.querySelector('.js-navToggle');\r\n\tconst MobileNav = document.querySelector('.MobileNav');\r\n\tconst navToggleClose = document.querySelector('.js-navToggleClose');\r\n\t\r\n\tnavToggle.addEventListener('click', function(evt) {\r\n\t\tevt.preventDefault();\r\n\t\tMobileNav.classList.add('is-active');\r\n\t}, false);\r\n\r\n\tnavToggleClose.addEventListener('click', function(evt) {\r\n\t\tevt.preventDefault();\r\n\t\tMobileNav.classList.remove('is-active');\r\n\t}, false);\r\n}\r\n\r\nToggleNav();\r\nimgFill('.imgFill', '.imgFillSrc');","import Vibrant from 'node-vibrant';\r\n\r\nconst FigureBg = () => {\r\n  const Figures = Array.from(document.querySelectorAll('.Figure--slideDown'));\r\n  for (let Figure of Figures) {\r\n    const imgSrc = Figure.querySelector('img').getAttribute('src');\r\n    const FigCaption = Figure.querySelector('figcaption');\r\n\r\n    const bgColor = new Vibrant(imgSrc);\r\n    bgColor.getPalette(( err, palette ) => {\r\n      if (err) {\r\n        FigCaption.style.backgroundColor('#ffffff');\r\n      } else {\r\n        const hexColor = palette.Vibrant.rgb.join();\r\n        const bodyColor = palette.Vibrant.getTitleTextColor();\r\n        FigCaption.style.backgroundColor = 'rgba(' + hexColor + ', 1)';\r\n        FigCaption.style.color = bodyColor;\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nexport default FigureBg;\r\n","\r\nconst childHidden = (el) => {\r\n  const elHidden = document.querySelectorAll(el);\r\n  for (let i = 0; i < elHidden.length; i++) {\r\n    elHidden[i].style.display = 'none';\r\n  }\r\n};\r\n\r\n\r\nconst Tabs = () => {\r\n  const Tab = document.querySelector('.Tab');\r\n  const TabAchor = Tab.querySelector('.TabAchor');\r\n  const TabContent = Tab.querySelector('.TabContent');\r\n\r\n\r\n}\r\n\r\nexport default Tabs;\r\n","'use strict';\r\n\r\n// usage:\r\n// imgFill(target, imgSrc)\r\n// require es6\r\n\r\n\r\n\r\nconst setCSS = (element) => {\r\n  let CSS = {\r\n    backgroundSize: \"cover\",\r\n    backgroundPosition: \"center\",\r\n    backgroundRepeat: \"no-repeat\"\r\n  };\r\n  // create multiple CSS Property\r\n  for (let i in CSS) {\r\n    element.style[i] = CSS[i];\r\n  }\r\n};\r\n\r\nconst imgFill = (target, srcClass) => {\r\n  let imgConts = Array.from(document.querySelectorAll(target));\r\n  for (let img of imgConts) {\r\n\r\n    // define image source class\r\n    let imgSrc = img.querySelector(srcClass);\r\n\r\n    // Get image source url\r\n    let imgSrcURL = imgSrc.getAttribute('src');\r\n\r\n    // hide source images\r\n    imgSrc.style.display = 'none';\r\n    // Set Multiple CSS Property\r\n    img.style.backgroundImage = 'url(' + imgSrcURL + ')';\r\n    setCSS(img);\r\n  }\r\n};\r\n\r\nexport default imgFill;"]}