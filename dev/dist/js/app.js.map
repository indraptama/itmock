{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/isarray/index.js","app.js","node_modules/node-vibrant/lib/browser.js","node_modules/node-vibrant/lib/filter/default.js","node_modules/node-vibrant/lib/filter/index.js","node_modules/node-vibrant/lib/generator/default.js","node_modules/node-vibrant/lib/generator/index.js","node_modules/node-vibrant/lib/image/browser.js","node_modules/node-vibrant/lib/image/index.js","node_modules/node-vibrant/lib/quantizer/baseline.js","node_modules/node-vibrant/lib/quantizer/color-cut.js","node_modules/node-vibrant/lib/quantizer/impl/color-cut.js","node_modules/node-vibrant/lib/quantizer/impl/mmcq.js","node_modules/node-vibrant/lib/quantizer/impl/pqueue.js","node_modules/node-vibrant/lib/quantizer/impl/vbox.js","node_modules/node-vibrant/lib/quantizer/index.js","node_modules/node-vibrant/lib/quantizer/mmcq.js","node_modules/node-vibrant/lib/quantizer/nocopy.js","node_modules/node-vibrant/lib/swatch.js","node_modules/node-vibrant/lib/util.js","node_modules/node-vibrant/lib/vibrant.js","node_modules/node-vibrant/vendor-mod/quantize.js","node_modules/page/index.js","node_modules/path-to-regexp/index.js","node_modules/process/browser.js","node_modules/quantize/quantize.js","node_modules/whatwg-fetch/fetch.js","src/index.js","src/js/figure-bg.js","src/js/tabs.js","src/js/vendor/imgfill.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","Array","isArray","arr","Object","prototype","toString",2,"Vibrant","DefaultOpts","Image","./image/browser","./vibrant",3,"g","b",4,"Default","./default",5,"DefaultGenerator","Generator","Swatch","util","extend","child","parent","ctor","this","constructor","key","hasProp","__super__","hasOwnProperty","slice","targetDarkLuma","maxDarkLuma","minLightLuma","targetLightLuma","minNormalLuma","targetNormalLuma","maxNormalLuma","targetMutesSaturation","maxMutesSaturation","targetVibrantSaturation","minVibrantSaturation","weightSaturation","weightLuma","weightPopulation","superClass","opts","defaults","VibrantSwatch","LightVibrantSwatch","DarkVibrantSwatch","MutedSwatch","LightMutedSwatch","DarkMutedSwatch","HighestPopulation","generate","swatches","maxPopulation","findMaxPopulation","generateVarationColors","generateEmptySwatches","getVibrantSwatch","getLightVibrantSwatch","getDarkVibrantSwatch","getMutedSwatch","getLightMutedSwatch","getDarkMutedSwatch","findColorVariation","hsl","getHsl","hslToRgb","j","len","population","ref","swatch","Math","max","getPopulation","targetLuma","minLuma","maxLuma","targetSaturation","minSaturation","maxSaturation","luma","maxValue","sat","value","isAlreadySelected","createComparisonValue","saturation","weightedMean","invertDiff","targetValue","abs","sum","sumWeight","values","weight","arguments","../swatch","../util","./index",6,7,"BrowserImage","path","cb","img","document","createElement","crossOrigin","src","onload","_this","_initCanvas","onerror","err","raw","canvas","context","getContext","body","appendChild","width","height","drawImage","clear","clearRect","getWidth","getHeight","resize","w","h","scale","update","imageData","putImageData","getPixelCount","getImageData","removeCanvas","parentNode","removeChild",8,"scaleDown","maxSide","ratio","maxDimension","quality",9,"BaselineQuantizer","Quantizer","quantize","apply","initialize","pixels","allPixels","cmap","offset","pixelCount","push","colorCount","vboxes","map","vbox","color","count","getQuantizedColors",10,"ColorCut","ColorCutQuantizer","buf","buf8","data","ArrayBuffer","Uint8ClampedArray","Uint32Array","set","quantizer","./impl/color-cut",11,"ABGRColor","COMPONENT_BLUE","COMPONENT_GREEN","COMPONENT_RED","Color","QUANTIZE_WORD_MASK","QUANTIZE_WORD_WIDTH","RGBAColor","Vbox","approximateToRgb888","isLittleEndian","modifySignificantOctet","modifyWordWidth","quantizeFromRgb888","quantizedBlue","quantizedGreen","quantizedRed","sort","lower","upper","partition","pivot","swap","left","right","index","ref1","v","ceil","red","c","green","blue","alpha","Uint8Array","current","target","newValue","dimension","k","ref2","ref3","distinctColorCount","distinctColorIndex","m","quantizedColor","hist","colors","quantizedColors","quantizePixels","maxColors","pq","PriorityQueue","comparator","queue","splitBoxes","generateAverageColors","maxSize","dequeue","canSplit","splitBox","getAverageColor","colors1","lowerIndex","upperIndex","fitBox","lhs","rhs","getVolume","maxRed","minRed","maxGreen","minGreen","maxBlue","minBlue","getColorCount","Number","MAX_VALUE","MIN_VALUE","newBox","splitPoint","findSplitPoint","getLongestColorDimension","blueLength","greenLength","redLength","longestDimension","midPoint","blueMean","blueSum","colorPopulation","greenMean","greenSum","redMean","redSum","totalPopulation","round","../../swatch",12,"MMCQ","PQueue","RSHIFT","SIGBITS","VBox","getColorIndex","maxIterations","fractByPopulations","pq2","shouldIgnore","filters","build","keys","_splitBoxes","volume","contents","size","pop","avg","iteration","vbox1","vbox2","split","../../util","./pqueue","./vbox",13,"sorted","_sort","peek",14,"r1","r2","g1","g2","b1","b2","hist1","bmax","bmin","gmax","gmin","hn","rmax","rmin","invalidate","_count","_avg","_volume","clone","bsum","gsum","mult","ntot","rsum","accSum","bw","d","doCut","gw","maxd","maxw","reverseSum","rw","total","c2","d1","d2","dim1","dim2","min","contains","p",15,"Baseline","NoCopy","./baseline","./color-cut","./mmcq","./nocopy",16,"MMCQImpl","mmcq","./impl/mmcq",17,"NoCopyQuantizer","../../vendor-mod/quantize",18,"rgb","yiq","rgbToHsl","getRgb","getHex","rgbToHex","getTitleTextColor","_ensureTextColors","getBodyTextColor","./util",19,"DELTAE94","NA","PERFECT","CLOSE","GOOD","SIMILAR","_o","hexToRgb","hex","exec","parseInt","hue2rgb","q","rgbToXyz","x","y","z","pow","xyzToCIELab","L","REF_X","REF_Y","REF_Z","rgbToCIELab","deltaE94","lab1","lab2","L1","L2","WEIGHT_C","WEIGHT_H","WEIGHT_L","a1","a2","dL","da","db","xC1","xC2","xDC","xDE","xDH","xDL","xSC","xSH","sqrt","rgbDiff","rgb1","rgb2","hexDiff","hex1","hex2","DELTAE94_DIFF_STATUS","getColorDiffStatus",20,"Builder","Filter","bind","fn","me","sourceImage","generator","from","_swatches","getPalette","image","error","_process","_error","getSwatches","Muted","DarkVibrant","DarkMuted","LightVibrant","LightMuted","src1","opts1","maxColorCount","addFilter","removeFilter","indexOf","splice","clearFilters","useImage","useGenerator","useQuantizer","Util","./filter","./filter/","./generator","./generator/","./quantizer","./quantizer/","./swatch",21,"pv","array","naturalOrder","reduce","sigbits","undefined","debug","histo","CMap","getAll","rval","gval","bval","histosize","rshift","medianCutApply","count2","copy","partialsum","lookaheadsum","iter","lh","ncolors","niters","maxcolors","hasFilters","houldIgnore","force","_count_set","npix","hval","histoindex","pixel","palette","vb","nearest","pColor","forcebw","lowest","idx","highest",22,"process","page","route","Route","callbacks","middleware","start","unhandled","ctx","handled","hashbang","base","location","hash","replace","pathname","search","canonicalPath","stop","href","decodeURLEncodedURIComponent","val","decodeURLComponents","decodeURIComponent","Context","state","title","querystring","params","parts","options","method","regexp","pathtoRegexp","sensitive","strict","onclick","which","metaKey","ctrlKey","shiftKey","defaultPrevented","el","nodeName","hasAttribute","getAttribute","link","sameOrigin","match","orig","substr","preventDefault","show","window","event","button","origin","protocol","hostname","port","running","prevContext","clickEvent","ontouchstart","history","dispatch","exits","popstate","addEventListener","onpopstate","click","url","removeEventListener","pushState","back","setTimeout","redirect","to","init","save","nextExit","prev","nextEnter","exit","replaceState","self","next","qsIndex","name","loaded","readyState","path-to-regexp",23,"parse","str","res","tokens","PATH_REGEXP","escaped","prefix","capture","group","suffix","asterisk","repeat","optional","delimiter","pattern","escapeGroup","compile","tokensToFunction","matches","RegExp","obj","token","segment","TypeError","isarray","encodeURIComponent","test","escapeString","attachKeys","re","flags","regexpToRegexp","groups","source","arrayToRegexp","pathToRegexp","join","stringToRegexp","tokensToRegExp","end","lastToken","endsWithSlash",24,"cleanUpNextTick","draining","currentQueue","concat","queueIndex","drainQueue","timeout","run","clearTimeout","Item","fun","noop","nextTick","args","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask",25,"getHisto","forEach","vboxFromPixels","nColors",26,"normalizeName","String","toLowerCase","normalizeValue","Headers","headers","append","getOwnPropertyNames","consumed","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","result","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","Body","_initBody","_bodyInit","_bodyText","support","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","arrayBuffer","rejected","then","text","decode","json","JSON","normalizeMethod","upcased","toUpperCase","methods","Request","input","credentials","mode","referrer","form","trim","bytes","shift","xhr","head","pairs","getAllResponseHeaders","header","Response","bodyInit","type","status","ok","statusText","fetch","list","get","has","callback","thisArg","response","redirectStatuses","RangeError","responseURL","getResponseHeader","request","XMLHttpRequest","responseText","open","withCredentials","responseType","setRequestHeader","send","polyfill",27,"_interopRequireDefault","__esModule","default","ToggleNav","navToggle","querySelector","MobileNav","navToggleClose","evt","classList","add","remove","_page","_whatwgFetch","_tabs","_nodeVibrant","_figureBg","_figureBg2","_imgfill","_imgfill2","particlesJS","load","console","log","./js/figure-bg.js","./js/tabs.js","./js/vendor/imgfill.js","node-vibrant","whatwg-fetch",28,"defineProperty","_nodeVibrant2","FigureBg","Figures","querySelectorAll","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_loop","Figure","imgSrc","FigCaption","bgColor","style","backgroundColor","hexColor","bodyColor","_iterator","Symbol","iterator","done",29,"Tabs","Tab",30,"setCSS","element","CSS","backgroundSize","backgroundPosition","backgroundRepeat","imgFill","srcClass","imgConts","imgSrcURL","display","backgroundImage"],"mappings":"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","file":"app.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],2:[function(require,module,exports){\nvar Vibrant;\n\nVibrant = require('./vibrant');\n\nVibrant.DefaultOpts.Image = require('./image/browser');\n\nmodule.exports = Vibrant;\n\n},{\"./image/browser\":7,\"./vibrant\":20}],3:[function(require,module,exports){\nmodule.exports = function(r, g, b, a) {\n  return a >= 125 && !(r > 250 && g > 250 && b > 250);\n};\n\n},{}],4:[function(require,module,exports){\nmodule.exports.Default = require('./default');\n\n},{\"./default\":3}],5:[function(require,module,exports){\nvar DefaultGenerator, DefaultOpts, Generator, Swatch, util,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\nSwatch = require('../swatch');\n\nutil = require('../util');\n\nGenerator = require('./index');\n\nDefaultOpts = {\n  targetDarkLuma: 0.26,\n  maxDarkLuma: 0.45,\n  minLightLuma: 0.55,\n  targetLightLuma: 0.74,\n  minNormalLuma: 0.3,\n  targetNormalLuma: 0.5,\n  maxNormalLuma: 0.7,\n  targetMutesSaturation: 0.3,\n  maxMutesSaturation: 0.4,\n  targetVibrantSaturation: 1.0,\n  minVibrantSaturation: 0.35,\n  weightSaturation: 3,\n  weightLuma: 6,\n  weightPopulation: 1\n};\n\nmodule.exports = DefaultGenerator = (function(superClass) {\n  extend(DefaultGenerator, superClass);\n\n  DefaultGenerator.prototype.HighestPopulation = 0;\n\n  function DefaultGenerator(opts) {\n    this.opts = util.defaults(opts, DefaultOpts);\n    this.VibrantSwatch = null;\n    this.LightVibrantSwatch = null;\n    this.DarkVibrantSwatch = null;\n    this.MutedSwatch = null;\n    this.LightMutedSwatch = null;\n    this.DarkMutedSwatch = null;\n  }\n\n  DefaultGenerator.prototype.generate = function(swatches) {\n    this.swatches = swatches;\n    this.maxPopulation = this.findMaxPopulation;\n    this.generateVarationColors();\n    return this.generateEmptySwatches();\n  };\n\n  DefaultGenerator.prototype.getVibrantSwatch = function() {\n    return this.VibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getLightVibrantSwatch = function() {\n    return this.LightVibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getDarkVibrantSwatch = function() {\n    return this.DarkVibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getMutedSwatch = function() {\n    return this.MutedSwatch;\n  };\n\n  DefaultGenerator.prototype.getLightMutedSwatch = function() {\n    return this.LightMutedSwatch;\n  };\n\n  DefaultGenerator.prototype.getDarkMutedSwatch = function() {\n    return this.DarkMutedSwatch;\n  };\n\n  DefaultGenerator.prototype.generateVarationColors = function() {\n    this.VibrantSwatch = this.findColorVariation(this.opts.targetNormalLuma, this.opts.minNormalLuma, this.opts.maxNormalLuma, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.LightVibrantSwatch = this.findColorVariation(this.opts.targetLightLuma, this.opts.minLightLuma, 1, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.DarkVibrantSwatch = this.findColorVariation(this.opts.targetDarkLuma, 0, this.opts.maxDarkLuma, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.MutedSwatch = this.findColorVariation(this.opts.targetNormalLuma, this.opts.minNormalLuma, this.opts.maxNormalLuma, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n    this.LightMutedSwatch = this.findColorVariation(this.opts.targetLightLuma, this.opts.minLightLuma, 1, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n    return this.DarkMutedSwatch = this.findColorVariation(this.opts.targetDarkLuma, 0, this.opts.maxDarkLuma, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n  };\n\n  DefaultGenerator.prototype.generateEmptySwatches = function() {\n    var hsl;\n    if (this.VibrantSwatch === null) {\n      if (this.DarkVibrantSwatch !== null) {\n        hsl = this.DarkVibrantSwatch.getHsl();\n        hsl[2] = this.opts.targetNormalLuma;\n        this.VibrantSwatch = new Swatch(util.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);\n      }\n    }\n    if (this.DarkVibrantSwatch === null) {\n      if (this.VibrantSwatch !== null) {\n        hsl = this.VibrantSwatch.getHsl();\n        hsl[2] = this.opts.targetDarkLuma;\n        return this.DarkVibrantSwatch = new Swatch(util.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);\n      }\n    }\n  };\n\n  DefaultGenerator.prototype.findMaxPopulation = function() {\n    var j, len, population, ref, swatch;\n    population = 0;\n    ref = this.swatches;\n    for (j = 0, len = ref.length; j < len; j++) {\n      swatch = ref[j];\n      population = Math.max(population, swatch.getPopulation());\n    }\n    return population;\n  };\n\n  DefaultGenerator.prototype.findColorVariation = function(targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation) {\n    var j, len, luma, max, maxValue, ref, sat, swatch, value;\n    max = null;\n    maxValue = 0;\n    ref = this.swatches;\n    for (j = 0, len = ref.length; j < len; j++) {\n      swatch = ref[j];\n      sat = swatch.getHsl()[1];\n      luma = swatch.getHsl()[2];\n      if (sat >= minSaturation && sat <= maxSaturation && luma >= minLuma && luma <= maxLuma && !this.isAlreadySelected(swatch)) {\n        value = this.createComparisonValue(sat, targetSaturation, luma, targetLuma, swatch.getPopulation(), this.HighestPopulation);\n        if (max === null || value > maxValue) {\n          max = swatch;\n          maxValue = value;\n        }\n      }\n    }\n    return max;\n  };\n\n  DefaultGenerator.prototype.createComparisonValue = function(saturation, targetSaturation, luma, targetLuma, population, maxPopulation) {\n    return this.weightedMean(this.invertDiff(saturation, targetSaturation), this.opts.weightSaturation, this.invertDiff(luma, targetLuma), this.opts.weightLuma, population / maxPopulation, this.opts.weightPopulation);\n  };\n\n  DefaultGenerator.prototype.invertDiff = function(value, targetValue) {\n    return 1 - Math.abs(value - targetValue);\n  };\n\n  DefaultGenerator.prototype.weightedMean = function() {\n    var i, sum, sumWeight, value, values, weight;\n    values = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    sum = 0;\n    sumWeight = 0;\n    i = 0;\n    while (i < values.length) {\n      value = values[i];\n      weight = values[i + 1];\n      sum += value * weight;\n      sumWeight += weight;\n      i += 2;\n    }\n    return sum / sumWeight;\n  };\n\n  DefaultGenerator.prototype.isAlreadySelected = function(swatch) {\n    return this.VibrantSwatch === swatch || this.DarkVibrantSwatch === swatch || this.LightVibrantSwatch === swatch || this.MutedSwatch === swatch || this.DarkMutedSwatch === swatch || this.LightMutedSwatch === swatch;\n  };\n\n  return DefaultGenerator;\n\n})(Generator);\n\n},{\"../swatch\":18,\"../util\":19,\"./index\":6}],6:[function(require,module,exports){\nvar Generator;\n\nmodule.exports = Generator = (function() {\n  function Generator() {}\n\n  Generator.prototype.generate = function(swatches) {};\n\n  Generator.prototype.getVibrantSwatch = function() {};\n\n  Generator.prototype.getLightVibrantSwatch = function() {};\n\n  Generator.prototype.getDarkVibrantSwatch = function() {};\n\n  Generator.prototype.getMutedSwatch = function() {};\n\n  Generator.prototype.getLightMutedSwatch = function() {};\n\n  Generator.prototype.getDarkMutedSwatch = function() {};\n\n  return Generator;\n\n})();\n\nmodule.exports.Default = require('./default');\n\n},{\"./default\":5}],7:[function(require,module,exports){\nvar BrowserImage, Image,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nImage = require('./index');\n\nmodule.exports = BrowserImage = (function(superClass) {\n  extend(BrowserImage, superClass);\n\n  function BrowserImage(path, cb) {\n    this.img = document.createElement('img');\n    this.img.crossOrigin = 'anonymous';\n    this.img.src = path;\n    this.img.onload = (function(_this) {\n      return function() {\n        _this._initCanvas();\n        return typeof cb === \"function\" ? cb(null, _this) : void 0;\n      };\n    })(this);\n    this.img.onerror = (function(_this) {\n      return function(e) {\n        var err;\n        err = new Error(\"Fail to load image: \" + path);\n        err.raw = e;\n        return typeof cb === \"function\" ? cb(err) : void 0;\n      };\n    })(this);\n  }\n\n  BrowserImage.prototype._initCanvas = function() {\n    this.canvas = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n    document.body.appendChild(this.canvas);\n    this.width = this.canvas.width = this.img.width;\n    this.height = this.canvas.height = this.img.height;\n    return this.context.drawImage(this.img, 0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.clear = function() {\n    return this.context.clearRect(0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.getWidth = function() {\n    return this.width;\n  };\n\n  BrowserImage.prototype.getHeight = function() {\n    return this.height;\n  };\n\n  BrowserImage.prototype.resize = function(w, h, r) {\n    this.width = this.canvas.width = w;\n    this.height = this.canvas.height = h;\n    this.context.scale(r, r);\n    return this.context.drawImage(this.img, 0, 0);\n  };\n\n  BrowserImage.prototype.update = function(imageData) {\n    return this.context.putImageData(imageData, 0, 0);\n  };\n\n  BrowserImage.prototype.getPixelCount = function() {\n    return this.width * this.height;\n  };\n\n  BrowserImage.prototype.getImageData = function() {\n    return this.context.getImageData(0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.removeCanvas = function() {\n    return this.canvas.parentNode.removeChild(this.canvas);\n  };\n\n  return BrowserImage;\n\n})(Image);\n\n},{\"./index\":8}],8:[function(require,module,exports){\nvar Image;\n\nmodule.exports = Image = (function() {\n  function Image() {}\n\n  Image.prototype.clear = function() {};\n\n  Image.prototype.update = function(imageData) {};\n\n  Image.prototype.getWidth = function() {};\n\n  Image.prototype.getHeight = function() {};\n\n  Image.prototype.scaleDown = function(opts) {\n    var height, maxSide, ratio, width;\n    width = this.getWidth();\n    height = this.getHeight();\n    ratio = 1;\n    if (opts.maxDimension != null) {\n      maxSide = Math.max(width, height);\n      if (maxSide > opts.maxDimension) {\n        ratio = opts.maxDimension / maxSide;\n      }\n    } else {\n      ratio = 1 / opts.quality;\n    }\n    if (ratio < 1) {\n      return this.resize(width * ratio, height * ratio, ratio);\n    }\n  };\n\n  Image.prototype.resize = function(w, h, r) {};\n\n  Image.prototype.getPixelCount = function() {};\n\n  Image.prototype.getImageData = function() {};\n\n  Image.prototype.removeCanvas = function() {};\n\n  return Image;\n\n})();\n\n},{}],9:[function(require,module,exports){\nvar BaselineQuantizer, Quantizer, Swatch, quantize,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nquantize = require('quantize');\n\nmodule.exports = BaselineQuantizer = (function(superClass) {\n  extend(BaselineQuantizer, superClass);\n\n  function BaselineQuantizer() {\n    return BaselineQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  BaselineQuantizer.prototype.initialize = function(pixels, opts) {\n    var a, allPixels, b, cmap, g, i, offset, pixelCount, r;\n    this.opts = opts;\n    pixelCount = pixels.length / 4;\n    allPixels = [];\n    i = 0;\n    while (i < pixelCount) {\n      offset = i * 4;\n      r = pixels[offset + 0];\n      g = pixels[offset + 1];\n      b = pixels[offset + 2];\n      a = pixels[offset + 3];\n      if (a >= 125) {\n        if (!(r > 250 && g > 250 && b > 250)) {\n          allPixels.push([r, g, b]);\n        }\n      }\n      i = i + this.opts.quality;\n    }\n    cmap = quantize(allPixels, this.opts.colorCount);\n    return this.swatches = cmap.vboxes.map((function(_this) {\n      return function(vbox) {\n        return new Swatch(vbox.color, vbox.vbox.count());\n      };\n    })(this));\n  };\n\n  BaselineQuantizer.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return BaselineQuantizer;\n\n})(Quantizer);\n\n},{\"../swatch\":18,\"./index\":15,\"quantize\":25}],10:[function(require,module,exports){\nvar ColorCut, ColorCutQuantizer, Quantizer, Swatch,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nColorCut = require('./impl/color-cut');\n\nmodule.exports = ColorCutQuantizer = (function(superClass) {\n  extend(ColorCutQuantizer, superClass);\n\n  function ColorCutQuantizer() {\n    return ColorCutQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  ColorCutQuantizer.prototype.initialize = function(pixels, opts) {\n    var buf, buf8, data;\n    this.opts = opts;\n    buf = new ArrayBuffer(pixels.length);\n    buf8 = new Uint8ClampedArray(buf);\n    data = new Uint32Array(buf);\n    buf8.set(pixels);\n    return this.quantizer = new ColorCut(data, this.opts);\n  };\n\n  ColorCutQuantizer.prototype.getQuantizedColors = function() {\n    return this.quantizer.getQuantizedColors();\n  };\n\n  return ColorCutQuantizer;\n\n})(Quantizer);\n\n},{\"../swatch\":18,\"./impl/color-cut\":11,\"./index\":15}],11:[function(require,module,exports){\nvar ABGRColor, COMPONENT_BLUE, COMPONENT_GREEN, COMPONENT_RED, Color, ColorCutQuantizer, QUANTIZE_WORD_MASK, QUANTIZE_WORD_WIDTH, RGBAColor, Swatch, Vbox, approximateToRgb888, isLittleEndian, modifySignificantOctet, modifyWordWidth, quantizeFromRgb888, quantizedBlue, quantizedGreen, quantizedRed, sort;\n\nSwatch = require('../../swatch');\n\nsort = function(arr, lower, upper) {\n  var partition, pivot, swap;\n  swap = function(a, b) {\n    var t;\n    t = arr[a];\n    arr[a] = arr[b];\n    return arr[b] = t;\n  };\n  partition = function(pivot, left, right) {\n    var index, j, ref, ref1, v, value;\n    index = left;\n    value = arr[pivot];\n    swap(pivot, right);\n    for (v = j = ref = left, ref1 = right - 1; ref <= ref1 ? j <= ref1 : j >= ref1; v = ref <= ref1 ? ++j : --j) {\n      if (arr[v] > value) {\n        swap(v, index);\n        index++;\n      }\n    }\n    swap(right, index);\n    return index;\n  };\n  if (lower < upper) {\n    pivot = lower + Math.ceil((upper - lower) / 2);\n    pivot = partition(pivot, lower, upper);\n    sort(arr, lower, pivot - 1);\n    return sort(arr, pivot + 1, upper);\n  }\n};\n\nCOMPONENT_RED = -3;\n\nCOMPONENT_GREEN = -2;\n\nCOMPONENT_BLUE = -1;\n\nQUANTIZE_WORD_WIDTH = 5;\n\nQUANTIZE_WORD_MASK = (1 << QUANTIZE_WORD_WIDTH) - 1;\n\nRGBAColor = {\n  red: function(c) {\n    return c >> 24;\n  },\n  green: function(c) {\n    return c << 8 >> 24;\n  },\n  blue: function(c) {\n    return c << 16 >> 24;\n  },\n  alpha: function(c) {\n    return c << 24 >> 24;\n  }\n};\n\nABGRColor = {\n  red: function(c) {\n    return c << 24 >> 24;\n  },\n  green: function(c) {\n    return c << 16 >> 24;\n  },\n  blue: function(c) {\n    return c << 8 >> 24;\n  },\n  alpha: function(c) {\n    return c >> 24;\n  }\n};\n\nisLittleEndian = function() {\n  var a, b, c;\n  a = new ArrayBuffer(4);\n  b = new Uint8Array(a);\n  c = new Uint32Array(a);\n  b[0] = 0xa1;\n  b[1] = 0xb2;\n  b[2] = 0xc3;\n  b[3] = 0xd4;\n  if (c[0] === 0xd4c3b2a1) {\n    return true;\n  }\n  if (c[0] === 0xa1b2c3d4) {\n    return false;\n  }\n  throw new Error(\"Failed to determin endianness\");\n};\n\nColor = isLittleEndian() ? ABGRColor : RGBAColor;\n\nmodifyWordWidth = function(value, current, target) {\n  var newValue;\n  newValue = 0;\n  if (target > current) {\n    newValue = value << (target - current);\n  } else {\n    newValue = value >> (current - target);\n  }\n  return newValue & ((1 << target) - 1);\n};\n\nmodifySignificantOctet = function(a, dimension, lower, upper) {\n  var color, i, j, k, ref, ref1, ref2, ref3;\n  switch (dimension) {\n    case COMPONENT_RED:\n      break;\n    case COMPONENT_GREEN:\n      for (i = j = ref = lower, ref1 = upper; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n        color = a[i];\n        a[i] = quantizedGreen(color) << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | quantizedRed(color) << QUANTIZE_WORD_WIDTH | quantizedBlue(color);\n      }\n      break;\n    case COMPONENT_BLUE:\n      for (i = k = ref2 = lower, ref3 = upper; ref2 <= ref3 ? k <= ref3 : k >= ref3; i = ref2 <= ref3 ? ++k : --k) {\n        color = a[i];\n        a[i] = quantizedBlue(color) << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | quantizedGreen(color) << QUANTIZE_WORD_WIDTH | quantizedRed(color);\n      }\n      break;\n  }\n};\n\nquantizeFromRgb888 = function(color) {\n  var b, g, r;\n  r = modifyWordWidth(Color.red(color), 8, QUANTIZE_WORD_WIDTH);\n  g = modifyWordWidth(Color.green(color), 8, QUANTIZE_WORD_WIDTH);\n  b = modifyWordWidth(Color.blue(color), 8, QUANTIZE_WORD_WIDTH);\n  return r << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | g << QUANTIZE_WORD_WIDTH | b;\n};\n\napproximateToRgb888 = function(r, g, b) {\n  var color;\n  if (!((g != null) && (b != null))) {\n    color = r;\n    r = quantizedRed(color);\n    g = quantizedGreen(color);\n    b = quantizedBlue(color);\n  }\n  return [modifyWordWidth(r, QUANTIZE_WORD_WIDTH, 8), modifyWordWidth(g, QUANTIZE_WORD_WIDTH, 8), modifyWordWidth(b, QUANTIZE_WORD_WIDTH, 8)];\n};\n\nquantizedRed = function(color) {\n  return color >> (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) & QUANTIZE_WORD_MASK;\n};\n\nquantizedGreen = function(color) {\n  return color >> QUANTIZE_WORD_WIDTH & QUANTIZE_WORD_MASK;\n};\n\nquantizedBlue = function(color) {\n  return color & QUANTIZE_WORD_MASK;\n};\n\nmodule.exports = ColorCutQuantizer = (function() {\n  function ColorCutQuantizer(data, opts) {\n    var c, color, distinctColorCount, distinctColorIndex, i, j, k, l, m, quantizedColor, ref, ref1, ref2, ref3;\n    this.opts = opts;\n    this.hist = new Uint32Array(1 << (QUANTIZE_WORD_WIDTH * 3));\n    this.pixels = new Uint32Array(data.length);\n    for (i = j = 0, ref = data.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {\n      this.pixels[i] = quantizedColor = quantizeFromRgb888(data[i]);\n      this.hist[quantizedColor]++;\n    }\n    distinctColorCount = 0;\n    for (color = k = 0, ref1 = this.hist.length - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; color = 0 <= ref1 ? ++k : --k) {\n      if (this.hist[color] > 0) {\n        distinctColorCount++;\n      }\n    }\n    this.colors = new Uint32Array(distinctColorCount);\n    distinctColorIndex = 0;\n    for (color = l = 0, ref2 = this.hist.length - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; color = 0 <= ref2 ? ++l : --l) {\n      if (this.hist[color] > 0) {\n        this.colors[distinctColorIndex++] = color;\n      }\n    }\n    if (distinctColorCount <= this.opts.colorCount) {\n      this.quantizedColors = [];\n      for (i = m = 0, ref3 = this.colors.length - 1; 0 <= ref3 ? m <= ref3 : m >= ref3; i = 0 <= ref3 ? ++m : --m) {\n        c = this.colors[i];\n        this.quantizedColors.push(new Swatch(approximateToRgb888(c), this.hist[c]));\n      }\n    } else {\n      this.quantizedColors = this.quantizePixels(this.opts.colorCount);\n    }\n  }\n\n  ColorCutQuantizer.prototype.getQuantizedColors = function() {\n    return this.quantizedColors;\n  };\n\n  ColorCutQuantizer.prototype.quantizePixels = function(maxColors) {\n    var pq;\n    pq = new PriorityQueue({\n      comparator: Vbox.comparator\n    });\n    pq.queue(new Vbox(this.colors, this.hist, 0, this.colors.length - 1));\n    this.splitBoxes(pq, maxColors);\n    return this.generateAverageColors(pq);\n  };\n\n  ColorCutQuantizer.prototype.splitBoxes = function(queue, maxSize) {\n    var vbox;\n    while (queue.length < maxSize) {\n      vbox = queue.dequeue();\n      if (vbox != null ? vbox.canSplit() : void 0) {\n        queue.queue(vbox.splitBox());\n        queue.queue(vbox);\n      } else {\n        return;\n      }\n    }\n  };\n\n  ColorCutQuantizer.prototype.generateAverageColors = function(vboxes) {\n    var colors;\n    colors = [];\n    while (vboxes.length > 0) {\n      colors.push(vboxes.dequeue().getAverageColor());\n    }\n    return colors;\n  };\n\n  return ColorCutQuantizer;\n\n})();\n\nVbox = (function() {\n  Vbox.comparator = function(lhs, rhs) {\n    return lhs.getVolume() - rhs.getVolume();\n  };\n\n  function Vbox(colors1, hist, lowerIndex, upperIndex) {\n    this.colors = colors1;\n    this.hist = hist;\n    this.lowerIndex = lowerIndex;\n    this.upperIndex = upperIndex;\n    this.fitBox();\n  }\n\n  Vbox.prototype.getVolume = function() {\n    return (this.maxRed - this.minRed + 1) * (this.maxGreen - this.minGreen + 1) * (this.maxBlue - this.minBlue + 1);\n  };\n\n  Vbox.prototype.canSplit = function() {\n    return this.getColorCount() > 1;\n  };\n\n  Vbox.prototype.getColorCount = function() {\n    return 1 + this.upperIndex - this.lowerIndex;\n  };\n\n  Vbox.prototype.fitBox = function() {\n    var b, color, count, g, i, j, r, ref, ref1;\n    this.minRed = this.minGreen = this.minBlue = Number.MAX_VALUE;\n    this.maxRed = this.maxGreen = this.maxBlue = Number.MIN_VALUE;\n    this.population = 0;\n    count = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      color = this.colors[i];\n      count += this.hist[color];\n      r = quantizedRed(color);\n      g = quantizedGreen(color);\n      b = quantizedBlue(color);\n      if (r > this.maxRed) {\n        this.maxRed = r;\n      }\n      if (r < this.minRed) {\n        this.minRed = r;\n      }\n      if (g > this.maxGreen) {\n        this.maxGreen = g;\n      }\n      if (g < this.minGreen) {\n        this.minGreen = g;\n      }\n      if (b > this.maxBlue) {\n        this.maxRed = b;\n      }\n      if (b < this.minBlue) {\n        this.minRed = b;\n      }\n    }\n    return this.population = count;\n  };\n\n  Vbox.prototype.splitBox = function() {\n    var newBox, splitPoint;\n    if (!this.canSplit()) {\n      throw new Error(\"Cannot split a box with only 1 color\");\n    }\n    splitPoint = this.findSplitPoint();\n    newBox = new Vbox(this.colors, this.hist, splitPoint + 1, this.upperIndex);\n    this.upperIndex = splitPoint;\n    this.fitBox();\n    return newBox;\n  };\n\n  Vbox.prototype.getLongestColorDimension = function() {\n    var blueLength, greenLength, redLength;\n    redLength = this.maxRed - this.minRed;\n    greenLength = this.maxGreen - this.minGreen;\n    blueLength = this.maxBlue - this.minBlue;\n    if (redLength >= greenLength && redLength >= blueLength) {\n      return COMPONENT_RED;\n    }\n    if (greenLength >= redLength && greenLength >= blueLength) {\n      return COMPONENT_GREEN;\n    }\n    return COMPONENT_BLUE;\n  };\n\n  Vbox.prototype.findSplitPoint = function() {\n    var count, i, j, longestDimension, midPoint, ref, ref1;\n    longestDimension = this.getLongestColorDimension();\n    modifySignificantOctet(this.colors, longestDimension, this.lowerIndex, this.upperIndex);\n    sort(this.colors, this.lowerIndex, this.upperIndex + 1);\n    modifySignificantOctet(this.colors, longestDimension, this.lowerIndex, this.upperIndex);\n    midPoint = this.population / 2;\n    count = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      count += this.hist[this.colors[i]];\n      if (count >= midPoint) {\n        return i;\n      }\n    }\n    return this.lowerIndex;\n  };\n\n  Vbox.prototype.getAverageColor = function() {\n    var blueMean, blueSum, color, colorPopulation, greenMean, greenSum, i, j, redMean, redSum, ref, ref1, totalPopulation;\n    redSum = greenSum = blueSum = 0;\n    totalPopulation = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      color = this.colors[i];\n      colorPopulation = this.hist[color];\n      totalPopulation += colorPopulation;\n      redSum += colorPopulation * quantizedRed(color);\n      greenSum += colorPopulation * quantizedGreen(color);\n      blueSum += colorPopulation * quantizedBlue(color);\n    }\n    redMean = Math.round(redSum / totalPopulation);\n    greenMean = Math.round(greenSum / totalPopulation);\n    blueMean = Math.round(blueSum / totalPopulation);\n    return new Swatch(approximateToRgb888(redMean, greenMean, blueMean), totalPopulation);\n  };\n\n  return Vbox;\n\n})();\n\n},{\"../../swatch\":18}],12:[function(require,module,exports){\nvar MMCQ, PQueue, RSHIFT, SIGBITS, Swatch, VBox, getColorIndex, ref, util;\n\nref = util = require('../../util'), getColorIndex = ref.getColorIndex, SIGBITS = ref.SIGBITS, RSHIFT = ref.RSHIFT;\n\nSwatch = require('../../swatch');\n\nVBox = require('./vbox');\n\nPQueue = require('./pqueue');\n\nmodule.exports = MMCQ = (function() {\n  MMCQ.DefaultOpts = {\n    maxIterations: 1000,\n    fractByPopulations: 0.75\n  };\n\n  function MMCQ(opts) {\n    this.opts = util.defaults(opts, this.constructor.DefaultOpts);\n  }\n\n  MMCQ.prototype.quantize = function(pixels, opts) {\n    var color, colorCount, hist, pq, pq2, shouldIgnore, swatches, v, vbox;\n    if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n      throw new Error(\"Wrong MMCQ parameters\");\n    }\n    shouldIgnore = function() {\n      return false;\n    };\n    if (Array.isArray(opts.filters) && opts.filters.length > 0) {\n      shouldIgnore = function(r, g, b, a) {\n        var f, i, len, ref1;\n        ref1 = opts.filters;\n        for (i = 0, len = ref1.length; i < len; i++) {\n          f = ref1[i];\n          if (!f(r, g, b, a)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    vbox = VBox.build(pixels, shouldIgnore);\n    hist = vbox.hist;\n    colorCount = Object.keys(hist).length;\n    pq = new PQueue(function(a, b) {\n      return a.count() - b.count();\n    });\n    pq.push(vbox);\n    this._splitBoxes(pq, this.opts.fractByPopulations * opts.colorCount);\n    pq2 = new PQueue(function(a, b) {\n      return a.count() * a.volume() - b.count() * b.volume();\n    });\n    pq2.contents = pq.contents;\n    this._splitBoxes(pq2, opts.colorCount - pq2.size());\n    swatches = [];\n    this.vboxes = [];\n    while (pq2.size()) {\n      v = pq2.pop();\n      color = v.avg();\n      if (!(typeof shouldIgnore === \"function\" ? shouldIgnore(color[0], color[1], color[2], 255) : void 0)) {\n        this.vboxes.push(v);\n        swatches.push(new Swatch(color, v.count()));\n      }\n    }\n    return swatches;\n  };\n\n  MMCQ.prototype._splitBoxes = function(pq, target) {\n    var colorCount, iteration, maxIterations, ref1, vbox, vbox1, vbox2;\n    colorCount = 1;\n    iteration = 0;\n    maxIterations = this.opts.maxIterations;\n    while (iteration < maxIterations) {\n      iteration++;\n      vbox = pq.pop();\n      if (!vbox.count()) {\n        continue;\n      }\n      ref1 = vbox.split(), vbox1 = ref1[0], vbox2 = ref1[1];\n      pq.push(vbox1);\n      if (vbox2) {\n        pq.push(vbox2);\n        colorCount++;\n      }\n      if (colorCount >= target || iteration > maxIterations) {\n        return;\n      }\n    }\n  };\n\n  return MMCQ;\n\n})();\n\n},{\"../../swatch\":18,\"../../util\":19,\"./pqueue\":13,\"./vbox\":14}],13:[function(require,module,exports){\nvar PQueue;\n\nmodule.exports = PQueue = (function() {\n  function PQueue(comparator) {\n    this.comparator = comparator;\n    this.contents = [];\n    this.sorted = false;\n  }\n\n  PQueue.prototype._sort = function() {\n    this.contents.sort(this.comparator);\n    return this.sorted = true;\n  };\n\n  PQueue.prototype.push = function(o) {\n    this.contents.push(o);\n    return this.sorted = false;\n  };\n\n  PQueue.prototype.peek = function(index) {\n    if (!this.sorted) {\n      this._sort();\n    }\n    if (index == null) {\n      index = this.contents.length - 1;\n    }\n    return this.contents[index];\n  };\n\n  PQueue.prototype.pop = function() {\n    if (!this.sorted) {\n      this._sort();\n    }\n    return this.contents.pop();\n  };\n\n  PQueue.prototype.size = function() {\n    return this.contents.length;\n  };\n\n  PQueue.prototype.map = function(f) {\n    if (!this.sorted) {\n      this._sort();\n    }\n    return this.contents.map(f);\n  };\n\n  return PQueue;\n\n})();\n\n},{}],14:[function(require,module,exports){\nvar RSHIFT, SIGBITS, VBox, getColorIndex, ref, util;\n\nref = util = require('../../util'), getColorIndex = ref.getColorIndex, SIGBITS = ref.SIGBITS, RSHIFT = ref.RSHIFT;\n\nmodule.exports = VBox = (function() {\n  VBox.build = function(pixels, shouldIgnore) {\n    var a, b, bmax, bmin, g, gmax, gmin, hist, hn, i, index, n, offset, r, rmax, rmin;\n    hn = 1 << (3 * SIGBITS);\n    hist = new Uint32Array(hn);\n    rmax = gmax = bmax = 0;\n    rmin = gmin = bmin = Number.MAX_VALUE;\n    n = pixels.length / 4;\n    i = 0;\n    while (i < n) {\n      offset = i * 4;\n      i++;\n      r = pixels[offset + 0];\n      g = pixels[offset + 1];\n      b = pixels[offset + 2];\n      a = pixels[offset + 3];\n      if (shouldIgnore(r, g, b, a)) {\n        continue;\n      }\n      r = r >> RSHIFT;\n      g = g >> RSHIFT;\n      b = b >> RSHIFT;\n      index = getColorIndex(r, g, b);\n      hist[index] += 1;\n      if (r > rmax) {\n        rmax = r;\n      }\n      if (r < rmin) {\n        rmin = r;\n      }\n      if (g > gmax) {\n        gmax = g;\n      }\n      if (g < gmin) {\n        gmin = g;\n      }\n      if (b > bmax) {\n        bmax = b;\n      }\n      if (b < bmin) {\n        bmin = b;\n      }\n    }\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, hist);\n  };\n\n  function VBox(r1, r2, g1, g2, b1, b2, hist1) {\n    this.r1 = r1;\n    this.r2 = r2;\n    this.g1 = g1;\n    this.g2 = g2;\n    this.b1 = b1;\n    this.b2 = b2;\n    this.hist = hist1;\n  }\n\n  VBox.prototype.invalidate = function() {\n    delete this._count;\n    delete this._avg;\n    return delete this._volume;\n  };\n\n  VBox.prototype.volume = function() {\n    if (this._volume == null) {\n      this._volume = (this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1);\n    }\n    return this._volume;\n  };\n\n  VBox.prototype.count = function() {\n    var c, hist;\n    if (this._count == null) {\n      hist = this.hist;\n      c = 0;\n      \n      for (var r = this.r1; r <= this.r2; r++) {\n        for (var g = this.g1; g <= this.g2; g++) {\n          for (var b = this.b1; b <= this.b2; b++) {\n            var index = getColorIndex(r, g, b);\n            c += hist[index];\n          }\n        }\n      }\n      ;\n      this._count = c;\n    }\n    return this._count;\n  };\n\n  VBox.prototype.clone = function() {\n    return new VBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.hist);\n  };\n\n  VBox.prototype.avg = function() {\n    var bsum, gsum, hist, mult, ntot, rsum;\n    if (this._avg == null) {\n      hist = this.hist;\n      ntot = 0;\n      mult = 1 << (8 - SIGBITS);\n      rsum = gsum = bsum = 0;\n      \n      for (var r = this.r1; r <= this.r2; r++) {\n        for (var g = this.g1; g <= this.g2; g++) {\n          for (var b = this.b1; b <= this.b2; b++) {\n            var index = getColorIndex(r, g, b);\n            var h = hist[index];\n            ntot += h;\n            rsum += (h * (r + 0.5) * mult);\n            gsum += (h * (g + 0.5) * mult);\n            bsum += (h * (b + 0.5) * mult);\n          }\n        }\n      }\n      ;\n      if (ntot) {\n        this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n      } else {\n        this._avg = [~~(mult * (this.r1 + this.r2 + 1) / 2), ~~(mult * (this.g1 + this.g2 + 1) / 2), ~~(mult * (this.b1 + this.b2 + 1) / 2)];\n      }\n    }\n    return this._avg;\n  };\n\n  VBox.prototype.split = function() {\n    var accSum, bw, d, doCut, gw, hist, i, j, maxd, maxw, ref1, reverseSum, rw, splitPoint, sum, total, vbox;\n    hist = this.hist;\n    if (!this.count()) {\n      return null;\n    }\n    if (this.count() === 1) {\n      return [this.clone()];\n    }\n    rw = this.r2 - this.r1 + 1;\n    gw = this.g2 - this.g1 + 1;\n    bw = this.b2 - this.b1 + 1;\n    maxw = Math.max(rw, gw, bw);\n    accSum = null;\n    sum = total = 0;\n    maxd = null;\n    switch (maxw) {\n      case rw:\n        maxd = 'r';\n        accSum = new Uint32Array(this.r2 + 1);\n        \n        for (var r = this.r1; r <= this.r2; r++) {\n          sum = 0\n          for (var g = this.g1; g <= this.g2; g++) {\n            for (var b = this.b1; b <= this.b2; b++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[r] = total;\n        }\n        ;\n        break;\n      case gw:\n        maxd = 'g';\n        accSum = new Uint32Array(this.g2 + 1);\n        \n        for (var g = this.g1; g <= this.g2; g++) {\n          sum = 0\n          for (var r = this.r1; r <= this.r2; r++) {\n            for (var b = this.b1; b <= this.b2; b++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[g] = total;\n        }\n        ;\n        break;\n      case bw:\n        maxd = 'b';\n        accSum = new Uint32Array(this.b2 + 1);\n        \n        for (var b = this.b1; b <= this.b2; b++) {\n          sum = 0\n          for (var r = this.r1; r <= this.r2; r++) {\n            for (var g = this.g1; g <= this.g2; g++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[b] = total;\n        }\n        ;\n    }\n    splitPoint = -1;\n    reverseSum = new Uint32Array(accSum.length);\n    for (i = j = 0, ref1 = accSum.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n      d = accSum[i];\n      if (splitPoint < 0 && d > total / 2) {\n        splitPoint = i;\n      }\n      reverseSum[i] = total - d;\n    }\n    vbox = this;\n    doCut = function(d) {\n      var c2, d1, d2, dim1, dim2, left, right, vbox1, vbox2;\n      dim1 = d + \"1\";\n      dim2 = d + \"2\";\n      d1 = vbox[dim1];\n      d2 = vbox[dim2];\n      vbox1 = vbox.clone();\n      vbox2 = vbox.clone();\n      left = splitPoint - d1;\n      right = d2 - splitPoint;\n      if (left <= right) {\n        d2 = Math.min(d2 - 1, ~~(splitPoint + right / 2));\n        d2 = Math.max(0, d2);\n      } else {\n        d2 = Math.max(d1, ~~(splitPoint - 1 - left / 2));\n        d2 = Math.min(vbox[dim2], d2);\n      }\n      while (!accSum[d2]) {\n        d2++;\n      }\n      c2 = reverseSum[d2];\n      while (!c2 && accSum[d2 - 1]) {\n        c2 = reverseSum[--d2];\n      }\n      vbox1[dim2] = d2;\n      vbox2[dim1] = d2 + 1;\n      return [vbox1, vbox2];\n    };\n    return doCut(maxd);\n  };\n\n  VBox.prototype.contains = function(p) {\n    var b, g, r;\n    r = p[0] >> RSHIFT;\n    g = p[1] >> RSHIFT;\n    b = p[2] >> RSHIFT;\n    return r >= this.r1 && r <= this.r2 && g >= this.g1 && g <= this.g2 && b >= this.b1 && b <= this.b2;\n  };\n\n  return VBox;\n\n})();\n\n},{\"../../util\":19}],15:[function(require,module,exports){\nvar Quantizer;\n\nmodule.exports = Quantizer = (function() {\n  function Quantizer() {}\n\n  Quantizer.prototype.initialize = function(pixels, opts) {};\n\n  Quantizer.prototype.getQuantizedColors = function() {};\n\n  return Quantizer;\n\n})();\n\nmodule.exports.Baseline = require('./baseline');\n\nmodule.exports.NoCopy = require('./nocopy');\n\nmodule.exports.ColorCut = require('./color-cut');\n\nmodule.exports.MMCQ = require('./mmcq');\n\n},{\"./baseline\":9,\"./color-cut\":10,\"./mmcq\":16,\"./nocopy\":17}],16:[function(require,module,exports){\nvar MMCQ, MMCQImpl, Quantizer, Swatch,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nMMCQImpl = require('./impl/mmcq');\n\nmodule.exports = MMCQ = (function(superClass) {\n  extend(MMCQ, superClass);\n\n  function MMCQ() {\n    return MMCQ.__super__.constructor.apply(this, arguments);\n  }\n\n  MMCQ.prototype.initialize = function(pixels, opts) {\n    var mmcq;\n    this.opts = opts;\n    mmcq = new MMCQImpl();\n    return this.swatches = mmcq.quantize(pixels, this.opts);\n  };\n\n  MMCQ.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return MMCQ;\n\n})(Quantizer);\n\n},{\"../swatch\":18,\"./impl/mmcq\":12,\"./index\":15}],17:[function(require,module,exports){\nvar NoCopyQuantizer, Quantizer, Swatch, quantize,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nquantize = require('../../vendor-mod/quantize');\n\nmodule.exports = NoCopyQuantizer = (function(superClass) {\n  extend(NoCopyQuantizer, superClass);\n\n  function NoCopyQuantizer() {\n    return NoCopyQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  NoCopyQuantizer.prototype.initialize = function(pixels, opts) {\n    var cmap;\n    this.opts = opts;\n    cmap = quantize(pixels, this.opts);\n    return this.swatches = cmap.vboxes.map((function(_this) {\n      return function(vbox) {\n        return new Swatch(vbox.color, vbox.vbox.count());\n      };\n    })(this));\n  };\n\n  NoCopyQuantizer.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return NoCopyQuantizer;\n\n})(Quantizer);\n\n},{\"../../vendor-mod/quantize\":21,\"../swatch\":18,\"./index\":15}],18:[function(require,module,exports){\nvar Swatch, util;\n\nutil = require('./util');\n\n\n/*\n  From Vibrant.js by Jari Zwarts\n  Ported to node.js by AKFish\n\n  Swatch class\n */\n\nmodule.exports = Swatch = (function() {\n  Swatch.prototype.hsl = void 0;\n\n  Swatch.prototype.rgb = void 0;\n\n  Swatch.prototype.population = 1;\n\n  Swatch.prototype.yiq = 0;\n\n  function Swatch(rgb, population) {\n    this.rgb = rgb;\n    this.population = population;\n  }\n\n  Swatch.prototype.getHsl = function() {\n    if (!this.hsl) {\n      return this.hsl = util.rgbToHsl(this.rgb[0], this.rgb[1], this.rgb[2]);\n    } else {\n      return this.hsl;\n    }\n  };\n\n  Swatch.prototype.getPopulation = function() {\n    return this.population;\n  };\n\n  Swatch.prototype.getRgb = function() {\n    return this.rgb;\n  };\n\n  Swatch.prototype.getHex = function() {\n    return util.rgbToHex(this.rgb[0], this.rgb[1], this.rgb[2]);\n  };\n\n  Swatch.prototype.getTitleTextColor = function() {\n    this._ensureTextColors();\n    if (this.yiq < 200) {\n      return \"#fff\";\n    } else {\n      return \"#000\";\n    }\n  };\n\n  Swatch.prototype.getBodyTextColor = function() {\n    this._ensureTextColors();\n    if (this.yiq < 150) {\n      return \"#fff\";\n    } else {\n      return \"#000\";\n    }\n  };\n\n  Swatch.prototype._ensureTextColors = function() {\n    if (!this.yiq) {\n      return this.yiq = (this.rgb[0] * 299 + this.rgb[1] * 587 + this.rgb[2] * 114) / 1000;\n    }\n  };\n\n  return Swatch;\n\n})();\n\n},{\"./util\":19}],19:[function(require,module,exports){\nvar DELTAE94, RSHIFT, SIGBITS;\n\nDELTAE94 = {\n  NA: 0,\n  PERFECT: 1,\n  CLOSE: 2,\n  GOOD: 10,\n  SIMILAR: 50\n};\n\nSIGBITS = 5;\n\nRSHIFT = 8 - SIGBITS;\n\nmodule.exports = {\n  clone: function(o) {\n    var _o, key, value;\n    if (typeof o === 'object') {\n      if (Array.isArray(o)) {\n        return o.map((function(_this) {\n          return function(v) {\n            return _this.clone(v);\n          };\n        })(this));\n      } else {\n        _o = {};\n        for (key in o) {\n          value = o[key];\n          _o[key] = this.clone(value);\n        }\n        return _o;\n      }\n    }\n    return o;\n  },\n  defaults: function() {\n    var _o, i, key, len, o, value;\n    o = {};\n    for (i = 0, len = arguments.length; i < len; i++) {\n      _o = arguments[i];\n      for (key in _o) {\n        value = _o[key];\n        if (o[key] == null) {\n          o[key] = this.clone(value);\n        }\n      }\n    }\n    return o;\n  },\n  hexToRgb: function(hex) {\n    var m;\n    m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (m != null) {\n      return [m[1], m[2], m[3]].map(function(s) {\n        return parseInt(s, 16);\n      });\n    }\n    return null;\n  },\n  rgbToHex: function(r, g, b) {\n    return \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);\n  },\n  rgbToHsl: function(r, g, b) {\n    var d, h, l, max, min, s;\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    h = void 0;\n    s = void 0;\n    l = (max + min) / 2;\n    if (max === min) {\n      h = s = 0;\n    } else {\n      d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0);\n          break;\n        case g:\n          h = (b - r) / d + 2;\n          break;\n        case b:\n          h = (r - g) / d + 4;\n      }\n      h /= 6;\n    }\n    return [h, s, l];\n  },\n  hslToRgb: function(h, s, l) {\n    var b, g, hue2rgb, p, q, r;\n    r = void 0;\n    g = void 0;\n    b = void 0;\n    hue2rgb = function(p, q, t) {\n      if (t < 0) {\n        t += 1;\n      }\n      if (t > 1) {\n        t -= 1;\n      }\n      if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n      }\n      if (t < 1 / 2) {\n        return q;\n      }\n      if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n      }\n      return p;\n    };\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      q = l < 0.5 ? l * (1 + s) : l + s - (l * s);\n      p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - (1 / 3));\n    }\n    return [r * 255, g * 255, b * 255];\n  },\n  rgbToXyz: function(r, g, b) {\n    var x, y, z;\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    r = r > 0.04045 ? Math.pow((r + 0.005) / 1.055, 2.4) : r / 12.92;\n    g = g > 0.04045 ? Math.pow((g + 0.005) / 1.055, 2.4) : g / 12.92;\n    b = b > 0.04045 ? Math.pow((b + 0.005) / 1.055, 2.4) : b / 12.92;\n    r *= 100;\n    g *= 100;\n    b *= 100;\n    x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n    y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n    z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n    return [x, y, z];\n  },\n  xyzToCIELab: function(x, y, z) {\n    var L, REF_X, REF_Y, REF_Z, a, b;\n    REF_X = 95.047;\n    REF_Y = 100;\n    REF_Z = 108.883;\n    x /= REF_X;\n    y /= REF_Y;\n    z /= REF_Z;\n    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n    L = 116 * y - 16;\n    a = 500 * (x - y);\n    b = 200 * (y - z);\n    return [L, a, b];\n  },\n  rgbToCIELab: function(r, g, b) {\n    var ref, x, y, z;\n    ref = this.rgbToXyz(r, g, b), x = ref[0], y = ref[1], z = ref[2];\n    return this.xyzToCIELab(x, y, z);\n  },\n  deltaE94: function(lab1, lab2) {\n    var L1, L2, WEIGHT_C, WEIGHT_H, WEIGHT_L, a1, a2, b1, b2, dL, da, db, xC1, xC2, xDC, xDE, xDH, xDL, xSC, xSH;\n    WEIGHT_L = 1;\n    WEIGHT_C = 1;\n    WEIGHT_H = 1;\n    L1 = lab1[0], a1 = lab1[1], b1 = lab1[2];\n    L2 = lab2[0], a2 = lab2[1], b2 = lab2[2];\n    dL = L1 - L2;\n    da = a1 - a2;\n    db = b1 - b2;\n    xC1 = Math.sqrt(a1 * a1 + b1 * b1);\n    xC2 = Math.sqrt(a2 * a2 + b2 * b2);\n    xDL = L2 - L1;\n    xDC = xC2 - xC1;\n    xDE = Math.sqrt(dL * dL + da * da + db * db);\n    if (Math.sqrt(xDE) > Math.sqrt(Math.abs(xDL)) + Math.sqrt(Math.abs(xDC))) {\n      xDH = Math.sqrt(xDE * xDE - xDL * xDL - xDC * xDC);\n    } else {\n      xDH = 0;\n    }\n    xSC = 1 + 0.045 * xC1;\n    xSH = 1 + 0.015 * xC1;\n    xDL /= WEIGHT_L;\n    xDC /= WEIGHT_C * xSC;\n    xDH /= WEIGHT_H * xSH;\n    return Math.sqrt(xDL * xDL + xDC * xDC + xDH * xDH);\n  },\n  rgbDiff: function(rgb1, rgb2) {\n    var lab1, lab2;\n    lab1 = this.rgbToCIELab.apply(this, rgb1);\n    lab2 = this.rgbToCIELab.apply(this, rgb2);\n    return this.deltaE94(lab1, lab2);\n  },\n  hexDiff: function(hex1, hex2) {\n    var rgb1, rgb2;\n    rgb1 = this.hexToRgb(hex1);\n    rgb2 = this.hexToRgb(hex2);\n    return this.rgbDiff(rgb1, rgb2);\n  },\n  DELTAE94_DIFF_STATUS: DELTAE94,\n  getColorDiffStatus: function(d) {\n    if (d < DELTAE94.NA) {\n      return \"N/A\";\n    }\n    if (d <= DELTAE94.PERFECT) {\n      return \"Perfect\";\n    }\n    if (d <= DELTAE94.CLOSE) {\n      return \"Close\";\n    }\n    if (d <= DELTAE94.GOOD) {\n      return \"Good\";\n    }\n    if (d < DELTAE94.SIMILAR) {\n      return \"Similar\";\n    }\n    return \"Wrong\";\n  },\n  SIGBITS: SIGBITS,\n  RSHIFT: RSHIFT,\n  getColorIndex: function(r, g, b) {\n    return (r << (2 * SIGBITS)) + (g << SIGBITS) + b;\n  }\n};\n\n},{}],20:[function(require,module,exports){\n\n/*\n  From Vibrant.js by Jari Zwarts\n  Ported to node.js by AKFish\n\n  Color algorithm class that finds variations on colors in an image.\n\n  Credits\n  --------\n  Lokesh Dhakar (http://www.lokeshdhakar.com) - Created ColorThief\n  Google - Palette support library in Android\n */\nvar Builder, DefaultGenerator, Filter, Swatch, Vibrant, util,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nSwatch = require('./swatch');\n\nutil = require('./util');\n\nDefaultGenerator = require('./generator').Default;\n\nFilter = require('./filter');\n\nmodule.exports = Vibrant = (function() {\n  Vibrant.DefaultOpts = {\n    colorCount: 64,\n    quality: 5,\n    generator: new DefaultGenerator(),\n    Image: null,\n    Quantizer: require('./quantizer').MMCQ,\n    filters: []\n  };\n\n  Vibrant.from = function(src) {\n    return new Builder(src);\n  };\n\n  Vibrant.prototype.quantize = require('quantize');\n\n  Vibrant.prototype._swatches = [];\n\n  function Vibrant(sourceImage, opts) {\n    this.sourceImage = sourceImage;\n    if (opts == null) {\n      opts = {};\n    }\n    this.swatches = bind(this.swatches, this);\n    this.opts = util.defaults(opts, this.constructor.DefaultOpts);\n    this.generator = this.opts.generator;\n  }\n\n  Vibrant.prototype.getPalette = function(cb) {\n    var image;\n    return image = new this.opts.Image(this.sourceImage, (function(_this) {\n      return function(err, image) {\n        var error;\n        if (err != null) {\n          return cb(err);\n        }\n        try {\n          _this._process(image, _this.opts);\n          return cb(null, _this.swatches());\n        } catch (_error) {\n          error = _error;\n          return cb(error);\n        }\n      };\n    })(this));\n  };\n\n  Vibrant.prototype.getSwatches = function(cb) {\n    return this.getPalette(cb);\n  };\n\n  Vibrant.prototype._process = function(image, opts) {\n    var imageData, quantizer, swatches;\n    image.scaleDown(this.opts);\n    imageData = image.getImageData();\n    quantizer = new this.opts.Quantizer();\n    quantizer.initialize(imageData.data, this.opts);\n    swatches = quantizer.getQuantizedColors();\n    this.generator.generate(swatches);\n    return image.removeCanvas();\n  };\n\n  Vibrant.prototype.swatches = function() {\n    return {\n      Vibrant: this.generator.getVibrantSwatch(),\n      Muted: this.generator.getMutedSwatch(),\n      DarkVibrant: this.generator.getDarkVibrantSwatch(),\n      DarkMuted: this.generator.getDarkMutedSwatch(),\n      LightVibrant: this.generator.getLightVibrantSwatch(),\n      LightMuted: this.generator.getLightMutedSwatch()\n    };\n  };\n\n  return Vibrant;\n\n})();\n\nmodule.exports.Builder = Builder = (function() {\n  function Builder(src1, opts1) {\n    this.src = src1;\n    this.opts = opts1 != null ? opts1 : {};\n    this.opts.filters = util.clone(Vibrant.DefaultOpts.filters);\n  }\n\n  Builder.prototype.maxColorCount = function(n) {\n    this.opts.colorCount = n;\n    return this;\n  };\n\n  Builder.prototype.maxDimension = function(d) {\n    this.opts.maxDimension = d;\n    return this;\n  };\n\n  Builder.prototype.addFilter = function(f) {\n    if (typeof f === 'function') {\n      this.opts.filters.push(f);\n    }\n    return this;\n  };\n\n  Builder.prototype.removeFilter = function(f) {\n    var i;\n    if ((i = this.opts.filters.indexOf(f)) > 0) {\n      this.opts.filters.splice(i);\n    }\n    return this;\n  };\n\n  Builder.prototype.clearFilters = function() {\n    this.opts.filters = [];\n    return this;\n  };\n\n  Builder.prototype.quality = function(q) {\n    this.opts.quality = q;\n    return this;\n  };\n\n  Builder.prototype.useImage = function(image) {\n    this.opts.Image = image;\n    return this;\n  };\n\n  Builder.prototype.useGenerator = function(generator) {\n    this.opts.generator = generator;\n    return this;\n  };\n\n  Builder.prototype.useQuantizer = function(quantizer) {\n    this.opts.Quantizer = quantizer;\n    return this;\n  };\n\n  Builder.prototype.build = function() {\n    if (this.v == null) {\n      this.v = new Vibrant(this.src, this.opts);\n    }\n    return this.v;\n  };\n\n  Builder.prototype.getSwatches = function(cb) {\n    return this.build().getPalette(cb);\n  };\n\n  Builder.prototype.getPalette = function(cb) {\n    return this.build().getPalette(cb);\n  };\n\n  Builder.prototype.from = function(src) {\n    return new Vibrant(src, this.opts);\n  };\n\n  return Builder;\n\n})();\n\nmodule.exports.Util = util;\n\nmodule.exports.Swatch = Swatch;\n\nmodule.exports.Quantizer = require('./quantizer/');\n\nmodule.exports.Generator = require('./generator/');\n\nmodule.exports.Filter = require('./filter/');\n\n},{\"./filter\":4,\"./filter/\":4,\"./generator\":6,\"./generator/\":6,\"./quantizer\":15,\"./quantizer/\":15,\"./swatch\":18,\"./util\":19,\"quantize\":25}],21:[function(require,module,exports){\n/*\r\n * quantize.js Copyright 2008 Nick Rabinowitz\r\n * Ported to node.js by Olivier Lesnicki\r\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\r\n */\r\n\r\n// fill out a couple protovis dependencies\r\n/*\r\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\r\n * Copyright 2010 Stanford Visualization Group\r\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\r\n */\r\nif (!pv) {\r\n    var pv = {\r\n        map: function(array, f) {\r\n            var o = {};\r\n            return f ? array.map(function(d, i) {\r\n                o.index = i;\r\n                return f.call(o, d);\r\n            }) : array.slice();\r\n        },\r\n        naturalOrder: function(a, b) {\r\n            return a - b;\r\n        },\r\n        sum: function(array, f) {\r\n            var o = {};\r\n            return array.reduce(f ? function(p, d, i) {\r\n                o.index = i;\r\n                return p + f.call(o, d);\r\n            } : function(p, d) {\r\n                return p + d;\r\n            }, 0);\r\n        },\r\n        max: function(array, f) {\r\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Basic Javascript port of the MMCQ (modified median cut quantization)\r\n * algorithm from the Leptonica library (http://www.leptonica.com/).\r\n * Returns a color map you can use to map original pixels to the reduced\r\n * palette. Still a work in progress.\r\n *\r\n * @author Nick Rabinowitz\r\n * @example\r\n\r\n// array of pixels as [R,G,B] arrays\r\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\r\n                // etc\r\n                ];\r\nvar maxColors = 4;\r\n\r\nvar cmap = MMCQ.quantize(myPixels, maxColors);\r\nvar newPalette = cmap.palette();\r\nvar newPixels = myPixels.map(function(p) {\r\n    return cmap.map(p);\r\n});\r\n\r\n */\r\nvar MMCQ = (function() {\r\n    // private constants\r\n    var sigbits = 5,\r\n        rshift = 8 - sigbits,\r\n        maxIterations = 1000,\r\n        fractByPopulations = 0.75;\r\n\r\n    // get reduced-space color index for a pixel\r\n\r\n    function getColorIndex(r, g, b) {\r\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\r\n    }\r\n\r\n    // Simple priority queue\r\n\r\n    function PQueue(comparator) {\r\n        var contents = [],\r\n            sorted = false;\r\n\r\n        function sort() {\r\n            contents.sort(comparator);\r\n            sorted = true;\r\n        }\r\n\r\n        return {\r\n            push: function(o) {\r\n                contents.push(o);\r\n                sorted = false;\r\n            },\r\n            peek: function(index) {\r\n                if (!sorted) sort();\r\n                if (index === undefined) index = contents.length - 1;\r\n                return contents[index];\r\n            },\r\n            pop: function() {\r\n                if (!sorted) sort();\r\n                return contents.pop();\r\n            },\r\n            size: function() {\r\n                return contents.length;\r\n            },\r\n            map: function(f) {\r\n                return contents.map(f);\r\n            },\r\n            debug: function() {\r\n                if (!sorted) sort();\r\n                return contents;\r\n            }\r\n        };\r\n    }\r\n\r\n    // 3d color space box\r\n\r\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\r\n        var vbox = this;\r\n        vbox.r1 = r1;\r\n        vbox.r2 = r2;\r\n        vbox.g1 = g1;\r\n        vbox.g2 = g2;\r\n        vbox.b1 = b1;\r\n        vbox.b2 = b2;\r\n        vbox.histo = histo;\r\n    }\r\n    VBox.prototype = {\r\n        volume: function(force) {\r\n            var vbox = this;\r\n            if (!vbox._volume || force) {\r\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\r\n            }\r\n            return vbox._volume;\r\n        },\r\n        count: function(force) {\r\n            var vbox = this,\r\n                histo = vbox.histo;\r\n            if (!vbox._count_set || force) {\r\n                var npix = 0,\r\n                    i, j, k;\r\n                for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                            index = getColorIndex(i, j, k);\r\n                            npix += histo[index];\r\n                        }\r\n                    }\r\n                }\r\n                vbox._count = npix;\r\n                vbox._count_set = true;\r\n            }\r\n            return vbox._count;\r\n        },\r\n        copy: function() {\r\n            var vbox = this;\r\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\r\n        },\r\n        avg: function(force) {\r\n            var vbox = this,\r\n                histo = vbox.histo;\r\n            if (!vbox._avg || force) {\r\n                var ntot = 0,\r\n                    mult = 1 << (8 - sigbits),\r\n                    // mult = (8 - sigbits),\r\n                    rsum = 0,\r\n                    gsum = 0,\r\n                    bsum = 0,\r\n                    hval,\r\n                    i, j, k, histoindex;\r\n                for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                            histoindex = getColorIndex(i, j, k);\r\n                            hval = histo[histoindex];\r\n                            ntot += hval;\r\n                            rsum += (hval * (i + 0.5) * mult);\r\n                            gsum += (hval * (j + 0.5) * mult);\r\n                            bsum += (hval * (k + 0.5) * mult);\r\n                        }\r\n                    }\r\n                }\r\n                if (ntot) {\r\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\r\n                } else {\r\n                    //console.log('empty box');\r\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\r\n                }\r\n            }\r\n            return vbox._avg;\r\n        },\r\n        contains: function(pixel) {\r\n            var vbox = this,\r\n                rval = pixel[0] >> rshift;\r\n            gval = pixel[1] >> rshift;\r\n            bval = pixel[2] >> rshift;\r\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\r\n                gval >= vbox.g1 && gval <= vbox.g2 &&\r\n                bval >= vbox.b1 && bval <= vbox.b2);\r\n        }\r\n    };\r\n\r\n    // Color map\r\n\r\n    function CMap() {\r\n        this.vboxes = new PQueue(function(a, b) {\r\n            return pv.naturalOrder(\r\n                a.vbox.count() * a.vbox.volume(),\r\n                b.vbox.count() * b.vbox.volume()\r\n            )\r\n        });;\r\n    }\r\n    CMap.prototype = {\r\n        push: function(vbox) {\r\n            this.vboxes.push({\r\n                vbox: vbox,\r\n                color: vbox.avg()\r\n            });\r\n        },\r\n        palette: function() {\r\n            return this.vboxes.map(function(vb) {\r\n                return vb.color\r\n            });\r\n        },\r\n        size: function() {\r\n            return this.vboxes.size();\r\n        },\r\n        map: function(color) {\r\n            var vboxes = this.vboxes;\r\n            for (var i = 0; i < vboxes.size(); i++) {\r\n                if (vboxes.peek(i).vbox.contains(color)) {\r\n                    return vboxes.peek(i).color;\r\n                }\r\n            }\r\n            return this.nearest(color);\r\n        },\r\n        nearest: function(color) {\r\n            var vboxes = this.vboxes,\r\n                d1, d2, pColor;\r\n            for (var i = 0; i < vboxes.size(); i++) {\r\n                d2 = Math.sqrt(\r\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\r\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\r\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\r\n                );\r\n                if (d2 < d1 || d1 === undefined) {\r\n                    d1 = d2;\r\n                    pColor = vboxes.peek(i).color;\r\n                }\r\n            }\r\n            return pColor;\r\n        },\r\n        forcebw: function() {\r\n            // XXX: won't  work yet\r\n            var vboxes = this.vboxes;\r\n            vboxes.sort(function(a, b) {\r\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\r\n            });\r\n\r\n            // force darkest color to black if everything < 5\r\n            var lowest = vboxes[0].color;\r\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\r\n                vboxes[0].color = [0, 0, 0];\r\n\r\n            // force lightest color to white if everything > 251\r\n            var idx = vboxes.length - 1,\r\n                highest = vboxes[idx].color;\r\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\r\n                vboxes[idx].color = [255, 255, 255];\r\n        }\r\n    };\r\n\r\n\r\n    function getAll(pixels, shouldIgnore) {\r\n        var histosize = 1 << (3 * sigbits),\r\n            histo = new Uint32Array(histosize),\r\n            index, rval, gval, bval;\r\n        var rmin = 1000000,\r\n            rmax = 0,\r\n            gmin = 1000000,\r\n            gmax = 0,\r\n            bmin = 1000000,\r\n            bmax = 0;\r\n\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        } else {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        }\r\n\r\n        return {\r\n          histo: histo,\r\n          vbox: new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo)\r\n        };\r\n    }\r\n\r\n    // histo (1-d array, giving the number of pixels in\r\n    // each quantized region of color space), or null on error\r\n\r\n    function getHisto(pixels, shouldIgnore) {\r\n        var histosize = 1 << (3 * sigbits),\r\n            histo = new Uint32Array(histosize),\r\n            index, rval, gval, bval;\r\n\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n          }\r\n        } else {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n          }\r\n        }\r\n\r\n        return histo;\r\n    }\r\n\r\n    function vboxFromPixels(pixels, histo, shouldIgnore) {\r\n        var rmin = 1000000,\r\n            rmax = 0,\r\n            gmin = 1000000,\r\n            gmax = 0,\r\n            bmin = 1000000,\r\n            bmax = 0,\r\n            rval, gval, bval;\r\n        // find min/max\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        } else {\r\n            while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        }\r\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\r\n    }\r\n\r\n    function medianCutApply(histo, vbox) {\r\n        if (!vbox.count()) return;\r\n\r\n        var rw = vbox.r2 - vbox.r1 + 1,\r\n            gw = vbox.g2 - vbox.g1 + 1,\r\n            bw = vbox.b2 - vbox.b1 + 1,\r\n            maxw = pv.max([rw, gw, bw]);\r\n        // only one pixel, no split\r\n        if (vbox.count() == 1) {\r\n            return [vbox.copy()]\r\n        }\r\n        /* Find the partial sum arrays along the selected axis. */\r\n        var total = 0,\r\n            partialsum,\r\n            lookaheadsum,\r\n            i, j, k, sum, index;\r\n        // var D = ['r', 'g', 'b'],\r\n        //   indexer = getColorIndex;\r\n        // if (maxw == gw) {\r\n        //   D = ['g', 'r', 'b'];\r\n        //   indexer = function(g, r, b) { return getColorIndex(r, g, b); };\r\n        // } else if (maxw == bw) {\r\n        //   indexer = function(b, r, g) { return getColorIndex(r, g, b); };\r\n        //   D = ['b', 'r', 'g'];\r\n        // }\r\n        // partialsum = new Uint32Array(vbox[D[0] + \"2\"] + 1);\r\n        // console.log(vbox[D[0] + \"2\"])\r\n        // for (i = vbox[D[0] + \"1\"]; i <= vbox[D[0] + \"2\"]; i++) {\r\n        //     sum = 0;\r\n        //     for (j = vbox[D[1] + \"1\"]; j <= vbox[D[1] + \"2\"]; j++) {\r\n        //         for (k = vbox[D[2] + \"1\"]; k <= vbox[D[2] + \"2\"]; k++) {\r\n        //             index = indexer(i, j, k);\r\n        //             sum += histo[index];\r\n        //         }\r\n        //     }\r\n        //     total += sum;\r\n        //     console.log(i + \"->\" + total)\r\n        //     partialsum[i] = total;\r\n        // }\r\n        var maxd = 'b';\r\n        if (maxw == rw) {\r\n            maxd = 'r';\r\n            partialsum = new Uint32Array(vbox.r2 + 1);\r\n            for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                        index = getColorIndex(i, j, k);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        } else if (maxw == gw) {\r\n            maxd = 'g';\r\n            partialsum = new Uint32Array(vbox.g2 + 1);\r\n            for (i = vbox.g1; i <= vbox.g2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.r1; j <= vbox.r2; j++) {\r\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                        index = getColorIndex(j, i, k);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        } else { /* maxw == bw */\r\n            // maxd = 'b';\r\n            partialsum = new Uint32Array(vbox.b2 + 1);\r\n            for (i = vbox.b1; i <= vbox.b2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.r1; j <= vbox.r2; j++) {\r\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\r\n                        index = getColorIndex(j, k, i);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        }\r\n        var splitPoint = -1;\r\n        lookaheadsum = new Uint32Array(partialsum.length);\r\n        for (i = 0; i < partialsum.length; i++) {\r\n          var d = partialsum[i];\r\n          if (splitPoint < 0 && d > (total / 2)) splitPoint = i;\r\n          lookaheadsum[i] = total - d\r\n        }\r\n        // partialsum.forEach(function(d, i) {\r\n        //   if (splitPoint < 0 && d > (total / 2)) splitPoint = i\r\n        //     lookaheadsum[i] = total - d\r\n        // });\r\n\r\n        // console.log('cut')\r\n        function doCut(color) {\r\n            var dim1 = color + '1',\r\n                dim2 = color + '2',\r\n                left, right, vbox1, vbox2, d2, count2 = 0,\r\n                i = splitPoint;\r\n            vbox1 = vbox.copy();\r\n            vbox2 = vbox.copy();\r\n            left = i - vbox[dim1];\r\n            right = vbox[dim2] - i;\r\n            if (left <= right) {\r\n                d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\r\n                d2 = Math.max(0, d2);\r\n            } else {\r\n                d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\r\n                d2 = Math.min(vbox[dim2], d2);\r\n            }\r\n            // console.log(partialsum[d2])\r\n            // avoid 0-count boxes\r\n            while (!partialsum[d2]) d2++;\r\n            count2 = lookaheadsum[d2];\r\n            // console.log('-_-')\r\n            while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\r\n            // set dimensions\r\n            vbox1[dim2] = d2;\r\n            vbox2[dim1] = vbox1[dim2] + 1;\r\n            // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\r\n            return [vbox1, vbox2];\r\n\r\n        }\r\n        // determine the cut planes\r\n        return doCut(maxd);\r\n        // return maxw == rw ? doCut('r') :\r\n        //     maxw == gw ? doCut('g') :\r\n        //     doCut('b');\r\n    }\r\n\r\n    function quantize(pixels, opts) {\r\n        var maxcolors = opts.colorCount;\r\n        // short-circuit\r\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\r\n            // console.log('wrong number of maxcolors');\r\n            return false;\r\n        }\r\n\r\n        var hasFilters = Array.isArray(opts.filters) && opts.filters.length > 0;\r\n        function shouldIgnore(r, g, b, a) {\r\n          for (var i = 0; i < opts.filters.length; i++) {\r\n            var f = opts.filters[i];\r\n            if (!f(r, g, b, a)) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        }\r\n\r\n        var r = getAll(pixels, hasFilters ? houldIgnore : null);\r\n        // XXX: check color content and convert to grayscale if insufficient\r\n\r\n        // var histo = getHisto(pixels, hasFilters ? shouldIgnore : null),\r\n        var histo = r.histo,\r\n            histosize = 1 << (3 * sigbits);\r\n\r\n        // check that we aren't below maxcolors already\r\n        var nColors = Object.keys(histo).length;\r\n        if (nColors <= maxcolors) {\r\n            // XXX: generate the new colors from the histo and return\r\n        }\r\n\r\n        // get the beginning vbox from the colors\r\n        // var vbox = vboxFromPixels(pixels, histo, hasFilters ? shouldIgnore : null),\r\n        var vbox = r.vbox,\r\n            pq = new PQueue(function(a, b) {\r\n                return pv.naturalOrder(a.count(), b.count())\r\n            });\r\n        pq.push(vbox);\r\n\r\n        // inner function to do the iteration\r\n\r\n        function iter(lh, target) {\r\n            var ncolors = 1,\r\n                niters = 0,\r\n                vbox;\r\n            while (niters < maxIterations) {\r\n                vbox = lh.pop();\r\n                if (!vbox.count()) { /* just put it back */\r\n                    // lh.push(vbox); // Maybe not\r\n                    niters++;\r\n                    continue;\r\n                }\r\n                // do the cut\r\n                var vboxes = medianCutApply(histo, vbox),\r\n                    vbox1 = vboxes[0],\r\n                    vbox2 = vboxes[1];\r\n\r\n                if (!vbox1) {\r\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\r\n                    return;\r\n                }\r\n                lh.push(vbox1);\r\n                if (vbox2) { /* vbox2 can be null */\r\n                    lh.push(vbox2);\r\n                    ncolors++;\r\n                }\r\n                if (ncolors >= target) return;\r\n                if (niters++ > maxIterations) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // first set of colors, sorted by population\r\n        iter(pq, fractByPopulations * maxcolors);\r\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\r\n\r\n        // Re-sort by the product of pixel occupancy times the size in color space.\r\n        var pq2 = new PQueue(function(a, b) {\r\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\r\n        });\r\n        while (pq.size()) {\r\n            pq2.push(pq.pop());\r\n        }\r\n\r\n        // next set - generate the median cuts using the (npix * vol) sorting.\r\n        iter(pq2, maxcolors - pq2.size());\r\n\r\n        // calculate the actual colors\r\n        var cmap = new CMap();\r\n        while (pq2.size()) {\r\n            var v = pq2.pop(),\r\n              c = vbox.avg();\r\n            if (!hasFilters || !shouldIgnore(c[0], c[1], c[2], 255)) {\r\n              cmap.push(v);\r\n            }\r\n        }\r\n\r\n        return cmap;\r\n    }\r\n\r\n    return {\r\n        quantize: quantize,\r\n        getAll: getAll,\r\n        medianCutApply: medianCutApply\r\n    }\r\n})();\r\n\r\nmodule.exports = MMCQ.quantize\r\nmodule.exports.getAll = MMCQ.getAll\r\nmodule.exports.splitBox = MMCQ.medianCutApply\r\n\n},{}],22:[function(require,module,exports){\n(function (process){\n  /* globals require, module */\n\n  'use strict';\n\n  /**\n   * Module dependencies.\n   */\n\n  var pathtoRegexp = require('path-to-regexp');\n\n  /**\n   * Module exports.\n   */\n\n  module.exports = page;\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var location = ('undefined' !== typeof window) && (window.history.location || window.location);\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n\n  /**\n   * Decode URL components (query string, pathname, hash).\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\n   */\n  var decodeURLComponents = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * HashBang option\n   */\n\n  var hashbang = false;\n\n  /**\n   * Previous context, for capturing\n   * page exit events.\n   */\n\n  var prevContext;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {String|Function} path\n   * @param {Function} fn...\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(path);\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n  page.exits = [];\n\n  /**\n   * Current path being processed\n   * @type {String}\n   */\n  page.current = '';\n\n  /**\n   * Number of pages navigated to.\n   * @type {number}\n   *\n   *     page.len == 0;\n   *     page('/login');\n   *     page.len == 1;\n   */\n\n  page.len = 0;\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {String} path\n   * @api public\n   */\n\n  page.base = function(path) {\n    if (0 === arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options) {\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click) {\n      document.addEventListener(clickEvent, onclick, false);\n    }\n    if (true === options.hashbang) hashbang = true;\n    if (!dispatch) return;\n    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function() {\n    if (!running) return;\n    page.current = '';\n    page.len = 0;\n    running = false;\n    document.removeEventListener(clickEvent, onclick, false);\n    window.removeEventListener('popstate', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @param {Boolean} dispatch\n   * @return {Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    if (false !== dispatch) page.dispatch(ctx);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {String} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object} [state]\n   * @api public\n   */\n\n  page.back = function(path, state) {\n    if (page.len > 0) {\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      history.back();\n      page.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    }else{\n      setTimeout(function() {\n        page.show(base, state);\n      });\n    }\n  };\n\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {String} from - if param 'to' is undefined redirects to 'from'\n   * @param {String} [to]\n   * @api public\n   */\n  page.redirect = function(from, to) {\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page(from, function(e) {\n        setTimeout(function() {\n          page.replace(to);\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        page.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @return {Context}\n   * @api public\n   */\n\n\n  page.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) page.dispatch(ctx);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Object} ctx\n   * @api private\n   */\n\n  page.dispatch = function(ctx) {\n    var prev = prevContext,\n      i = 0,\n      j = 0;\n\n    prevContext = ctx;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled(ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n\n    if (hashbang) {\n      current = base + location.hash.replace('#!', '');\n    } else {\n      current = location.pathname + location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    location.href = ctx.canonicalPath;\n  }\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  page.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return page.exit('*', path);\n    }\n\n    var route = new Route(path);\n    for (var i = 1; i < arguments.length; ++i) {\n      page.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {str} URL component to decode\n   */\n  function decodeURLEncodedURIComponent(val) {\n    if (typeof val !== 'string') { return val; }\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = parts[0];\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    page.len++;\n    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @param {String} path\n   * @param {Object} options.\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(this.path,\n      this.keys = [],\n      options.sensitive,\n      options.strict);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {String} path\n   * @param {Object} params\n   * @return {Boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  var onpopstate = (function () {\n    var loaded = false;\n    if ('undefined' === typeof window) {\n      return;\n    }\n    if (document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else {\n        page.show(location.pathname + location.hash, undefined, undefined, false);\n      }\n    };\n  })();\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n\n    if (1 !== which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n\n\n    // ensure link\n    var el = e.target;\n    while (el && 'A' !== el.nodeName) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName) return;\n\n\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;\n\n\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    if (el.target) return;\n\n    // x-origin\n    if (!sameOrigin(el.href)) return;\n\n\n\n    // rebuild path\n    var path = el.pathname + el.search + (el.hash || '');\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n\n    if (path.indexOf(base) === 0) {\n      path = path.substr(base.length);\n    }\n\n    if (hashbang) path = path.replace('#!', '');\n\n    if (base && orig === path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null === e.which ? e.button : e.which;\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return (href && (0 === href.indexOf(origin)));\n  }\n\n  page.sameOrigin = sameOrigin;\n\n}).call(this,require('_process'))\n\n},{\"_process\":24,\"path-to-regexp\":23}],23:[function(require,module,exports){\nvar isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n\n},{\"isarray\":1}],24:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],25:[function(require,module,exports){\n/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n\n// fill out a couple protovis dependencies\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nif (!pv) {\n    var pv = {\n        map: function(array, f) {\n            var o = {};\n            return f ? array.map(function(d, i) {\n                o.index = i;\n                return f.call(o, d);\n            }) : array.slice();\n        },\n        naturalOrder: function(a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function(array, f) {\n            var o = {};\n            return array.reduce(f ? function(p, d, i) {\n                o.index = i;\n                return p + f.call(o, d);\n            } : function(p, d) {\n                return p + d;\n            }, 0);\n        },\n        max: function(array, f) {\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    }\n}\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\nvar MMCQ = (function() {\n    // private constants\n    var sigbits = 5,\n        rshift = 8 - sigbits,\n        maxIterations = 1000,\n        fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n\n    function PQueue(comparator) {\n        var contents = [],\n            sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function(o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function(index) {\n                if (!sorted) sort();\n                if (index === undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function() {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function() {\n                return contents.length;\n            },\n            map: function(f) {\n                return contents.map(f);\n            },\n            debug: function() {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function(force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0,\n                    i, j, k;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            index = getColorIndex(i, j, k);\n                            npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function() {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0,\n                    mult = 1 << (8 - sigbits),\n                    rsum = 0,\n                    gsum = 0,\n                    bsum = 0,\n                    hval,\n                    i, j, k, histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            histoindex = getColorIndex(i, j, k);\n                            hval = histo[histoindex] || 0;\n                            ntot += hval;\n                            rsum += (hval * (i + 0.5) * mult);\n                            gsum += (hval * (j + 0.5) * mult);\n                            bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\n                } else {\n                    //console.log('empty box');\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function(pixel) {\n            var vbox = this,\n                rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                gval >= vbox.g1 && gval <= vbox.g2 &&\n                bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n\n    function CMap() {\n        this.vboxes = new PQueue(function(a, b) {\n            return pv.naturalOrder(\n                a.vbox.count() * a.vbox.volume(),\n                b.vbox.count() * b.vbox.volume()\n            )\n        });;\n    }\n    CMap.prototype = {\n        push: function(vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function() {\n            return this.vboxes.map(function(vb) {\n                return vb.color\n            });\n        },\n        size: function() {\n            return this.vboxes.size();\n        },\n        map: function(color) {\n            var vboxes = this.vboxes;\n            for (var i = 0; i < vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function(color) {\n            var vboxes = this.vboxes,\n                d1, d2, pColor;\n            for (var i = 0; i < vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function() {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function(a, b) {\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\n            });\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0, 0, 0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length - 1,\n                highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255, 255, 255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits),\n            histo = new Array(histosize),\n            index, rval, gval, bval;\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin = 1000000,\n            rmax = 0,\n            gmin = 1000000,\n            gmax = 0,\n            bmin = 1000000,\n            bmax = 0,\n            rval, gval, bval;\n        // find min/max\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax) bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1,\n            gw = vbox.g2 - vbox.g1 + 1,\n            bw = vbox.b2 - vbox.b1 + 1,\n            maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()]\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0,\n            partialsum = [],\n            lookaheadsum = [],\n            i, j, k, sum, index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i, j, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j, i, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else { /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j, k, i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function(d, i) {\n            lookaheadsum[i] = total - d\n        });\n\n        function doCut(color) {\n            var dim1 = color + '1',\n                dim2 = color + '2',\n                left, right, vbox1, vbox2, d2, count2 = 0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n                    // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n            doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n            // console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels),\n            histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function() {\n            nColors++\n        });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo),\n            pq = new PQueue(function(a, b) {\n                return pv.naturalOrder(a.count(), b.count())\n            });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n\n        function iter(lh, target) {\n            var ncolors = 1,\n                niters = 0,\n                vbox;\n            while (niters < maxIterations) {\n                vbox = lh.pop();\n                if (!vbox.count()) { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox),\n                    vbox1 = vboxes[0],\n                    vbox2 = vboxes[1];\n\n                if (!vbox1) {\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) { /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n                    // console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function(a, b) {\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors - pq2.size());\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    }\n})();\n\nmodule.exports = MMCQ.quantize\n\n},{}],26:[function(require,module,exports){\n(function() {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this._initBody(bodyInit)\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      xhr.onload = function() {\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})();\n\n},{}],27:[function(require,module,exports){\n'use strict';\n\nvar _page = require('page');\n\nvar _page2 = _interopRequireDefault(_page);\n\nvar _whatwgFetch = require('whatwg-fetch');\n\nvar _whatwgFetch2 = _interopRequireDefault(_whatwgFetch);\n\nvar _tabs = require('./js/tabs.js');\n\nvar _tabs2 = _interopRequireDefault(_tabs);\n\nvar _nodeVibrant = require('node-vibrant');\n\nvar _nodeVibrant2 = _interopRequireDefault(_nodeVibrant);\n\nvar _figureBg = require('./js/figure-bg.js');\n\nvar _figureBg2 = _interopRequireDefault(_figureBg);\n\nvar _imgfill = require('./js/vendor/imgfill.js');\n\nvar _imgfill2 = _interopRequireDefault(_imgfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import particlesJS from 'particles.js';\n\nfunction ToggleNav() {\n\tvar navToggle = document.querySelector('.js-navToggle');\n\tvar MobileNav = document.querySelector('.MobileNav');\n\tvar navToggleClose = document.querySelector('.js-navToggleClose');\n\n\tnavToggle.addEventListener('click', function (evt) {\n\t\tevt.preventDefault();\n\t\tMobileNav.classList.add('is-active');\n\t}, false);\n\n\tnavToggleClose.addEventListener('click', function (evt) {\n\t\tevt.preventDefault();\n\t\tMobileNav.classList.remove('is-active');\n\t}, false);\n}\n\n// Call Function\n\nToggleNav();\n(0, _figureBg2.default)();\n\n(0, _imgfill2.default)('.imgFill', '.imgFillSrc');\n\n// Vanilla\ndocument.addEventListener('DOMContentLoaded', function () {\n\tparticlesJS.load('particles-js', '../asset/js/particlesjs-config1.json', function () {\n\t\tconsole.log('callback - particles.js config loaded');\n\t});\n});\n\n},{\"./js/figure-bg.js\":28,\"./js/tabs.js\":29,\"./js/vendor/imgfill.js\":30,\"node-vibrant\":2,\"page\":22,\"whatwg-fetch\":26}],28:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _nodeVibrant = require('node-vibrant');\n\nvar _nodeVibrant2 = _interopRequireDefault(_nodeVibrant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FigureBg = function FigureBg() {\n  var Figures = Array.from(document.querySelectorAll('.Figure--slideDown'));\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var Figure = _step.value;\n\n      var imgSrc = Figure.querySelector('img').getAttribute('src');\n      var FigCaption = Figure.querySelector('figcaption');\n\n      var bgColor = new _nodeVibrant2.default(imgSrc);\n      bgColor.getPalette(function (err, palette) {\n        if (err) {\n          FigCaption.style.backgroundColor('#ffffff');\n        } else {\n          var hexColor = palette.Vibrant.rgb.join();\n          var bodyColor = palette.Vibrant.getTitleTextColor();\n          FigCaption.style.backgroundColor = 'rgba(' + hexColor + ', 1)';\n          FigCaption.style.color = bodyColor;\n        }\n      });\n    };\n\n    for (var _iterator = Figures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      _loop();\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n};\n\nexports.default = FigureBg;\n\n},{\"node-vibrant\":2}],29:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar childHidden = function childHidden(el) {\n  var elHidden = document.querySelectorAll(el);\n  for (var i = 0; i < elHidden.length; i++) {\n    elHidden[i].style.display = 'none';\n  }\n};\n\nvar Tabs = function Tabs() {\n  var Tab = document.querySelector('.Tab');\n  var TabAchor = Tab.querySelector('.TabAchor');\n  var TabContent = Tab.querySelector('.TabContent');\n};\n\nexports.default = Tabs;\n\n},{}],30:[function(require,module,exports){\n'use strict';\n\n// usage:\n// imgFill(target, imgSrc)\n// require es6\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar setCSS = function setCSS(element) {\n  var CSS = {\n    backgroundSize: \"cover\",\n    backgroundPosition: \"center\",\n    backgroundRepeat: \"no-repeat\"\n  };\n  // create multiple CSS Property\n  for (var i in CSS) {\n    element.style[i] = CSS[i];\n  }\n};\n\nvar imgFill = function imgFill(target, srcClass) {\n  var imgConts = Array.from(document.querySelectorAll(target));\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = imgConts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var img = _step.value;\n\n      // define image source class\n      var imgSrc = img.querySelector(srcClass);\n\n      // Get image source url\n      var imgSrcURL = imgSrc.getAttribute('src');\n\n      // hide source images\n      imgSrc.style.display = 'none';\n      // Set Multiple CSS Property\n      img.style.backgroundImage = 'url(' + imgSrcURL + ')';\n      setCSS(img);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n};\n\nexports.default = imgFill;\n\n},{}]},{},[27])\n\n","var Vibrant;\n\nVibrant = require('./vibrant');\n\nVibrant.DefaultOpts.Image = require('./image/browser');\n\nmodule.exports = Vibrant;\n","module.exports = function(r, g, b, a) {\n  return a >= 125 && !(r > 250 && g > 250 && b > 250);\n};\n","module.exports.Default = require('./default');\n","var DefaultGenerator, DefaultOpts, Generator, Swatch, util,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\nSwatch = require('../swatch');\n\nutil = require('../util');\n\nGenerator = require('./index');\n\nDefaultOpts = {\n  targetDarkLuma: 0.26,\n  maxDarkLuma: 0.45,\n  minLightLuma: 0.55,\n  targetLightLuma: 0.74,\n  minNormalLuma: 0.3,\n  targetNormalLuma: 0.5,\n  maxNormalLuma: 0.7,\n  targetMutesSaturation: 0.3,\n  maxMutesSaturation: 0.4,\n  targetVibrantSaturation: 1.0,\n  minVibrantSaturation: 0.35,\n  weightSaturation: 3,\n  weightLuma: 6,\n  weightPopulation: 1\n};\n\nmodule.exports = DefaultGenerator = (function(superClass) {\n  extend(DefaultGenerator, superClass);\n\n  DefaultGenerator.prototype.HighestPopulation = 0;\n\n  function DefaultGenerator(opts) {\n    this.opts = util.defaults(opts, DefaultOpts);\n    this.VibrantSwatch = null;\n    this.LightVibrantSwatch = null;\n    this.DarkVibrantSwatch = null;\n    this.MutedSwatch = null;\n    this.LightMutedSwatch = null;\n    this.DarkMutedSwatch = null;\n  }\n\n  DefaultGenerator.prototype.generate = function(swatches) {\n    this.swatches = swatches;\n    this.maxPopulation = this.findMaxPopulation;\n    this.generateVarationColors();\n    return this.generateEmptySwatches();\n  };\n\n  DefaultGenerator.prototype.getVibrantSwatch = function() {\n    return this.VibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getLightVibrantSwatch = function() {\n    return this.LightVibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getDarkVibrantSwatch = function() {\n    return this.DarkVibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getMutedSwatch = function() {\n    return this.MutedSwatch;\n  };\n\n  DefaultGenerator.prototype.getLightMutedSwatch = function() {\n    return this.LightMutedSwatch;\n  };\n\n  DefaultGenerator.prototype.getDarkMutedSwatch = function() {\n    return this.DarkMutedSwatch;\n  };\n\n  DefaultGenerator.prototype.generateVarationColors = function() {\n    this.VibrantSwatch = this.findColorVariation(this.opts.targetNormalLuma, this.opts.minNormalLuma, this.opts.maxNormalLuma, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.LightVibrantSwatch = this.findColorVariation(this.opts.targetLightLuma, this.opts.minLightLuma, 1, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.DarkVibrantSwatch = this.findColorVariation(this.opts.targetDarkLuma, 0, this.opts.maxDarkLuma, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.MutedSwatch = this.findColorVariation(this.opts.targetNormalLuma, this.opts.minNormalLuma, this.opts.maxNormalLuma, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n    this.LightMutedSwatch = this.findColorVariation(this.opts.targetLightLuma, this.opts.minLightLuma, 1, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n    return this.DarkMutedSwatch = this.findColorVariation(this.opts.targetDarkLuma, 0, this.opts.maxDarkLuma, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n  };\n\n  DefaultGenerator.prototype.generateEmptySwatches = function() {\n    var hsl;\n    if (this.VibrantSwatch === null) {\n      if (this.DarkVibrantSwatch !== null) {\n        hsl = this.DarkVibrantSwatch.getHsl();\n        hsl[2] = this.opts.targetNormalLuma;\n        this.VibrantSwatch = new Swatch(util.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);\n      }\n    }\n    if (this.DarkVibrantSwatch === null) {\n      if (this.VibrantSwatch !== null) {\n        hsl = this.VibrantSwatch.getHsl();\n        hsl[2] = this.opts.targetDarkLuma;\n        return this.DarkVibrantSwatch = new Swatch(util.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);\n      }\n    }\n  };\n\n  DefaultGenerator.prototype.findMaxPopulation = function() {\n    var j, len, population, ref, swatch;\n    population = 0;\n    ref = this.swatches;\n    for (j = 0, len = ref.length; j < len; j++) {\n      swatch = ref[j];\n      population = Math.max(population, swatch.getPopulation());\n    }\n    return population;\n  };\n\n  DefaultGenerator.prototype.findColorVariation = function(targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation) {\n    var j, len, luma, max, maxValue, ref, sat, swatch, value;\n    max = null;\n    maxValue = 0;\n    ref = this.swatches;\n    for (j = 0, len = ref.length; j < len; j++) {\n      swatch = ref[j];\n      sat = swatch.getHsl()[1];\n      luma = swatch.getHsl()[2];\n      if (sat >= minSaturation && sat <= maxSaturation && luma >= minLuma && luma <= maxLuma && !this.isAlreadySelected(swatch)) {\n        value = this.createComparisonValue(sat, targetSaturation, luma, targetLuma, swatch.getPopulation(), this.HighestPopulation);\n        if (max === null || value > maxValue) {\n          max = swatch;\n          maxValue = value;\n        }\n      }\n    }\n    return max;\n  };\n\n  DefaultGenerator.prototype.createComparisonValue = function(saturation, targetSaturation, luma, targetLuma, population, maxPopulation) {\n    return this.weightedMean(this.invertDiff(saturation, targetSaturation), this.opts.weightSaturation, this.invertDiff(luma, targetLuma), this.opts.weightLuma, population / maxPopulation, this.opts.weightPopulation);\n  };\n\n  DefaultGenerator.prototype.invertDiff = function(value, targetValue) {\n    return 1 - Math.abs(value - targetValue);\n  };\n\n  DefaultGenerator.prototype.weightedMean = function() {\n    var i, sum, sumWeight, value, values, weight;\n    values = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    sum = 0;\n    sumWeight = 0;\n    i = 0;\n    while (i < values.length) {\n      value = values[i];\n      weight = values[i + 1];\n      sum += value * weight;\n      sumWeight += weight;\n      i += 2;\n    }\n    return sum / sumWeight;\n  };\n\n  DefaultGenerator.prototype.isAlreadySelected = function(swatch) {\n    return this.VibrantSwatch === swatch || this.DarkVibrantSwatch === swatch || this.LightVibrantSwatch === swatch || this.MutedSwatch === swatch || this.DarkMutedSwatch === swatch || this.LightMutedSwatch === swatch;\n  };\n\n  return DefaultGenerator;\n\n})(Generator);\n","var Generator;\n\nmodule.exports = Generator = (function() {\n  function Generator() {}\n\n  Generator.prototype.generate = function(swatches) {};\n\n  Generator.prototype.getVibrantSwatch = function() {};\n\n  Generator.prototype.getLightVibrantSwatch = function() {};\n\n  Generator.prototype.getDarkVibrantSwatch = function() {};\n\n  Generator.prototype.getMutedSwatch = function() {};\n\n  Generator.prototype.getLightMutedSwatch = function() {};\n\n  Generator.prototype.getDarkMutedSwatch = function() {};\n\n  return Generator;\n\n})();\n\nmodule.exports.Default = require('./default');\n","var BrowserImage, Image,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nImage = require('./index');\n\nmodule.exports = BrowserImage = (function(superClass) {\n  extend(BrowserImage, superClass);\n\n  function BrowserImage(path, cb) {\n    this.img = document.createElement('img');\n    this.img.crossOrigin = 'anonymous';\n    this.img.src = path;\n    this.img.onload = (function(_this) {\n      return function() {\n        _this._initCanvas();\n        return typeof cb === \"function\" ? cb(null, _this) : void 0;\n      };\n    })(this);\n    this.img.onerror = (function(_this) {\n      return function(e) {\n        var err;\n        err = new Error(\"Fail to load image: \" + path);\n        err.raw = e;\n        return typeof cb === \"function\" ? cb(err) : void 0;\n      };\n    })(this);\n  }\n\n  BrowserImage.prototype._initCanvas = function() {\n    this.canvas = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n    document.body.appendChild(this.canvas);\n    this.width = this.canvas.width = this.img.width;\n    this.height = this.canvas.height = this.img.height;\n    return this.context.drawImage(this.img, 0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.clear = function() {\n    return this.context.clearRect(0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.getWidth = function() {\n    return this.width;\n  };\n\n  BrowserImage.prototype.getHeight = function() {\n    return this.height;\n  };\n\n  BrowserImage.prototype.resize = function(w, h, r) {\n    this.width = this.canvas.width = w;\n    this.height = this.canvas.height = h;\n    this.context.scale(r, r);\n    return this.context.drawImage(this.img, 0, 0);\n  };\n\n  BrowserImage.prototype.update = function(imageData) {\n    return this.context.putImageData(imageData, 0, 0);\n  };\n\n  BrowserImage.prototype.getPixelCount = function() {\n    return this.width * this.height;\n  };\n\n  BrowserImage.prototype.getImageData = function() {\n    return this.context.getImageData(0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.removeCanvas = function() {\n    return this.canvas.parentNode.removeChild(this.canvas);\n  };\n\n  return BrowserImage;\n\n})(Image);\n","var Image;\n\nmodule.exports = Image = (function() {\n  function Image() {}\n\n  Image.prototype.clear = function() {};\n\n  Image.prototype.update = function(imageData) {};\n\n  Image.prototype.getWidth = function() {};\n\n  Image.prototype.getHeight = function() {};\n\n  Image.prototype.scaleDown = function(opts) {\n    var height, maxSide, ratio, width;\n    width = this.getWidth();\n    height = this.getHeight();\n    ratio = 1;\n    if (opts.maxDimension != null) {\n      maxSide = Math.max(width, height);\n      if (maxSide > opts.maxDimension) {\n        ratio = opts.maxDimension / maxSide;\n      }\n    } else {\n      ratio = 1 / opts.quality;\n    }\n    if (ratio < 1) {\n      return this.resize(width * ratio, height * ratio, ratio);\n    }\n  };\n\n  Image.prototype.resize = function(w, h, r) {};\n\n  Image.prototype.getPixelCount = function() {};\n\n  Image.prototype.getImageData = function() {};\n\n  Image.prototype.removeCanvas = function() {};\n\n  return Image;\n\n})();\n","var BaselineQuantizer, Quantizer, Swatch, quantize,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nquantize = require('quantize');\n\nmodule.exports = BaselineQuantizer = (function(superClass) {\n  extend(BaselineQuantizer, superClass);\n\n  function BaselineQuantizer() {\n    return BaselineQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  BaselineQuantizer.prototype.initialize = function(pixels, opts) {\n    var a, allPixels, b, cmap, g, i, offset, pixelCount, r;\n    this.opts = opts;\n    pixelCount = pixels.length / 4;\n    allPixels = [];\n    i = 0;\n    while (i < pixelCount) {\n      offset = i * 4;\n      r = pixels[offset + 0];\n      g = pixels[offset + 1];\n      b = pixels[offset + 2];\n      a = pixels[offset + 3];\n      if (a >= 125) {\n        if (!(r > 250 && g > 250 && b > 250)) {\n          allPixels.push([r, g, b]);\n        }\n      }\n      i = i + this.opts.quality;\n    }\n    cmap = quantize(allPixels, this.opts.colorCount);\n    return this.swatches = cmap.vboxes.map((function(_this) {\n      return function(vbox) {\n        return new Swatch(vbox.color, vbox.vbox.count());\n      };\n    })(this));\n  };\n\n  BaselineQuantizer.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return BaselineQuantizer;\n\n})(Quantizer);\n","var ColorCut, ColorCutQuantizer, Quantizer, Swatch,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nColorCut = require('./impl/color-cut');\n\nmodule.exports = ColorCutQuantizer = (function(superClass) {\n  extend(ColorCutQuantizer, superClass);\n\n  function ColorCutQuantizer() {\n    return ColorCutQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  ColorCutQuantizer.prototype.initialize = function(pixels, opts) {\n    var buf, buf8, data;\n    this.opts = opts;\n    buf = new ArrayBuffer(pixels.length);\n    buf8 = new Uint8ClampedArray(buf);\n    data = new Uint32Array(buf);\n    buf8.set(pixels);\n    return this.quantizer = new ColorCut(data, this.opts);\n  };\n\n  ColorCutQuantizer.prototype.getQuantizedColors = function() {\n    return this.quantizer.getQuantizedColors();\n  };\n\n  return ColorCutQuantizer;\n\n})(Quantizer);\n","var ABGRColor, COMPONENT_BLUE, COMPONENT_GREEN, COMPONENT_RED, Color, ColorCutQuantizer, QUANTIZE_WORD_MASK, QUANTIZE_WORD_WIDTH, RGBAColor, Swatch, Vbox, approximateToRgb888, isLittleEndian, modifySignificantOctet, modifyWordWidth, quantizeFromRgb888, quantizedBlue, quantizedGreen, quantizedRed, sort;\n\nSwatch = require('../../swatch');\n\nsort = function(arr, lower, upper) {\n  var partition, pivot, swap;\n  swap = function(a, b) {\n    var t;\n    t = arr[a];\n    arr[a] = arr[b];\n    return arr[b] = t;\n  };\n  partition = function(pivot, left, right) {\n    var index, j, ref, ref1, v, value;\n    index = left;\n    value = arr[pivot];\n    swap(pivot, right);\n    for (v = j = ref = left, ref1 = right - 1; ref <= ref1 ? j <= ref1 : j >= ref1; v = ref <= ref1 ? ++j : --j) {\n      if (arr[v] > value) {\n        swap(v, index);\n        index++;\n      }\n    }\n    swap(right, index);\n    return index;\n  };\n  if (lower < upper) {\n    pivot = lower + Math.ceil((upper - lower) / 2);\n    pivot = partition(pivot, lower, upper);\n    sort(arr, lower, pivot - 1);\n    return sort(arr, pivot + 1, upper);\n  }\n};\n\nCOMPONENT_RED = -3;\n\nCOMPONENT_GREEN = -2;\n\nCOMPONENT_BLUE = -1;\n\nQUANTIZE_WORD_WIDTH = 5;\n\nQUANTIZE_WORD_MASK = (1 << QUANTIZE_WORD_WIDTH) - 1;\n\nRGBAColor = {\n  red: function(c) {\n    return c >> 24;\n  },\n  green: function(c) {\n    return c << 8 >> 24;\n  },\n  blue: function(c) {\n    return c << 16 >> 24;\n  },\n  alpha: function(c) {\n    return c << 24 >> 24;\n  }\n};\n\nABGRColor = {\n  red: function(c) {\n    return c << 24 >> 24;\n  },\n  green: function(c) {\n    return c << 16 >> 24;\n  },\n  blue: function(c) {\n    return c << 8 >> 24;\n  },\n  alpha: function(c) {\n    return c >> 24;\n  }\n};\n\nisLittleEndian = function() {\n  var a, b, c;\n  a = new ArrayBuffer(4);\n  b = new Uint8Array(a);\n  c = new Uint32Array(a);\n  b[0] = 0xa1;\n  b[1] = 0xb2;\n  b[2] = 0xc3;\n  b[3] = 0xd4;\n  if (c[0] === 0xd4c3b2a1) {\n    return true;\n  }\n  if (c[0] === 0xa1b2c3d4) {\n    return false;\n  }\n  throw new Error(\"Failed to determin endianness\");\n};\n\nColor = isLittleEndian() ? ABGRColor : RGBAColor;\n\nmodifyWordWidth = function(value, current, target) {\n  var newValue;\n  newValue = 0;\n  if (target > current) {\n    newValue = value << (target - current);\n  } else {\n    newValue = value >> (current - target);\n  }\n  return newValue & ((1 << target) - 1);\n};\n\nmodifySignificantOctet = function(a, dimension, lower, upper) {\n  var color, i, j, k, ref, ref1, ref2, ref3;\n  switch (dimension) {\n    case COMPONENT_RED:\n      break;\n    case COMPONENT_GREEN:\n      for (i = j = ref = lower, ref1 = upper; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n        color = a[i];\n        a[i] = quantizedGreen(color) << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | quantizedRed(color) << QUANTIZE_WORD_WIDTH | quantizedBlue(color);\n      }\n      break;\n    case COMPONENT_BLUE:\n      for (i = k = ref2 = lower, ref3 = upper; ref2 <= ref3 ? k <= ref3 : k >= ref3; i = ref2 <= ref3 ? ++k : --k) {\n        color = a[i];\n        a[i] = quantizedBlue(color) << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | quantizedGreen(color) << QUANTIZE_WORD_WIDTH | quantizedRed(color);\n      }\n      break;\n  }\n};\n\nquantizeFromRgb888 = function(color) {\n  var b, g, r;\n  r = modifyWordWidth(Color.red(color), 8, QUANTIZE_WORD_WIDTH);\n  g = modifyWordWidth(Color.green(color), 8, QUANTIZE_WORD_WIDTH);\n  b = modifyWordWidth(Color.blue(color), 8, QUANTIZE_WORD_WIDTH);\n  return r << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | g << QUANTIZE_WORD_WIDTH | b;\n};\n\napproximateToRgb888 = function(r, g, b) {\n  var color;\n  if (!((g != null) && (b != null))) {\n    color = r;\n    r = quantizedRed(color);\n    g = quantizedGreen(color);\n    b = quantizedBlue(color);\n  }\n  return [modifyWordWidth(r, QUANTIZE_WORD_WIDTH, 8), modifyWordWidth(g, QUANTIZE_WORD_WIDTH, 8), modifyWordWidth(b, QUANTIZE_WORD_WIDTH, 8)];\n};\n\nquantizedRed = function(color) {\n  return color >> (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) & QUANTIZE_WORD_MASK;\n};\n\nquantizedGreen = function(color) {\n  return color >> QUANTIZE_WORD_WIDTH & QUANTIZE_WORD_MASK;\n};\n\nquantizedBlue = function(color) {\n  return color & QUANTIZE_WORD_MASK;\n};\n\nmodule.exports = ColorCutQuantizer = (function() {\n  function ColorCutQuantizer(data, opts) {\n    var c, color, distinctColorCount, distinctColorIndex, i, j, k, l, m, quantizedColor, ref, ref1, ref2, ref3;\n    this.opts = opts;\n    this.hist = new Uint32Array(1 << (QUANTIZE_WORD_WIDTH * 3));\n    this.pixels = new Uint32Array(data.length);\n    for (i = j = 0, ref = data.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {\n      this.pixels[i] = quantizedColor = quantizeFromRgb888(data[i]);\n      this.hist[quantizedColor]++;\n    }\n    distinctColorCount = 0;\n    for (color = k = 0, ref1 = this.hist.length - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; color = 0 <= ref1 ? ++k : --k) {\n      if (this.hist[color] > 0) {\n        distinctColorCount++;\n      }\n    }\n    this.colors = new Uint32Array(distinctColorCount);\n    distinctColorIndex = 0;\n    for (color = l = 0, ref2 = this.hist.length - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; color = 0 <= ref2 ? ++l : --l) {\n      if (this.hist[color] > 0) {\n        this.colors[distinctColorIndex++] = color;\n      }\n    }\n    if (distinctColorCount <= this.opts.colorCount) {\n      this.quantizedColors = [];\n      for (i = m = 0, ref3 = this.colors.length - 1; 0 <= ref3 ? m <= ref3 : m >= ref3; i = 0 <= ref3 ? ++m : --m) {\n        c = this.colors[i];\n        this.quantizedColors.push(new Swatch(approximateToRgb888(c), this.hist[c]));\n      }\n    } else {\n      this.quantizedColors = this.quantizePixels(this.opts.colorCount);\n    }\n  }\n\n  ColorCutQuantizer.prototype.getQuantizedColors = function() {\n    return this.quantizedColors;\n  };\n\n  ColorCutQuantizer.prototype.quantizePixels = function(maxColors) {\n    var pq;\n    pq = new PriorityQueue({\n      comparator: Vbox.comparator\n    });\n    pq.queue(new Vbox(this.colors, this.hist, 0, this.colors.length - 1));\n    this.splitBoxes(pq, maxColors);\n    return this.generateAverageColors(pq);\n  };\n\n  ColorCutQuantizer.prototype.splitBoxes = function(queue, maxSize) {\n    var vbox;\n    while (queue.length < maxSize) {\n      vbox = queue.dequeue();\n      if (vbox != null ? vbox.canSplit() : void 0) {\n        queue.queue(vbox.splitBox());\n        queue.queue(vbox);\n      } else {\n        return;\n      }\n    }\n  };\n\n  ColorCutQuantizer.prototype.generateAverageColors = function(vboxes) {\n    var colors;\n    colors = [];\n    while (vboxes.length > 0) {\n      colors.push(vboxes.dequeue().getAverageColor());\n    }\n    return colors;\n  };\n\n  return ColorCutQuantizer;\n\n})();\n\nVbox = (function() {\n  Vbox.comparator = function(lhs, rhs) {\n    return lhs.getVolume() - rhs.getVolume();\n  };\n\n  function Vbox(colors1, hist, lowerIndex, upperIndex) {\n    this.colors = colors1;\n    this.hist = hist;\n    this.lowerIndex = lowerIndex;\n    this.upperIndex = upperIndex;\n    this.fitBox();\n  }\n\n  Vbox.prototype.getVolume = function() {\n    return (this.maxRed - this.minRed + 1) * (this.maxGreen - this.minGreen + 1) * (this.maxBlue - this.minBlue + 1);\n  };\n\n  Vbox.prototype.canSplit = function() {\n    return this.getColorCount() > 1;\n  };\n\n  Vbox.prototype.getColorCount = function() {\n    return 1 + this.upperIndex - this.lowerIndex;\n  };\n\n  Vbox.prototype.fitBox = function() {\n    var b, color, count, g, i, j, r, ref, ref1;\n    this.minRed = this.minGreen = this.minBlue = Number.MAX_VALUE;\n    this.maxRed = this.maxGreen = this.maxBlue = Number.MIN_VALUE;\n    this.population = 0;\n    count = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      color = this.colors[i];\n      count += this.hist[color];\n      r = quantizedRed(color);\n      g = quantizedGreen(color);\n      b = quantizedBlue(color);\n      if (r > this.maxRed) {\n        this.maxRed = r;\n      }\n      if (r < this.minRed) {\n        this.minRed = r;\n      }\n      if (g > this.maxGreen) {\n        this.maxGreen = g;\n      }\n      if (g < this.minGreen) {\n        this.minGreen = g;\n      }\n      if (b > this.maxBlue) {\n        this.maxRed = b;\n      }\n      if (b < this.minBlue) {\n        this.minRed = b;\n      }\n    }\n    return this.population = count;\n  };\n\n  Vbox.prototype.splitBox = function() {\n    var newBox, splitPoint;\n    if (!this.canSplit()) {\n      throw new Error(\"Cannot split a box with only 1 color\");\n    }\n    splitPoint = this.findSplitPoint();\n    newBox = new Vbox(this.colors, this.hist, splitPoint + 1, this.upperIndex);\n    this.upperIndex = splitPoint;\n    this.fitBox();\n    return newBox;\n  };\n\n  Vbox.prototype.getLongestColorDimension = function() {\n    var blueLength, greenLength, redLength;\n    redLength = this.maxRed - this.minRed;\n    greenLength = this.maxGreen - this.minGreen;\n    blueLength = this.maxBlue - this.minBlue;\n    if (redLength >= greenLength && redLength >= blueLength) {\n      return COMPONENT_RED;\n    }\n    if (greenLength >= redLength && greenLength >= blueLength) {\n      return COMPONENT_GREEN;\n    }\n    return COMPONENT_BLUE;\n  };\n\n  Vbox.prototype.findSplitPoint = function() {\n    var count, i, j, longestDimension, midPoint, ref, ref1;\n    longestDimension = this.getLongestColorDimension();\n    modifySignificantOctet(this.colors, longestDimension, this.lowerIndex, this.upperIndex);\n    sort(this.colors, this.lowerIndex, this.upperIndex + 1);\n    modifySignificantOctet(this.colors, longestDimension, this.lowerIndex, this.upperIndex);\n    midPoint = this.population / 2;\n    count = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      count += this.hist[this.colors[i]];\n      if (count >= midPoint) {\n        return i;\n      }\n    }\n    return this.lowerIndex;\n  };\n\n  Vbox.prototype.getAverageColor = function() {\n    var blueMean, blueSum, color, colorPopulation, greenMean, greenSum, i, j, redMean, redSum, ref, ref1, totalPopulation;\n    redSum = greenSum = blueSum = 0;\n    totalPopulation = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      color = this.colors[i];\n      colorPopulation = this.hist[color];\n      totalPopulation += colorPopulation;\n      redSum += colorPopulation * quantizedRed(color);\n      greenSum += colorPopulation * quantizedGreen(color);\n      blueSum += colorPopulation * quantizedBlue(color);\n    }\n    redMean = Math.round(redSum / totalPopulation);\n    greenMean = Math.round(greenSum / totalPopulation);\n    blueMean = Math.round(blueSum / totalPopulation);\n    return new Swatch(approximateToRgb888(redMean, greenMean, blueMean), totalPopulation);\n  };\n\n  return Vbox;\n\n})();\n","var MMCQ, PQueue, RSHIFT, SIGBITS, Swatch, VBox, getColorIndex, ref, util;\n\nref = util = require('../../util'), getColorIndex = ref.getColorIndex, SIGBITS = ref.SIGBITS, RSHIFT = ref.RSHIFT;\n\nSwatch = require('../../swatch');\n\nVBox = require('./vbox');\n\nPQueue = require('./pqueue');\n\nmodule.exports = MMCQ = (function() {\n  MMCQ.DefaultOpts = {\n    maxIterations: 1000,\n    fractByPopulations: 0.75\n  };\n\n  function MMCQ(opts) {\n    this.opts = util.defaults(opts, this.constructor.DefaultOpts);\n  }\n\n  MMCQ.prototype.quantize = function(pixels, opts) {\n    var color, colorCount, hist, pq, pq2, shouldIgnore, swatches, v, vbox;\n    if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n      throw new Error(\"Wrong MMCQ parameters\");\n    }\n    shouldIgnore = function() {\n      return false;\n    };\n    if (Array.isArray(opts.filters) && opts.filters.length > 0) {\n      shouldIgnore = function(r, g, b, a) {\n        var f, i, len, ref1;\n        ref1 = opts.filters;\n        for (i = 0, len = ref1.length; i < len; i++) {\n          f = ref1[i];\n          if (!f(r, g, b, a)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    vbox = VBox.build(pixels, shouldIgnore);\n    hist = vbox.hist;\n    colorCount = Object.keys(hist).length;\n    pq = new PQueue(function(a, b) {\n      return a.count() - b.count();\n    });\n    pq.push(vbox);\n    this._splitBoxes(pq, this.opts.fractByPopulations * opts.colorCount);\n    pq2 = new PQueue(function(a, b) {\n      return a.count() * a.volume() - b.count() * b.volume();\n    });\n    pq2.contents = pq.contents;\n    this._splitBoxes(pq2, opts.colorCount - pq2.size());\n    swatches = [];\n    this.vboxes = [];\n    while (pq2.size()) {\n      v = pq2.pop();\n      color = v.avg();\n      if (!(typeof shouldIgnore === \"function\" ? shouldIgnore(color[0], color[1], color[2], 255) : void 0)) {\n        this.vboxes.push(v);\n        swatches.push(new Swatch(color, v.count()));\n      }\n    }\n    return swatches;\n  };\n\n  MMCQ.prototype._splitBoxes = function(pq, target) {\n    var colorCount, iteration, maxIterations, ref1, vbox, vbox1, vbox2;\n    colorCount = 1;\n    iteration = 0;\n    maxIterations = this.opts.maxIterations;\n    while (iteration < maxIterations) {\n      iteration++;\n      vbox = pq.pop();\n      if (!vbox.count()) {\n        continue;\n      }\n      ref1 = vbox.split(), vbox1 = ref1[0], vbox2 = ref1[1];\n      pq.push(vbox1);\n      if (vbox2) {\n        pq.push(vbox2);\n        colorCount++;\n      }\n      if (colorCount >= target || iteration > maxIterations) {\n        return;\n      }\n    }\n  };\n\n  return MMCQ;\n\n})();\n","var PQueue;\n\nmodule.exports = PQueue = (function() {\n  function PQueue(comparator) {\n    this.comparator = comparator;\n    this.contents = [];\n    this.sorted = false;\n  }\n\n  PQueue.prototype._sort = function() {\n    this.contents.sort(this.comparator);\n    return this.sorted = true;\n  };\n\n  PQueue.prototype.push = function(o) {\n    this.contents.push(o);\n    return this.sorted = false;\n  };\n\n  PQueue.prototype.peek = function(index) {\n    if (!this.sorted) {\n      this._sort();\n    }\n    if (index == null) {\n      index = this.contents.length - 1;\n    }\n    return this.contents[index];\n  };\n\n  PQueue.prototype.pop = function() {\n    if (!this.sorted) {\n      this._sort();\n    }\n    return this.contents.pop();\n  };\n\n  PQueue.prototype.size = function() {\n    return this.contents.length;\n  };\n\n  PQueue.prototype.map = function(f) {\n    if (!this.sorted) {\n      this._sort();\n    }\n    return this.contents.map(f);\n  };\n\n  return PQueue;\n\n})();\n","var RSHIFT, SIGBITS, VBox, getColorIndex, ref, util;\n\nref = util = require('../../util'), getColorIndex = ref.getColorIndex, SIGBITS = ref.SIGBITS, RSHIFT = ref.RSHIFT;\n\nmodule.exports = VBox = (function() {\n  VBox.build = function(pixels, shouldIgnore) {\n    var a, b, bmax, bmin, g, gmax, gmin, hist, hn, i, index, n, offset, r, rmax, rmin;\n    hn = 1 << (3 * SIGBITS);\n    hist = new Uint32Array(hn);\n    rmax = gmax = bmax = 0;\n    rmin = gmin = bmin = Number.MAX_VALUE;\n    n = pixels.length / 4;\n    i = 0;\n    while (i < n) {\n      offset = i * 4;\n      i++;\n      r = pixels[offset + 0];\n      g = pixels[offset + 1];\n      b = pixels[offset + 2];\n      a = pixels[offset + 3];\n      if (shouldIgnore(r, g, b, a)) {\n        continue;\n      }\n      r = r >> RSHIFT;\n      g = g >> RSHIFT;\n      b = b >> RSHIFT;\n      index = getColorIndex(r, g, b);\n      hist[index] += 1;\n      if (r > rmax) {\n        rmax = r;\n      }\n      if (r < rmin) {\n        rmin = r;\n      }\n      if (g > gmax) {\n        gmax = g;\n      }\n      if (g < gmin) {\n        gmin = g;\n      }\n      if (b > bmax) {\n        bmax = b;\n      }\n      if (b < bmin) {\n        bmin = b;\n      }\n    }\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, hist);\n  };\n\n  function VBox(r1, r2, g1, g2, b1, b2, hist1) {\n    this.r1 = r1;\n    this.r2 = r2;\n    this.g1 = g1;\n    this.g2 = g2;\n    this.b1 = b1;\n    this.b2 = b2;\n    this.hist = hist1;\n  }\n\n  VBox.prototype.invalidate = function() {\n    delete this._count;\n    delete this._avg;\n    return delete this._volume;\n  };\n\n  VBox.prototype.volume = function() {\n    if (this._volume == null) {\n      this._volume = (this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1);\n    }\n    return this._volume;\n  };\n\n  VBox.prototype.count = function() {\n    var c, hist;\n    if (this._count == null) {\n      hist = this.hist;\n      c = 0;\n      \n      for (var r = this.r1; r <= this.r2; r++) {\n        for (var g = this.g1; g <= this.g2; g++) {\n          for (var b = this.b1; b <= this.b2; b++) {\n            var index = getColorIndex(r, g, b);\n            c += hist[index];\n          }\n        }\n      }\n      ;\n      this._count = c;\n    }\n    return this._count;\n  };\n\n  VBox.prototype.clone = function() {\n    return new VBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.hist);\n  };\n\n  VBox.prototype.avg = function() {\n    var bsum, gsum, hist, mult, ntot, rsum;\n    if (this._avg == null) {\n      hist = this.hist;\n      ntot = 0;\n      mult = 1 << (8 - SIGBITS);\n      rsum = gsum = bsum = 0;\n      \n      for (var r = this.r1; r <= this.r2; r++) {\n        for (var g = this.g1; g <= this.g2; g++) {\n          for (var b = this.b1; b <= this.b2; b++) {\n            var index = getColorIndex(r, g, b);\n            var h = hist[index];\n            ntot += h;\n            rsum += (h * (r + 0.5) * mult);\n            gsum += (h * (g + 0.5) * mult);\n            bsum += (h * (b + 0.5) * mult);\n          }\n        }\n      }\n      ;\n      if (ntot) {\n        this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n      } else {\n        this._avg = [~~(mult * (this.r1 + this.r2 + 1) / 2), ~~(mult * (this.g1 + this.g2 + 1) / 2), ~~(mult * (this.b1 + this.b2 + 1) / 2)];\n      }\n    }\n    return this._avg;\n  };\n\n  VBox.prototype.split = function() {\n    var accSum, bw, d, doCut, gw, hist, i, j, maxd, maxw, ref1, reverseSum, rw, splitPoint, sum, total, vbox;\n    hist = this.hist;\n    if (!this.count()) {\n      return null;\n    }\n    if (this.count() === 1) {\n      return [this.clone()];\n    }\n    rw = this.r2 - this.r1 + 1;\n    gw = this.g2 - this.g1 + 1;\n    bw = this.b2 - this.b1 + 1;\n    maxw = Math.max(rw, gw, bw);\n    accSum = null;\n    sum = total = 0;\n    maxd = null;\n    switch (maxw) {\n      case rw:\n        maxd = 'r';\n        accSum = new Uint32Array(this.r2 + 1);\n        \n        for (var r = this.r1; r <= this.r2; r++) {\n          sum = 0\n          for (var g = this.g1; g <= this.g2; g++) {\n            for (var b = this.b1; b <= this.b2; b++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[r] = total;\n        }\n        ;\n        break;\n      case gw:\n        maxd = 'g';\n        accSum = new Uint32Array(this.g2 + 1);\n        \n        for (var g = this.g1; g <= this.g2; g++) {\n          sum = 0\n          for (var r = this.r1; r <= this.r2; r++) {\n            for (var b = this.b1; b <= this.b2; b++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[g] = total;\n        }\n        ;\n        break;\n      case bw:\n        maxd = 'b';\n        accSum = new Uint32Array(this.b2 + 1);\n        \n        for (var b = this.b1; b <= this.b2; b++) {\n          sum = 0\n          for (var r = this.r1; r <= this.r2; r++) {\n            for (var g = this.g1; g <= this.g2; g++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[b] = total;\n        }\n        ;\n    }\n    splitPoint = -1;\n    reverseSum = new Uint32Array(accSum.length);\n    for (i = j = 0, ref1 = accSum.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n      d = accSum[i];\n      if (splitPoint < 0 && d > total / 2) {\n        splitPoint = i;\n      }\n      reverseSum[i] = total - d;\n    }\n    vbox = this;\n    doCut = function(d) {\n      var c2, d1, d2, dim1, dim2, left, right, vbox1, vbox2;\n      dim1 = d + \"1\";\n      dim2 = d + \"2\";\n      d1 = vbox[dim1];\n      d2 = vbox[dim2];\n      vbox1 = vbox.clone();\n      vbox2 = vbox.clone();\n      left = splitPoint - d1;\n      right = d2 - splitPoint;\n      if (left <= right) {\n        d2 = Math.min(d2 - 1, ~~(splitPoint + right / 2));\n        d2 = Math.max(0, d2);\n      } else {\n        d2 = Math.max(d1, ~~(splitPoint - 1 - left / 2));\n        d2 = Math.min(vbox[dim2], d2);\n      }\n      while (!accSum[d2]) {\n        d2++;\n      }\n      c2 = reverseSum[d2];\n      while (!c2 && accSum[d2 - 1]) {\n        c2 = reverseSum[--d2];\n      }\n      vbox1[dim2] = d2;\n      vbox2[dim1] = d2 + 1;\n      return [vbox1, vbox2];\n    };\n    return doCut(maxd);\n  };\n\n  VBox.prototype.contains = function(p) {\n    var b, g, r;\n    r = p[0] >> RSHIFT;\n    g = p[1] >> RSHIFT;\n    b = p[2] >> RSHIFT;\n    return r >= this.r1 && r <= this.r2 && g >= this.g1 && g <= this.g2 && b >= this.b1 && b <= this.b2;\n  };\n\n  return VBox;\n\n})();\n","var Quantizer;\n\nmodule.exports = Quantizer = (function() {\n  function Quantizer() {}\n\n  Quantizer.prototype.initialize = function(pixels, opts) {};\n\n  Quantizer.prototype.getQuantizedColors = function() {};\n\n  return Quantizer;\n\n})();\n\nmodule.exports.Baseline = require('./baseline');\n\nmodule.exports.NoCopy = require('./nocopy');\n\nmodule.exports.ColorCut = require('./color-cut');\n\nmodule.exports.MMCQ = require('./mmcq');\n","var MMCQ, MMCQImpl, Quantizer, Swatch,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nMMCQImpl = require('./impl/mmcq');\n\nmodule.exports = MMCQ = (function(superClass) {\n  extend(MMCQ, superClass);\n\n  function MMCQ() {\n    return MMCQ.__super__.constructor.apply(this, arguments);\n  }\n\n  MMCQ.prototype.initialize = function(pixels, opts) {\n    var mmcq;\n    this.opts = opts;\n    mmcq = new MMCQImpl();\n    return this.swatches = mmcq.quantize(pixels, this.opts);\n  };\n\n  MMCQ.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return MMCQ;\n\n})(Quantizer);\n","var NoCopyQuantizer, Quantizer, Swatch, quantize,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nquantize = require('../../vendor-mod/quantize');\n\nmodule.exports = NoCopyQuantizer = (function(superClass) {\n  extend(NoCopyQuantizer, superClass);\n\n  function NoCopyQuantizer() {\n    return NoCopyQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  NoCopyQuantizer.prototype.initialize = function(pixels, opts) {\n    var cmap;\n    this.opts = opts;\n    cmap = quantize(pixels, this.opts);\n    return this.swatches = cmap.vboxes.map((function(_this) {\n      return function(vbox) {\n        return new Swatch(vbox.color, vbox.vbox.count());\n      };\n    })(this));\n  };\n\n  NoCopyQuantizer.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return NoCopyQuantizer;\n\n})(Quantizer);\n","var Swatch, util;\n\nutil = require('./util');\n\n\n/*\n  From Vibrant.js by Jari Zwarts\n  Ported to node.js by AKFish\n\n  Swatch class\n */\n\nmodule.exports = Swatch = (function() {\n  Swatch.prototype.hsl = void 0;\n\n  Swatch.prototype.rgb = void 0;\n\n  Swatch.prototype.population = 1;\n\n  Swatch.prototype.yiq = 0;\n\n  function Swatch(rgb, population) {\n    this.rgb = rgb;\n    this.population = population;\n  }\n\n  Swatch.prototype.getHsl = function() {\n    if (!this.hsl) {\n      return this.hsl = util.rgbToHsl(this.rgb[0], this.rgb[1], this.rgb[2]);\n    } else {\n      return this.hsl;\n    }\n  };\n\n  Swatch.prototype.getPopulation = function() {\n    return this.population;\n  };\n\n  Swatch.prototype.getRgb = function() {\n    return this.rgb;\n  };\n\n  Swatch.prototype.getHex = function() {\n    return util.rgbToHex(this.rgb[0], this.rgb[1], this.rgb[2]);\n  };\n\n  Swatch.prototype.getTitleTextColor = function() {\n    this._ensureTextColors();\n    if (this.yiq < 200) {\n      return \"#fff\";\n    } else {\n      return \"#000\";\n    }\n  };\n\n  Swatch.prototype.getBodyTextColor = function() {\n    this._ensureTextColors();\n    if (this.yiq < 150) {\n      return \"#fff\";\n    } else {\n      return \"#000\";\n    }\n  };\n\n  Swatch.prototype._ensureTextColors = function() {\n    if (!this.yiq) {\n      return this.yiq = (this.rgb[0] * 299 + this.rgb[1] * 587 + this.rgb[2] * 114) / 1000;\n    }\n  };\n\n  return Swatch;\n\n})();\n","var DELTAE94, RSHIFT, SIGBITS;\n\nDELTAE94 = {\n  NA: 0,\n  PERFECT: 1,\n  CLOSE: 2,\n  GOOD: 10,\n  SIMILAR: 50\n};\n\nSIGBITS = 5;\n\nRSHIFT = 8 - SIGBITS;\n\nmodule.exports = {\n  clone: function(o) {\n    var _o, key, value;\n    if (typeof o === 'object') {\n      if (Array.isArray(o)) {\n        return o.map((function(_this) {\n          return function(v) {\n            return _this.clone(v);\n          };\n        })(this));\n      } else {\n        _o = {};\n        for (key in o) {\n          value = o[key];\n          _o[key] = this.clone(value);\n        }\n        return _o;\n      }\n    }\n    return o;\n  },\n  defaults: function() {\n    var _o, i, key, len, o, value;\n    o = {};\n    for (i = 0, len = arguments.length; i < len; i++) {\n      _o = arguments[i];\n      for (key in _o) {\n        value = _o[key];\n        if (o[key] == null) {\n          o[key] = this.clone(value);\n        }\n      }\n    }\n    return o;\n  },\n  hexToRgb: function(hex) {\n    var m;\n    m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (m != null) {\n      return [m[1], m[2], m[3]].map(function(s) {\n        return parseInt(s, 16);\n      });\n    }\n    return null;\n  },\n  rgbToHex: function(r, g, b) {\n    return \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);\n  },\n  rgbToHsl: function(r, g, b) {\n    var d, h, l, max, min, s;\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    h = void 0;\n    s = void 0;\n    l = (max + min) / 2;\n    if (max === min) {\n      h = s = 0;\n    } else {\n      d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0);\n          break;\n        case g:\n          h = (b - r) / d + 2;\n          break;\n        case b:\n          h = (r - g) / d + 4;\n      }\n      h /= 6;\n    }\n    return [h, s, l];\n  },\n  hslToRgb: function(h, s, l) {\n    var b, g, hue2rgb, p, q, r;\n    r = void 0;\n    g = void 0;\n    b = void 0;\n    hue2rgb = function(p, q, t) {\n      if (t < 0) {\n        t += 1;\n      }\n      if (t > 1) {\n        t -= 1;\n      }\n      if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n      }\n      if (t < 1 / 2) {\n        return q;\n      }\n      if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n      }\n      return p;\n    };\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      q = l < 0.5 ? l * (1 + s) : l + s - (l * s);\n      p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - (1 / 3));\n    }\n    return [r * 255, g * 255, b * 255];\n  },\n  rgbToXyz: function(r, g, b) {\n    var x, y, z;\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    r = r > 0.04045 ? Math.pow((r + 0.005) / 1.055, 2.4) : r / 12.92;\n    g = g > 0.04045 ? Math.pow((g + 0.005) / 1.055, 2.4) : g / 12.92;\n    b = b > 0.04045 ? Math.pow((b + 0.005) / 1.055, 2.4) : b / 12.92;\n    r *= 100;\n    g *= 100;\n    b *= 100;\n    x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n    y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n    z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n    return [x, y, z];\n  },\n  xyzToCIELab: function(x, y, z) {\n    var L, REF_X, REF_Y, REF_Z, a, b;\n    REF_X = 95.047;\n    REF_Y = 100;\n    REF_Z = 108.883;\n    x /= REF_X;\n    y /= REF_Y;\n    z /= REF_Z;\n    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n    L = 116 * y - 16;\n    a = 500 * (x - y);\n    b = 200 * (y - z);\n    return [L, a, b];\n  },\n  rgbToCIELab: function(r, g, b) {\n    var ref, x, y, z;\n    ref = this.rgbToXyz(r, g, b), x = ref[0], y = ref[1], z = ref[2];\n    return this.xyzToCIELab(x, y, z);\n  },\n  deltaE94: function(lab1, lab2) {\n    var L1, L2, WEIGHT_C, WEIGHT_H, WEIGHT_L, a1, a2, b1, b2, dL, da, db, xC1, xC2, xDC, xDE, xDH, xDL, xSC, xSH;\n    WEIGHT_L = 1;\n    WEIGHT_C = 1;\n    WEIGHT_H = 1;\n    L1 = lab1[0], a1 = lab1[1], b1 = lab1[2];\n    L2 = lab2[0], a2 = lab2[1], b2 = lab2[2];\n    dL = L1 - L2;\n    da = a1 - a2;\n    db = b1 - b2;\n    xC1 = Math.sqrt(a1 * a1 + b1 * b1);\n    xC2 = Math.sqrt(a2 * a2 + b2 * b2);\n    xDL = L2 - L1;\n    xDC = xC2 - xC1;\n    xDE = Math.sqrt(dL * dL + da * da + db * db);\n    if (Math.sqrt(xDE) > Math.sqrt(Math.abs(xDL)) + Math.sqrt(Math.abs(xDC))) {\n      xDH = Math.sqrt(xDE * xDE - xDL * xDL - xDC * xDC);\n    } else {\n      xDH = 0;\n    }\n    xSC = 1 + 0.045 * xC1;\n    xSH = 1 + 0.015 * xC1;\n    xDL /= WEIGHT_L;\n    xDC /= WEIGHT_C * xSC;\n    xDH /= WEIGHT_H * xSH;\n    return Math.sqrt(xDL * xDL + xDC * xDC + xDH * xDH);\n  },\n  rgbDiff: function(rgb1, rgb2) {\n    var lab1, lab2;\n    lab1 = this.rgbToCIELab.apply(this, rgb1);\n    lab2 = this.rgbToCIELab.apply(this, rgb2);\n    return this.deltaE94(lab1, lab2);\n  },\n  hexDiff: function(hex1, hex2) {\n    var rgb1, rgb2;\n    rgb1 = this.hexToRgb(hex1);\n    rgb2 = this.hexToRgb(hex2);\n    return this.rgbDiff(rgb1, rgb2);\n  },\n  DELTAE94_DIFF_STATUS: DELTAE94,\n  getColorDiffStatus: function(d) {\n    if (d < DELTAE94.NA) {\n      return \"N/A\";\n    }\n    if (d <= DELTAE94.PERFECT) {\n      return \"Perfect\";\n    }\n    if (d <= DELTAE94.CLOSE) {\n      return \"Close\";\n    }\n    if (d <= DELTAE94.GOOD) {\n      return \"Good\";\n    }\n    if (d < DELTAE94.SIMILAR) {\n      return \"Similar\";\n    }\n    return \"Wrong\";\n  },\n  SIGBITS: SIGBITS,\n  RSHIFT: RSHIFT,\n  getColorIndex: function(r, g, b) {\n    return (r << (2 * SIGBITS)) + (g << SIGBITS) + b;\n  }\n};\n","\n/*\n  From Vibrant.js by Jari Zwarts\n  Ported to node.js by AKFish\n\n  Color algorithm class that finds variations on colors in an image.\n\n  Credits\n  --------\n  Lokesh Dhakar (http://www.lokeshdhakar.com) - Created ColorThief\n  Google - Palette support library in Android\n */\nvar Builder, DefaultGenerator, Filter, Swatch, Vibrant, util,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nSwatch = require('./swatch');\n\nutil = require('./util');\n\nDefaultGenerator = require('./generator').Default;\n\nFilter = require('./filter');\n\nmodule.exports = Vibrant = (function() {\n  Vibrant.DefaultOpts = {\n    colorCount: 64,\n    quality: 5,\n    generator: new DefaultGenerator(),\n    Image: null,\n    Quantizer: require('./quantizer').MMCQ,\n    filters: []\n  };\n\n  Vibrant.from = function(src) {\n    return new Builder(src);\n  };\n\n  Vibrant.prototype.quantize = require('quantize');\n\n  Vibrant.prototype._swatches = [];\n\n  function Vibrant(sourceImage, opts) {\n    this.sourceImage = sourceImage;\n    if (opts == null) {\n      opts = {};\n    }\n    this.swatches = bind(this.swatches, this);\n    this.opts = util.defaults(opts, this.constructor.DefaultOpts);\n    this.generator = this.opts.generator;\n  }\n\n  Vibrant.prototype.getPalette = function(cb) {\n    var image;\n    return image = new this.opts.Image(this.sourceImage, (function(_this) {\n      return function(err, image) {\n        var error;\n        if (err != null) {\n          return cb(err);\n        }\n        try {\n          _this._process(image, _this.opts);\n          return cb(null, _this.swatches());\n        } catch (_error) {\n          error = _error;\n          return cb(error);\n        }\n      };\n    })(this));\n  };\n\n  Vibrant.prototype.getSwatches = function(cb) {\n    return this.getPalette(cb);\n  };\n\n  Vibrant.prototype._process = function(image, opts) {\n    var imageData, quantizer, swatches;\n    image.scaleDown(this.opts);\n    imageData = image.getImageData();\n    quantizer = new this.opts.Quantizer();\n    quantizer.initialize(imageData.data, this.opts);\n    swatches = quantizer.getQuantizedColors();\n    this.generator.generate(swatches);\n    return image.removeCanvas();\n  };\n\n  Vibrant.prototype.swatches = function() {\n    return {\n      Vibrant: this.generator.getVibrantSwatch(),\n      Muted: this.generator.getMutedSwatch(),\n      DarkVibrant: this.generator.getDarkVibrantSwatch(),\n      DarkMuted: this.generator.getDarkMutedSwatch(),\n      LightVibrant: this.generator.getLightVibrantSwatch(),\n      LightMuted: this.generator.getLightMutedSwatch()\n    };\n  };\n\n  return Vibrant;\n\n})();\n\nmodule.exports.Builder = Builder = (function() {\n  function Builder(src1, opts1) {\n    this.src = src1;\n    this.opts = opts1 != null ? opts1 : {};\n    this.opts.filters = util.clone(Vibrant.DefaultOpts.filters);\n  }\n\n  Builder.prototype.maxColorCount = function(n) {\n    this.opts.colorCount = n;\n    return this;\n  };\n\n  Builder.prototype.maxDimension = function(d) {\n    this.opts.maxDimension = d;\n    return this;\n  };\n\n  Builder.prototype.addFilter = function(f) {\n    if (typeof f === 'function') {\n      this.opts.filters.push(f);\n    }\n    return this;\n  };\n\n  Builder.prototype.removeFilter = function(f) {\n    var i;\n    if ((i = this.opts.filters.indexOf(f)) > 0) {\n      this.opts.filters.splice(i);\n    }\n    return this;\n  };\n\n  Builder.prototype.clearFilters = function() {\n    this.opts.filters = [];\n    return this;\n  };\n\n  Builder.prototype.quality = function(q) {\n    this.opts.quality = q;\n    return this;\n  };\n\n  Builder.prototype.useImage = function(image) {\n    this.opts.Image = image;\n    return this;\n  };\n\n  Builder.prototype.useGenerator = function(generator) {\n    this.opts.generator = generator;\n    return this;\n  };\n\n  Builder.prototype.useQuantizer = function(quantizer) {\n    this.opts.Quantizer = quantizer;\n    return this;\n  };\n\n  Builder.prototype.build = function() {\n    if (this.v == null) {\n      this.v = new Vibrant(this.src, this.opts);\n    }\n    return this.v;\n  };\n\n  Builder.prototype.getSwatches = function(cb) {\n    return this.build().getPalette(cb);\n  };\n\n  Builder.prototype.getPalette = function(cb) {\n    return this.build().getPalette(cb);\n  };\n\n  Builder.prototype.from = function(src) {\n    return new Vibrant(src, this.opts);\n  };\n\n  return Builder;\n\n})();\n\nmodule.exports.Util = util;\n\nmodule.exports.Swatch = Swatch;\n\nmodule.exports.Quantizer = require('./quantizer/');\n\nmodule.exports.Generator = require('./generator/');\n\nmodule.exports.Filter = require('./filter/');\n","/*\r\n * quantize.js Copyright 2008 Nick Rabinowitz\r\n * Ported to node.js by Olivier Lesnicki\r\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\r\n */\r\n\r\n// fill out a couple protovis dependencies\r\n/*\r\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\r\n * Copyright 2010 Stanford Visualization Group\r\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\r\n */\r\nif (!pv) {\r\n    var pv = {\r\n        map: function(array, f) {\r\n            var o = {};\r\n            return f ? array.map(function(d, i) {\r\n                o.index = i;\r\n                return f.call(o, d);\r\n            }) : array.slice();\r\n        },\r\n        naturalOrder: function(a, b) {\r\n            return a - b;\r\n        },\r\n        sum: function(array, f) {\r\n            var o = {};\r\n            return array.reduce(f ? function(p, d, i) {\r\n                o.index = i;\r\n                return p + f.call(o, d);\r\n            } : function(p, d) {\r\n                return p + d;\r\n            }, 0);\r\n        },\r\n        max: function(array, f) {\r\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Basic Javascript port of the MMCQ (modified median cut quantization)\r\n * algorithm from the Leptonica library (http://www.leptonica.com/).\r\n * Returns a color map you can use to map original pixels to the reduced\r\n * palette. Still a work in progress.\r\n *\r\n * @author Nick Rabinowitz\r\n * @example\r\n\r\n// array of pixels as [R,G,B] arrays\r\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\r\n                // etc\r\n                ];\r\nvar maxColors = 4;\r\n\r\nvar cmap = MMCQ.quantize(myPixels, maxColors);\r\nvar newPalette = cmap.palette();\r\nvar newPixels = myPixels.map(function(p) {\r\n    return cmap.map(p);\r\n});\r\n\r\n */\r\nvar MMCQ = (function() {\r\n    // private constants\r\n    var sigbits = 5,\r\n        rshift = 8 - sigbits,\r\n        maxIterations = 1000,\r\n        fractByPopulations = 0.75;\r\n\r\n    // get reduced-space color index for a pixel\r\n\r\n    function getColorIndex(r, g, b) {\r\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\r\n    }\r\n\r\n    // Simple priority queue\r\n\r\n    function PQueue(comparator) {\r\n        var contents = [],\r\n            sorted = false;\r\n\r\n        function sort() {\r\n            contents.sort(comparator);\r\n            sorted = true;\r\n        }\r\n\r\n        return {\r\n            push: function(o) {\r\n                contents.push(o);\r\n                sorted = false;\r\n            },\r\n            peek: function(index) {\r\n                if (!sorted) sort();\r\n                if (index === undefined) index = contents.length - 1;\r\n                return contents[index];\r\n            },\r\n            pop: function() {\r\n                if (!sorted) sort();\r\n                return contents.pop();\r\n            },\r\n            size: function() {\r\n                return contents.length;\r\n            },\r\n            map: function(f) {\r\n                return contents.map(f);\r\n            },\r\n            debug: function() {\r\n                if (!sorted) sort();\r\n                return contents;\r\n            }\r\n        };\r\n    }\r\n\r\n    // 3d color space box\r\n\r\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\r\n        var vbox = this;\r\n        vbox.r1 = r1;\r\n        vbox.r2 = r2;\r\n        vbox.g1 = g1;\r\n        vbox.g2 = g2;\r\n        vbox.b1 = b1;\r\n        vbox.b2 = b2;\r\n        vbox.histo = histo;\r\n    }\r\n    VBox.prototype = {\r\n        volume: function(force) {\r\n            var vbox = this;\r\n            if (!vbox._volume || force) {\r\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\r\n            }\r\n            return vbox._volume;\r\n        },\r\n        count: function(force) {\r\n            var vbox = this,\r\n                histo = vbox.histo;\r\n            if (!vbox._count_set || force) {\r\n                var npix = 0,\r\n                    i, j, k;\r\n                for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                            index = getColorIndex(i, j, k);\r\n                            npix += histo[index];\r\n                        }\r\n                    }\r\n                }\r\n                vbox._count = npix;\r\n                vbox._count_set = true;\r\n            }\r\n            return vbox._count;\r\n        },\r\n        copy: function() {\r\n            var vbox = this;\r\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\r\n        },\r\n        avg: function(force) {\r\n            var vbox = this,\r\n                histo = vbox.histo;\r\n            if (!vbox._avg || force) {\r\n                var ntot = 0,\r\n                    mult = 1 << (8 - sigbits),\r\n                    // mult = (8 - sigbits),\r\n                    rsum = 0,\r\n                    gsum = 0,\r\n                    bsum = 0,\r\n                    hval,\r\n                    i, j, k, histoindex;\r\n                for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                            histoindex = getColorIndex(i, j, k);\r\n                            hval = histo[histoindex];\r\n                            ntot += hval;\r\n                            rsum += (hval * (i + 0.5) * mult);\r\n                            gsum += (hval * (j + 0.5) * mult);\r\n                            bsum += (hval * (k + 0.5) * mult);\r\n                        }\r\n                    }\r\n                }\r\n                if (ntot) {\r\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\r\n                } else {\r\n                    //console.log('empty box');\r\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\r\n                }\r\n            }\r\n            return vbox._avg;\r\n        },\r\n        contains: function(pixel) {\r\n            var vbox = this,\r\n                rval = pixel[0] >> rshift;\r\n            gval = pixel[1] >> rshift;\r\n            bval = pixel[2] >> rshift;\r\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\r\n                gval >= vbox.g1 && gval <= vbox.g2 &&\r\n                bval >= vbox.b1 && bval <= vbox.b2);\r\n        }\r\n    };\r\n\r\n    // Color map\r\n\r\n    function CMap() {\r\n        this.vboxes = new PQueue(function(a, b) {\r\n            return pv.naturalOrder(\r\n                a.vbox.count() * a.vbox.volume(),\r\n                b.vbox.count() * b.vbox.volume()\r\n            )\r\n        });;\r\n    }\r\n    CMap.prototype = {\r\n        push: function(vbox) {\r\n            this.vboxes.push({\r\n                vbox: vbox,\r\n                color: vbox.avg()\r\n            });\r\n        },\r\n        palette: function() {\r\n            return this.vboxes.map(function(vb) {\r\n                return vb.color\r\n            });\r\n        },\r\n        size: function() {\r\n            return this.vboxes.size();\r\n        },\r\n        map: function(color) {\r\n            var vboxes = this.vboxes;\r\n            for (var i = 0; i < vboxes.size(); i++) {\r\n                if (vboxes.peek(i).vbox.contains(color)) {\r\n                    return vboxes.peek(i).color;\r\n                }\r\n            }\r\n            return this.nearest(color);\r\n        },\r\n        nearest: function(color) {\r\n            var vboxes = this.vboxes,\r\n                d1, d2, pColor;\r\n            for (var i = 0; i < vboxes.size(); i++) {\r\n                d2 = Math.sqrt(\r\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\r\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\r\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\r\n                );\r\n                if (d2 < d1 || d1 === undefined) {\r\n                    d1 = d2;\r\n                    pColor = vboxes.peek(i).color;\r\n                }\r\n            }\r\n            return pColor;\r\n        },\r\n        forcebw: function() {\r\n            // XXX: won't  work yet\r\n            var vboxes = this.vboxes;\r\n            vboxes.sort(function(a, b) {\r\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\r\n            });\r\n\r\n            // force darkest color to black if everything < 5\r\n            var lowest = vboxes[0].color;\r\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\r\n                vboxes[0].color = [0, 0, 0];\r\n\r\n            // force lightest color to white if everything > 251\r\n            var idx = vboxes.length - 1,\r\n                highest = vboxes[idx].color;\r\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\r\n                vboxes[idx].color = [255, 255, 255];\r\n        }\r\n    };\r\n\r\n\r\n    function getAll(pixels, shouldIgnore) {\r\n        var histosize = 1 << (3 * sigbits),\r\n            histo = new Uint32Array(histosize),\r\n            index, rval, gval, bval;\r\n        var rmin = 1000000,\r\n            rmax = 0,\r\n            gmin = 1000000,\r\n            gmax = 0,\r\n            bmin = 1000000,\r\n            bmax = 0;\r\n\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        } else {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        }\r\n\r\n        return {\r\n          histo: histo,\r\n          vbox: new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo)\r\n        };\r\n    }\r\n\r\n    // histo (1-d array, giving the number of pixels in\r\n    // each quantized region of color space), or null on error\r\n\r\n    function getHisto(pixels, shouldIgnore) {\r\n        var histosize = 1 << (3 * sigbits),\r\n            histo = new Uint32Array(histosize),\r\n            index, rval, gval, bval;\r\n\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n          }\r\n        } else {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n          }\r\n        }\r\n\r\n        return histo;\r\n    }\r\n\r\n    function vboxFromPixels(pixels, histo, shouldIgnore) {\r\n        var rmin = 1000000,\r\n            rmax = 0,\r\n            gmin = 1000000,\r\n            gmax = 0,\r\n            bmin = 1000000,\r\n            bmax = 0,\r\n            rval, gval, bval;\r\n        // find min/max\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        } else {\r\n            while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        }\r\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\r\n    }\r\n\r\n    function medianCutApply(histo, vbox) {\r\n        if (!vbox.count()) return;\r\n\r\n        var rw = vbox.r2 - vbox.r1 + 1,\r\n            gw = vbox.g2 - vbox.g1 + 1,\r\n            bw = vbox.b2 - vbox.b1 + 1,\r\n            maxw = pv.max([rw, gw, bw]);\r\n        // only one pixel, no split\r\n        if (vbox.count() == 1) {\r\n            return [vbox.copy()]\r\n        }\r\n        /* Find the partial sum arrays along the selected axis. */\r\n        var total = 0,\r\n            partialsum,\r\n            lookaheadsum,\r\n            i, j, k, sum, index;\r\n        // var D = ['r', 'g', 'b'],\r\n        //   indexer = getColorIndex;\r\n        // if (maxw == gw) {\r\n        //   D = ['g', 'r', 'b'];\r\n        //   indexer = function(g, r, b) { return getColorIndex(r, g, b); };\r\n        // } else if (maxw == bw) {\r\n        //   indexer = function(b, r, g) { return getColorIndex(r, g, b); };\r\n        //   D = ['b', 'r', 'g'];\r\n        // }\r\n        // partialsum = new Uint32Array(vbox[D[0] + \"2\"] + 1);\r\n        // console.log(vbox[D[0] + \"2\"])\r\n        // for (i = vbox[D[0] + \"1\"]; i <= vbox[D[0] + \"2\"]; i++) {\r\n        //     sum = 0;\r\n        //     for (j = vbox[D[1] + \"1\"]; j <= vbox[D[1] + \"2\"]; j++) {\r\n        //         for (k = vbox[D[2] + \"1\"]; k <= vbox[D[2] + \"2\"]; k++) {\r\n        //             index = indexer(i, j, k);\r\n        //             sum += histo[index];\r\n        //         }\r\n        //     }\r\n        //     total += sum;\r\n        //     console.log(i + \"->\" + total)\r\n        //     partialsum[i] = total;\r\n        // }\r\n        var maxd = 'b';\r\n        if (maxw == rw) {\r\n            maxd = 'r';\r\n            partialsum = new Uint32Array(vbox.r2 + 1);\r\n            for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                        index = getColorIndex(i, j, k);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        } else if (maxw == gw) {\r\n            maxd = 'g';\r\n            partialsum = new Uint32Array(vbox.g2 + 1);\r\n            for (i = vbox.g1; i <= vbox.g2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.r1; j <= vbox.r2; j++) {\r\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                        index = getColorIndex(j, i, k);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        } else { /* maxw == bw */\r\n            // maxd = 'b';\r\n            partialsum = new Uint32Array(vbox.b2 + 1);\r\n            for (i = vbox.b1; i <= vbox.b2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.r1; j <= vbox.r2; j++) {\r\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\r\n                        index = getColorIndex(j, k, i);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        }\r\n        var splitPoint = -1;\r\n        lookaheadsum = new Uint32Array(partialsum.length);\r\n        for (i = 0; i < partialsum.length; i++) {\r\n          var d = partialsum[i];\r\n          if (splitPoint < 0 && d > (total / 2)) splitPoint = i;\r\n          lookaheadsum[i] = total - d\r\n        }\r\n        // partialsum.forEach(function(d, i) {\r\n        //   if (splitPoint < 0 && d > (total / 2)) splitPoint = i\r\n        //     lookaheadsum[i] = total - d\r\n        // });\r\n\r\n        // console.log('cut')\r\n        function doCut(color) {\r\n            var dim1 = color + '1',\r\n                dim2 = color + '2',\r\n                left, right, vbox1, vbox2, d2, count2 = 0,\r\n                i = splitPoint;\r\n            vbox1 = vbox.copy();\r\n            vbox2 = vbox.copy();\r\n            left = i - vbox[dim1];\r\n            right = vbox[dim2] - i;\r\n            if (left <= right) {\r\n                d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\r\n                d2 = Math.max(0, d2);\r\n            } else {\r\n                d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\r\n                d2 = Math.min(vbox[dim2], d2);\r\n            }\r\n            // console.log(partialsum[d2])\r\n            // avoid 0-count boxes\r\n            while (!partialsum[d2]) d2++;\r\n            count2 = lookaheadsum[d2];\r\n            // console.log('-_-')\r\n            while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\r\n            // set dimensions\r\n            vbox1[dim2] = d2;\r\n            vbox2[dim1] = vbox1[dim2] + 1;\r\n            // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\r\n            return [vbox1, vbox2];\r\n\r\n        }\r\n        // determine the cut planes\r\n        return doCut(maxd);\r\n        // return maxw == rw ? doCut('r') :\r\n        //     maxw == gw ? doCut('g') :\r\n        //     doCut('b');\r\n    }\r\n\r\n    function quantize(pixels, opts) {\r\n        var maxcolors = opts.colorCount;\r\n        // short-circuit\r\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\r\n            // console.log('wrong number of maxcolors');\r\n            return false;\r\n        }\r\n\r\n        var hasFilters = Array.isArray(opts.filters) && opts.filters.length > 0;\r\n        function shouldIgnore(r, g, b, a) {\r\n          for (var i = 0; i < opts.filters.length; i++) {\r\n            var f = opts.filters[i];\r\n            if (!f(r, g, b, a)) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        }\r\n\r\n        var r = getAll(pixels, hasFilters ? houldIgnore : null);\r\n        // XXX: check color content and convert to grayscale if insufficient\r\n\r\n        // var histo = getHisto(pixels, hasFilters ? shouldIgnore : null),\r\n        var histo = r.histo,\r\n            histosize = 1 << (3 * sigbits);\r\n\r\n        // check that we aren't below maxcolors already\r\n        var nColors = Object.keys(histo).length;\r\n        if (nColors <= maxcolors) {\r\n            // XXX: generate the new colors from the histo and return\r\n        }\r\n\r\n        // get the beginning vbox from the colors\r\n        // var vbox = vboxFromPixels(pixels, histo, hasFilters ? shouldIgnore : null),\r\n        var vbox = r.vbox,\r\n            pq = new PQueue(function(a, b) {\r\n                return pv.naturalOrder(a.count(), b.count())\r\n            });\r\n        pq.push(vbox);\r\n\r\n        // inner function to do the iteration\r\n\r\n        function iter(lh, target) {\r\n            var ncolors = 1,\r\n                niters = 0,\r\n                vbox;\r\n            while (niters < maxIterations) {\r\n                vbox = lh.pop();\r\n                if (!vbox.count()) { /* just put it back */\r\n                    // lh.push(vbox); // Maybe not\r\n                    niters++;\r\n                    continue;\r\n                }\r\n                // do the cut\r\n                var vboxes = medianCutApply(histo, vbox),\r\n                    vbox1 = vboxes[0],\r\n                    vbox2 = vboxes[1];\r\n\r\n                if (!vbox1) {\r\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\r\n                    return;\r\n                }\r\n                lh.push(vbox1);\r\n                if (vbox2) { /* vbox2 can be null */\r\n                    lh.push(vbox2);\r\n                    ncolors++;\r\n                }\r\n                if (ncolors >= target) return;\r\n                if (niters++ > maxIterations) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // first set of colors, sorted by population\r\n        iter(pq, fractByPopulations * maxcolors);\r\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\r\n\r\n        // Re-sort by the product of pixel occupancy times the size in color space.\r\n        var pq2 = new PQueue(function(a, b) {\r\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\r\n        });\r\n        while (pq.size()) {\r\n            pq2.push(pq.pop());\r\n        }\r\n\r\n        // next set - generate the median cuts using the (npix * vol) sorting.\r\n        iter(pq2, maxcolors - pq2.size());\r\n\r\n        // calculate the actual colors\r\n        var cmap = new CMap();\r\n        while (pq2.size()) {\r\n            var v = pq2.pop(),\r\n              c = vbox.avg();\r\n            if (!hasFilters || !shouldIgnore(c[0], c[1], c[2], 255)) {\r\n              cmap.push(v);\r\n            }\r\n        }\r\n\r\n        return cmap;\r\n    }\r\n\r\n    return {\r\n        quantize: quantize,\r\n        getAll: getAll,\r\n        medianCutApply: medianCutApply\r\n    }\r\n})();\r\n\r\nmodule.exports = MMCQ.quantize\r\nmodule.exports.getAll = MMCQ.getAll\r\nmodule.exports.splitBox = MMCQ.medianCutApply\r\n","  /* globals require, module */\n\n  'use strict';\n\n  /**\n   * Module dependencies.\n   */\n\n  var pathtoRegexp = require('path-to-regexp');\n\n  /**\n   * Module exports.\n   */\n\n  module.exports = page;\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var location = ('undefined' !== typeof window) && (window.history.location || window.location);\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n\n  /**\n   * Decode URL components (query string, pathname, hash).\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\n   */\n  var decodeURLComponents = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * HashBang option\n   */\n\n  var hashbang = false;\n\n  /**\n   * Previous context, for capturing\n   * page exit events.\n   */\n\n  var prevContext;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {String|Function} path\n   * @param {Function} fn...\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(path);\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n  page.exits = [];\n\n  /**\n   * Current path being processed\n   * @type {String}\n   */\n  page.current = '';\n\n  /**\n   * Number of pages navigated to.\n   * @type {number}\n   *\n   *     page.len == 0;\n   *     page('/login');\n   *     page.len == 1;\n   */\n\n  page.len = 0;\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {String} path\n   * @api public\n   */\n\n  page.base = function(path) {\n    if (0 === arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options) {\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click) {\n      document.addEventListener(clickEvent, onclick, false);\n    }\n    if (true === options.hashbang) hashbang = true;\n    if (!dispatch) return;\n    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function() {\n    if (!running) return;\n    page.current = '';\n    page.len = 0;\n    running = false;\n    document.removeEventListener(clickEvent, onclick, false);\n    window.removeEventListener('popstate', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @param {Boolean} dispatch\n   * @return {Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    if (false !== dispatch) page.dispatch(ctx);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {String} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object} [state]\n   * @api public\n   */\n\n  page.back = function(path, state) {\n    if (page.len > 0) {\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      history.back();\n      page.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    }else{\n      setTimeout(function() {\n        page.show(base, state);\n      });\n    }\n  };\n\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {String} from - if param 'to' is undefined redirects to 'from'\n   * @param {String} [to]\n   * @api public\n   */\n  page.redirect = function(from, to) {\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page(from, function(e) {\n        setTimeout(function() {\n          page.replace(to);\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        page.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @return {Context}\n   * @api public\n   */\n\n\n  page.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) page.dispatch(ctx);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Object} ctx\n   * @api private\n   */\n\n  page.dispatch = function(ctx) {\n    var prev = prevContext,\n      i = 0,\n      j = 0;\n\n    prevContext = ctx;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled(ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n\n    if (hashbang) {\n      current = base + location.hash.replace('#!', '');\n    } else {\n      current = location.pathname + location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    location.href = ctx.canonicalPath;\n  }\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  page.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return page.exit('*', path);\n    }\n\n    var route = new Route(path);\n    for (var i = 1; i < arguments.length; ++i) {\n      page.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {str} URL component to decode\n   */\n  function decodeURLEncodedURIComponent(val) {\n    if (typeof val !== 'string') { return val; }\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = parts[0];\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    page.len++;\n    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @param {String} path\n   * @param {Object} options.\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(this.path,\n      this.keys = [],\n      options.sensitive,\n      options.strict);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {String} path\n   * @param {Object} params\n   * @return {Boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  var onpopstate = (function () {\n    var loaded = false;\n    if ('undefined' === typeof window) {\n      return;\n    }\n    if (document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else {\n        page.show(location.pathname + location.hash, undefined, undefined, false);\n      }\n    };\n  })();\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n\n    if (1 !== which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n\n\n    // ensure link\n    var el = e.target;\n    while (el && 'A' !== el.nodeName) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName) return;\n\n\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;\n\n\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    if (el.target) return;\n\n    // x-origin\n    if (!sameOrigin(el.href)) return;\n\n\n\n    // rebuild path\n    var path = el.pathname + el.search + (el.hash || '');\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n\n    if (path.indexOf(base) === 0) {\n      path = path.substr(base.length);\n    }\n\n    if (hashbang) path = path.replace('#!', '');\n\n    if (base && orig === path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null === e.which ? e.button : e.which;\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return (href && (0 === href.indexOf(origin)));\n  }\n\n  page.sameOrigin = sameOrigin;\n","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n\n// fill out a couple protovis dependencies\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nif (!pv) {\n    var pv = {\n        map: function(array, f) {\n            var o = {};\n            return f ? array.map(function(d, i) {\n                o.index = i;\n                return f.call(o, d);\n            }) : array.slice();\n        },\n        naturalOrder: function(a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function(array, f) {\n            var o = {};\n            return array.reduce(f ? function(p, d, i) {\n                o.index = i;\n                return p + f.call(o, d);\n            } : function(p, d) {\n                return p + d;\n            }, 0);\n        },\n        max: function(array, f) {\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    }\n}\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\nvar MMCQ = (function() {\n    // private constants\n    var sigbits = 5,\n        rshift = 8 - sigbits,\n        maxIterations = 1000,\n        fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n\n    function PQueue(comparator) {\n        var contents = [],\n            sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function(o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function(index) {\n                if (!sorted) sort();\n                if (index === undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function() {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function() {\n                return contents.length;\n            },\n            map: function(f) {\n                return contents.map(f);\n            },\n            debug: function() {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function(force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0,\n                    i, j, k;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            index = getColorIndex(i, j, k);\n                            npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function() {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0,\n                    mult = 1 << (8 - sigbits),\n                    rsum = 0,\n                    gsum = 0,\n                    bsum = 0,\n                    hval,\n                    i, j, k, histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            histoindex = getColorIndex(i, j, k);\n                            hval = histo[histoindex] || 0;\n                            ntot += hval;\n                            rsum += (hval * (i + 0.5) * mult);\n                            gsum += (hval * (j + 0.5) * mult);\n                            bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\n                } else {\n                    //console.log('empty box');\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function(pixel) {\n            var vbox = this,\n                rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                gval >= vbox.g1 && gval <= vbox.g2 &&\n                bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n\n    function CMap() {\n        this.vboxes = new PQueue(function(a, b) {\n            return pv.naturalOrder(\n                a.vbox.count() * a.vbox.volume(),\n                b.vbox.count() * b.vbox.volume()\n            )\n        });;\n    }\n    CMap.prototype = {\n        push: function(vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function() {\n            return this.vboxes.map(function(vb) {\n                return vb.color\n            });\n        },\n        size: function() {\n            return this.vboxes.size();\n        },\n        map: function(color) {\n            var vboxes = this.vboxes;\n            for (var i = 0; i < vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function(color) {\n            var vboxes = this.vboxes,\n                d1, d2, pColor;\n            for (var i = 0; i < vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function() {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function(a, b) {\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\n            });\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0, 0, 0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length - 1,\n                highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255, 255, 255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits),\n            histo = new Array(histosize),\n            index, rval, gval, bval;\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin = 1000000,\n            rmax = 0,\n            gmin = 1000000,\n            gmax = 0,\n            bmin = 1000000,\n            bmax = 0,\n            rval, gval, bval;\n        // find min/max\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax) bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1,\n            gw = vbox.g2 - vbox.g1 + 1,\n            bw = vbox.b2 - vbox.b1 + 1,\n            maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()]\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0,\n            partialsum = [],\n            lookaheadsum = [],\n            i, j, k, sum, index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i, j, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j, i, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else { /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j, k, i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function(d, i) {\n            lookaheadsum[i] = total - d\n        });\n\n        function doCut(color) {\n            var dim1 = color + '1',\n                dim2 = color + '2',\n                left, right, vbox1, vbox2, d2, count2 = 0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n                    // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n            doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n            // console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels),\n            histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function() {\n            nColors++\n        });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo),\n            pq = new PQueue(function(a, b) {\n                return pv.naturalOrder(a.count(), b.count())\n            });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n\n        function iter(lh, target) {\n            var ncolors = 1,\n                niters = 0,\n                vbox;\n            while (niters < maxIterations) {\n                vbox = lh.pop();\n                if (!vbox.count()) { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox),\n                    vbox1 = vboxes[0],\n                    vbox2 = vboxes[1];\n\n                if (!vbox1) {\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) { /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n                    // console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function(a, b) {\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors - pq2.size());\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    }\n})();\n\nmodule.exports = MMCQ.quantize\n","(function() {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this._initBody(bodyInit)\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      xhr.onload = function() {\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})();\n","import page from 'page';\nimport fetch from 'whatwg-fetch';\nimport Tabs from './js/tabs.js';\nimport Vibrant from 'node-vibrant';\nimport FigureBg from './js/figure-bg.js';\nimport imgFill from './js/vendor/imgfill.js';\n// import particlesJS from 'particles.js';\n\n\n\nfunction ToggleNav() {\n\tconst navToggle = document.querySelector('.js-navToggle');\n\tconst MobileNav = document.querySelector('.MobileNav');\n\tconst navToggleClose = document.querySelector('.js-navToggleClose');\n\t\n\tnavToggle.addEventListener('click', function(evt) {\n\t\tevt.preventDefault();\n\t\tMobileNav.classList.add('is-active');\n\t}, false);\n\n\tnavToggleClose.addEventListener('click', function(evt) {\n\t\tevt.preventDefault();\n\t\tMobileNav.classList.remove('is-active');\n\t}, false);\n}\n\n\n// Call Function\n\nToggleNav();\nFigureBg();\n\nimgFill('.imgFill', '.imgFillSrc');\n\n\n\n\n// Vanilla\ndocument.addEventListener('DOMContentLoaded', function() {\n\tparticlesJS.load('particles-js', '../asset/js/particlesjs-config1.json', function() {console.log('callback - particles.js config loaded');});\n})","import Vibrant from 'node-vibrant';\n\nconst FigureBg = () => {\n  const Figures = Array.from(document.querySelectorAll('.Figure--slideDown'));\n  for (let Figure of Figures) {\n    const imgSrc = Figure.querySelector('img').getAttribute('src');\n    const FigCaption = Figure.querySelector('figcaption');\n\n    const bgColor = new Vibrant(imgSrc);\n    bgColor.getPalette(( err, palette ) => {\n      if (err) {\n        FigCaption.style.backgroundColor('#ffffff');\n      } else {\n        const hexColor = palette.Vibrant.rgb.join();\n        const bodyColor = palette.Vibrant.getTitleTextColor();\n        FigCaption.style.backgroundColor = 'rgba(' + hexColor + ', 1)';\n        FigCaption.style.color = bodyColor;\n      }\n    });\n  }\n};\n\nexport default FigureBg;\n","\nconst childHidden = (el) => {\n  const elHidden = document.querySelectorAll(el);\n  for (let i = 0; i < elHidden.length; i++) {\n    elHidden[i].style.display = 'none';\n  }\n};\n\n\nconst Tabs = () => {\n  const Tab = document.querySelector('.Tab');\n  const TabAchor = Tab.querySelector('.TabAchor');\n  const TabContent = Tab.querySelector('.TabContent');\n\n\n}\n\nexport default Tabs;\n","'use strict';\n\n// usage:\n// imgFill(target, imgSrc)\n// require es6\n\n\n\nconst setCSS = (element) => {\n  let CSS = {\n    backgroundSize: \"cover\",\n    backgroundPosition: \"center\",\n    backgroundRepeat: \"no-repeat\"\n  };\n  // create multiple CSS Property\n  for (let i in CSS) {\n    element.style[i] = CSS[i];\n  }\n};\n\nconst imgFill = (target, srcClass) => {\n  let imgConts = Array.from(document.querySelectorAll(target));\n  for (let img of imgConts) {\n\n    // define image source class\n    let imgSrc = img.querySelector(srcClass);\n\n    // Get image source url\n    let imgSrcURL = imgSrc.getAttribute('src');\n\n    // hide source images\n    imgSrc.style.display = 'none';\n    // Set Multiple CSS Property\n    img.style.backgroundImage = 'url(' + imgSrcURL + ')';\n    setCSS(img);\n  }\n};\n\nexport default imgFill;"],"sourceRoot":"/source/"}