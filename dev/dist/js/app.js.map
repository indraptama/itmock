{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/isarray/index.js","node_modules/node-vibrant/lib/browser.js","node_modules/node-vibrant/lib/filter/default.js","node_modules/node-vibrant/lib/filter/index.js","node_modules/node-vibrant/lib/generator/default.js","node_modules/node-vibrant/lib/generator/index.js","node_modules/node-vibrant/lib/image/browser.js","node_modules/node-vibrant/lib/image/index.js","node_modules/node-vibrant/lib/quantizer/baseline.js","node_modules/node-vibrant/lib/quantizer/color-cut.js","node_modules/node-vibrant/lib/quantizer/impl/color-cut.js","node_modules/node-vibrant/lib/quantizer/impl/mmcq.js","node_modules/node-vibrant/lib/quantizer/impl/pqueue.js","node_modules/node-vibrant/lib/quantizer/impl/vbox.js","node_modules/node-vibrant/lib/quantizer/index.js","node_modules/node-vibrant/lib/quantizer/mmcq.js","node_modules/node-vibrant/lib/quantizer/nocopy.js","node_modules/node-vibrant/lib/swatch.js","node_modules/node-vibrant/lib/util.js","node_modules/node-vibrant/lib/vibrant.js","node_modules/node-vibrant/vendor-mod/quantize.js","node_modules/page/index.js","node_modules/path-to-regexp/index.js","node_modules/process/browser.js","node_modules/punycode/punycode.js","node_modules/quantize/quantize.js","node_modules/querystring-es3/decode.js","node_modules/querystring-es3/encode.js","node_modules/querystring-es3/index.js","node_modules/url/url.js","node_modules/url/util.js","node_modules/whatwg-fetch/fetch.js","src/index.js","src/js/figure-bg.js","src/js/tabs.js","src/js/vendor/imgfill.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3XA,SAAS,SAAT,GAAqB;AACpB,KAAM,YAAY,SAAS,aAAT,CAAuB,eAAvB,CAAZ,CADc;AAEpB,KAAM,YAAY,SAAS,aAAT,CAAuB,YAAvB,CAAZ,CAFc;AAGpB,KAAM,iBAAiB,SAAS,aAAT,CAAuB,oBAAvB,CAAjB,CAHc;;AAKpB,WAAU,gBAAV,CAA2B,OAA3B,EAAoC,UAAS,GAAT,EAAc;AACjD,MAAI,cAAJ,GADiD;AAEjD,YAAU,SAAV,CAAoB,GAApB,CAAwB,WAAxB,EAFiD;EAAd,EAGjC,KAHH,EALoB;;AAUpB,gBAAe,gBAAf,CAAgC,OAAhC,EAAyC,UAAS,GAAT,EAAc;AACtD,MAAI,cAAJ,GADsD;AAEtD,YAAU,SAAV,CAAoB,MAApB,CAA2B,WAA3B,EAFsD;EAAd,EAGtC,KAHH,EAVoB;CAArB;;;;AAmBA;AACA;;AAEA,uBAAQ,UAAR,EAAoB,aAApB;;;;;;;;;;;;;;;;;;;;AC9BA,IAAM,WAAW,SAAX,QAAW,GAAM;AACrB,MAAM,UAAU,MAAM,IAAN,CAAW,SAAS,gBAAT,CAA0B,oBAA1B,CAAX,CAAV,CADe;;;;;;;UAEZ;;AACP,UAAM,SAAS,OAAO,aAAP,CAAqB,KAArB,EAA4B,YAA5B,CAAyC,KAAzC,CAAT;AACN,UAAM,aAAa,OAAO,aAAP,CAAqB,YAArB,CAAb;;AAEN,UAAM,UAAU,0BAAY,MAAZ,CAAV;AACN,cAAQ,UAAR,CAAmB,UAAE,GAAF,EAAO,OAAP,EAAoB;AACrC,YAAI,GAAJ,EAAS;AACP,qBAAW,KAAX,CAAiB,eAAjB,CAAiC,SAAjC,EADO;SAAT,MAEO;AACL,cAAM,WAAW,QAAQ,OAAR,CAAgB,GAAhB,CAAoB,IAApB,EAAX,CADD;AAEL,cAAM,YAAY,QAAQ,OAAR,CAAgB,iBAAhB,EAAZ,CAFD;AAGL,qBAAW,KAAX,CAAiB,eAAjB,GAAmC,UAAU,QAAV,GAAqB,MAArB,CAH9B;AAIL,qBAAW,KAAX,CAAiB,KAAjB,GAAyB,SAAzB,CAJK;SAFP;OADiB,CAAnB;;;AALF,yBAAmB,iCAAnB,oGAA4B;;KAA5B;;;;;;;;;;;;;;GAFqB;CAAN;;kBAoBF;;;;;;;;;ACrBf,IAAM,cAAc,SAAd,WAAc,CAAC,EAAD,EAAQ;AAC1B,MAAM,WAAW,SAAS,gBAAT,CAA0B,EAA1B,CAAX,CADoB;AAE1B,OAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,SAAS,MAAT,EAAiB,GAArC,EAA0C;AACxC,aAAS,CAAT,EAAY,KAAZ,CAAkB,OAAlB,GAA4B,MAA5B,CADwC;GAA1C;CAFkB;;AAQpB,IAAM,OAAO,SAAP,IAAO,GAAM;AACjB,MAAM,MAAM,SAAS,aAAT,CAAuB,MAAvB,CAAN,CADW;AAEjB,MAAM,WAAW,IAAI,aAAJ,CAAkB,WAAlB,CAAX,CAFW;AAGjB,MAAM,aAAa,IAAI,aAAJ,CAAkB,aAAlB,CAAb,CAHW;CAAN;;kBAQE;;;ACjBf;;;;;;;;;AAQA,IAAM,SAAS,SAAT,MAAS,CAAC,OAAD,EAAa;AAC1B,MAAI,MAAM;AACR,oBAAgB,OAAhB;AACA,wBAAoB,QAApB;AACA,sBAAkB,WAAlB;GAHE;;AADsB,OAOrB,IAAI,CAAJ,IAAS,GAAd,EAAmB;AACjB,YAAQ,KAAR,CAAc,CAAd,IAAmB,IAAI,CAAJ,CAAnB,CADiB;GAAnB;CAPa;;AAYf,IAAM,UAAU,SAAV,OAAU,CAAC,MAAD,EAAS,QAAT,EAAsB;AACpC,MAAI,WAAW,MAAM,IAAN,CAAW,SAAS,gBAAT,CAA0B,MAA1B,CAAX,CAAX,CADgC;;;;;;AAEpC,yBAAgB,kCAAhB,oGAA0B;UAAjB,kBAAiB;;;AAGxB,UAAI,SAAS,IAAI,aAAJ,CAAkB,QAAlB,CAAT;;;AAHoB,UAMpB,YAAY,OAAO,YAAP,CAAoB,KAApB,CAAZ;;;AANoB,YASxB,CAAO,KAAP,CAAa,OAAb,GAAuB,MAAvB;;AATwB,SAWxB,CAAI,KAAJ,CAAU,eAAV,GAA4B,SAAS,SAAT,GAAqB,GAArB,CAXJ;AAYxB,aAAO,GAAP,EAZwB;KAA1B;;;;;;;;;;;;;;GAFoC;CAAtB;;kBAkBD","file":"app.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","var Vibrant;\n\nVibrant = require('./vibrant');\n\nVibrant.DefaultOpts.Image = require('./image/browser');\n\nmodule.exports = Vibrant;\n","module.exports = function(r, g, b, a) {\n  return a >= 125 && !(r > 250 && g > 250 && b > 250);\n};\n","module.exports.Default = require('./default');\n","var DefaultGenerator, DefaultOpts, Generator, Swatch, util,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\nSwatch = require('../swatch');\n\nutil = require('../util');\n\nGenerator = require('./index');\n\nDefaultOpts = {\n  targetDarkLuma: 0.26,\n  maxDarkLuma: 0.45,\n  minLightLuma: 0.55,\n  targetLightLuma: 0.74,\n  minNormalLuma: 0.3,\n  targetNormalLuma: 0.5,\n  maxNormalLuma: 0.7,\n  targetMutesSaturation: 0.3,\n  maxMutesSaturation: 0.4,\n  targetVibrantSaturation: 1.0,\n  minVibrantSaturation: 0.35,\n  weightSaturation: 3,\n  weightLuma: 6,\n  weightPopulation: 1\n};\n\nmodule.exports = DefaultGenerator = (function(superClass) {\n  extend(DefaultGenerator, superClass);\n\n  DefaultGenerator.prototype.HighestPopulation = 0;\n\n  function DefaultGenerator(opts) {\n    this.opts = util.defaults(opts, DefaultOpts);\n    this.VibrantSwatch = null;\n    this.LightVibrantSwatch = null;\n    this.DarkVibrantSwatch = null;\n    this.MutedSwatch = null;\n    this.LightMutedSwatch = null;\n    this.DarkMutedSwatch = null;\n  }\n\n  DefaultGenerator.prototype.generate = function(swatches) {\n    this.swatches = swatches;\n    this.maxPopulation = this.findMaxPopulation;\n    this.generateVarationColors();\n    return this.generateEmptySwatches();\n  };\n\n  DefaultGenerator.prototype.getVibrantSwatch = function() {\n    return this.VibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getLightVibrantSwatch = function() {\n    return this.LightVibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getDarkVibrantSwatch = function() {\n    return this.DarkVibrantSwatch;\n  };\n\n  DefaultGenerator.prototype.getMutedSwatch = function() {\n    return this.MutedSwatch;\n  };\n\n  DefaultGenerator.prototype.getLightMutedSwatch = function() {\n    return this.LightMutedSwatch;\n  };\n\n  DefaultGenerator.prototype.getDarkMutedSwatch = function() {\n    return this.DarkMutedSwatch;\n  };\n\n  DefaultGenerator.prototype.generateVarationColors = function() {\n    this.VibrantSwatch = this.findColorVariation(this.opts.targetNormalLuma, this.opts.minNormalLuma, this.opts.maxNormalLuma, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.LightVibrantSwatch = this.findColorVariation(this.opts.targetLightLuma, this.opts.minLightLuma, 1, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.DarkVibrantSwatch = this.findColorVariation(this.opts.targetDarkLuma, 0, this.opts.maxDarkLuma, this.opts.targetVibrantSaturation, this.opts.minVibrantSaturation, 1);\n    this.MutedSwatch = this.findColorVariation(this.opts.targetNormalLuma, this.opts.minNormalLuma, this.opts.maxNormalLuma, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n    this.LightMutedSwatch = this.findColorVariation(this.opts.targetLightLuma, this.opts.minLightLuma, 1, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n    return this.DarkMutedSwatch = this.findColorVariation(this.opts.targetDarkLuma, 0, this.opts.maxDarkLuma, this.opts.targetMutesSaturation, 0, this.opts.maxMutesSaturation);\n  };\n\n  DefaultGenerator.prototype.generateEmptySwatches = function() {\n    var hsl;\n    if (this.VibrantSwatch === null) {\n      if (this.DarkVibrantSwatch !== null) {\n        hsl = this.DarkVibrantSwatch.getHsl();\n        hsl[2] = this.opts.targetNormalLuma;\n        this.VibrantSwatch = new Swatch(util.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);\n      }\n    }\n    if (this.DarkVibrantSwatch === null) {\n      if (this.VibrantSwatch !== null) {\n        hsl = this.VibrantSwatch.getHsl();\n        hsl[2] = this.opts.targetDarkLuma;\n        return this.DarkVibrantSwatch = new Swatch(util.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);\n      }\n    }\n  };\n\n  DefaultGenerator.prototype.findMaxPopulation = function() {\n    var j, len, population, ref, swatch;\n    population = 0;\n    ref = this.swatches;\n    for (j = 0, len = ref.length; j < len; j++) {\n      swatch = ref[j];\n      population = Math.max(population, swatch.getPopulation());\n    }\n    return population;\n  };\n\n  DefaultGenerator.prototype.findColorVariation = function(targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation) {\n    var j, len, luma, max, maxValue, ref, sat, swatch, value;\n    max = null;\n    maxValue = 0;\n    ref = this.swatches;\n    for (j = 0, len = ref.length; j < len; j++) {\n      swatch = ref[j];\n      sat = swatch.getHsl()[1];\n      luma = swatch.getHsl()[2];\n      if (sat >= minSaturation && sat <= maxSaturation && luma >= minLuma && luma <= maxLuma && !this.isAlreadySelected(swatch)) {\n        value = this.createComparisonValue(sat, targetSaturation, luma, targetLuma, swatch.getPopulation(), this.HighestPopulation);\n        if (max === null || value > maxValue) {\n          max = swatch;\n          maxValue = value;\n        }\n      }\n    }\n    return max;\n  };\n\n  DefaultGenerator.prototype.createComparisonValue = function(saturation, targetSaturation, luma, targetLuma, population, maxPopulation) {\n    return this.weightedMean(this.invertDiff(saturation, targetSaturation), this.opts.weightSaturation, this.invertDiff(luma, targetLuma), this.opts.weightLuma, population / maxPopulation, this.opts.weightPopulation);\n  };\n\n  DefaultGenerator.prototype.invertDiff = function(value, targetValue) {\n    return 1 - Math.abs(value - targetValue);\n  };\n\n  DefaultGenerator.prototype.weightedMean = function() {\n    var i, sum, sumWeight, value, values, weight;\n    values = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    sum = 0;\n    sumWeight = 0;\n    i = 0;\n    while (i < values.length) {\n      value = values[i];\n      weight = values[i + 1];\n      sum += value * weight;\n      sumWeight += weight;\n      i += 2;\n    }\n    return sum / sumWeight;\n  };\n\n  DefaultGenerator.prototype.isAlreadySelected = function(swatch) {\n    return this.VibrantSwatch === swatch || this.DarkVibrantSwatch === swatch || this.LightVibrantSwatch === swatch || this.MutedSwatch === swatch || this.DarkMutedSwatch === swatch || this.LightMutedSwatch === swatch;\n  };\n\n  return DefaultGenerator;\n\n})(Generator);\n","var Generator;\n\nmodule.exports = Generator = (function() {\n  function Generator() {}\n\n  Generator.prototype.generate = function(swatches) {};\n\n  Generator.prototype.getVibrantSwatch = function() {};\n\n  Generator.prototype.getLightVibrantSwatch = function() {};\n\n  Generator.prototype.getDarkVibrantSwatch = function() {};\n\n  Generator.prototype.getMutedSwatch = function() {};\n\n  Generator.prototype.getLightMutedSwatch = function() {};\n\n  Generator.prototype.getDarkMutedSwatch = function() {};\n\n  return Generator;\n\n})();\n\nmodule.exports.Default = require('./default');\n","var BrowserImage, Image, Url, isRelativeUrl, isSameOrigin,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nImage = require('./index');\n\nUrl = require('url');\n\nisRelativeUrl = function(url) {\n  var u;\n  u = Url.parse(url);\n  return u.protocol === null && u.host === null && u.port === null;\n};\n\nisSameOrigin = function(a, b) {\n  var ua, ub;\n  ua = Url.parse(a);\n  ub = Url.parse(b);\n  return ua.protocol === ub.protocol && ua.hostname === ub.hostname && ua.port === ub.port;\n};\n\nmodule.exports = BrowserImage = (function(superClass) {\n  extend(BrowserImage, superClass);\n\n  function BrowserImage(path, cb) {\n    this.img = document.createElement('img');\n    if (!isRelativeUrl(path) && !isSameOrigin(window.location.href, path)) {\n      this.img.crossOrigin = 'anonymous';\n    }\n    this.img.src = path;\n    this.img.onload = (function(_this) {\n      return function() {\n        _this._initCanvas();\n        return typeof cb === \"function\" ? cb(null, _this) : void 0;\n      };\n    })(this);\n    this.img.onerror = (function(_this) {\n      return function(e) {\n        var err;\n        err = new Error(\"Fail to load image: \" + path);\n        err.raw = e;\n        return typeof cb === \"function\" ? cb(err) : void 0;\n      };\n    })(this);\n  }\n\n  BrowserImage.prototype._initCanvas = function() {\n    this.canvas = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n    document.body.appendChild(this.canvas);\n    this.width = this.canvas.width = this.img.width;\n    this.height = this.canvas.height = this.img.height;\n    return this.context.drawImage(this.img, 0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.clear = function() {\n    return this.context.clearRect(0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.getWidth = function() {\n    return this.width;\n  };\n\n  BrowserImage.prototype.getHeight = function() {\n    return this.height;\n  };\n\n  BrowserImage.prototype.resize = function(w, h, r) {\n    this.width = this.canvas.width = w;\n    this.height = this.canvas.height = h;\n    this.context.scale(r, r);\n    return this.context.drawImage(this.img, 0, 0);\n  };\n\n  BrowserImage.prototype.update = function(imageData) {\n    return this.context.putImageData(imageData, 0, 0);\n  };\n\n  BrowserImage.prototype.getPixelCount = function() {\n    return this.width * this.height;\n  };\n\n  BrowserImage.prototype.getImageData = function() {\n    return this.context.getImageData(0, 0, this.width, this.height);\n  };\n\n  BrowserImage.prototype.removeCanvas = function() {\n    return this.canvas.parentNode.removeChild(this.canvas);\n  };\n\n  return BrowserImage;\n\n})(Image);\n","var Image;\n\nmodule.exports = Image = (function() {\n  function Image() {}\n\n  Image.prototype.clear = function() {};\n\n  Image.prototype.update = function(imageData) {};\n\n  Image.prototype.getWidth = function() {};\n\n  Image.prototype.getHeight = function() {};\n\n  Image.prototype.scaleDown = function(opts) {\n    var height, maxSide, ratio, width;\n    width = this.getWidth();\n    height = this.getHeight();\n    ratio = 1;\n    if (opts.maxDimension != null) {\n      maxSide = Math.max(width, height);\n      if (maxSide > opts.maxDimension) {\n        ratio = opts.maxDimension / maxSide;\n      }\n    } else {\n      ratio = 1 / opts.quality;\n    }\n    if (ratio < 1) {\n      return this.resize(width * ratio, height * ratio, ratio);\n    }\n  };\n\n  Image.prototype.resize = function(w, h, r) {};\n\n  Image.prototype.getPixelCount = function() {};\n\n  Image.prototype.getImageData = function() {};\n\n  Image.prototype.removeCanvas = function() {};\n\n  return Image;\n\n})();\n","var BaselineQuantizer, Quantizer, Swatch, quantize,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nquantize = require('quantize');\n\nmodule.exports = BaselineQuantizer = (function(superClass) {\n  extend(BaselineQuantizer, superClass);\n\n  function BaselineQuantizer() {\n    return BaselineQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  BaselineQuantizer.prototype.initialize = function(pixels, opts) {\n    var a, allPixels, b, cmap, g, i, offset, pixelCount, r;\n    this.opts = opts;\n    pixelCount = pixels.length / 4;\n    allPixels = [];\n    i = 0;\n    while (i < pixelCount) {\n      offset = i * 4;\n      r = pixels[offset + 0];\n      g = pixels[offset + 1];\n      b = pixels[offset + 2];\n      a = pixels[offset + 3];\n      if (a >= 125) {\n        if (!(r > 250 && g > 250 && b > 250)) {\n          allPixels.push([r, g, b]);\n        }\n      }\n      i = i + this.opts.quality;\n    }\n    cmap = quantize(allPixels, this.opts.colorCount);\n    return this.swatches = cmap.vboxes.map((function(_this) {\n      return function(vbox) {\n        return new Swatch(vbox.color, vbox.vbox.count());\n      };\n    })(this));\n  };\n\n  BaselineQuantizer.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return BaselineQuantizer;\n\n})(Quantizer);\n","var ColorCut, ColorCutQuantizer, Quantizer, Swatch,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nColorCut = require('./impl/color-cut');\n\nmodule.exports = ColorCutQuantizer = (function(superClass) {\n  extend(ColorCutQuantizer, superClass);\n\n  function ColorCutQuantizer() {\n    return ColorCutQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  ColorCutQuantizer.prototype.initialize = function(pixels, opts) {\n    var buf, buf8, data;\n    this.opts = opts;\n    buf = new ArrayBuffer(pixels.length);\n    buf8 = new Uint8ClampedArray(buf);\n    data = new Uint32Array(buf);\n    buf8.set(pixels);\n    return this.quantizer = new ColorCut(data, this.opts);\n  };\n\n  ColorCutQuantizer.prototype.getQuantizedColors = function() {\n    return this.quantizer.getQuantizedColors();\n  };\n\n  return ColorCutQuantizer;\n\n})(Quantizer);\n","var ABGRColor, COMPONENT_BLUE, COMPONENT_GREEN, COMPONENT_RED, Color, ColorCutQuantizer, QUANTIZE_WORD_MASK, QUANTIZE_WORD_WIDTH, RGBAColor, Swatch, Vbox, approximateToRgb888, isLittleEndian, modifySignificantOctet, modifyWordWidth, quantizeFromRgb888, quantizedBlue, quantizedGreen, quantizedRed, sort;\n\nSwatch = require('../../swatch');\n\nsort = function(arr, lower, upper) {\n  var partition, pivot, swap;\n  swap = function(a, b) {\n    var t;\n    t = arr[a];\n    arr[a] = arr[b];\n    return arr[b] = t;\n  };\n  partition = function(pivot, left, right) {\n    var index, j, ref, ref1, v, value;\n    index = left;\n    value = arr[pivot];\n    swap(pivot, right);\n    for (v = j = ref = left, ref1 = right - 1; ref <= ref1 ? j <= ref1 : j >= ref1; v = ref <= ref1 ? ++j : --j) {\n      if (arr[v] > value) {\n        swap(v, index);\n        index++;\n      }\n    }\n    swap(right, index);\n    return index;\n  };\n  if (lower < upper) {\n    pivot = lower + Math.ceil((upper - lower) / 2);\n    pivot = partition(pivot, lower, upper);\n    sort(arr, lower, pivot - 1);\n    return sort(arr, pivot + 1, upper);\n  }\n};\n\nCOMPONENT_RED = -3;\n\nCOMPONENT_GREEN = -2;\n\nCOMPONENT_BLUE = -1;\n\nQUANTIZE_WORD_WIDTH = 5;\n\nQUANTIZE_WORD_MASK = (1 << QUANTIZE_WORD_WIDTH) - 1;\n\nRGBAColor = {\n  red: function(c) {\n    return c >> 24;\n  },\n  green: function(c) {\n    return c << 8 >> 24;\n  },\n  blue: function(c) {\n    return c << 16 >> 24;\n  },\n  alpha: function(c) {\n    return c << 24 >> 24;\n  }\n};\n\nABGRColor = {\n  red: function(c) {\n    return c << 24 >> 24;\n  },\n  green: function(c) {\n    return c << 16 >> 24;\n  },\n  blue: function(c) {\n    return c << 8 >> 24;\n  },\n  alpha: function(c) {\n    return c >> 24;\n  }\n};\n\nisLittleEndian = function() {\n  var a, b, c;\n  a = new ArrayBuffer(4);\n  b = new Uint8Array(a);\n  c = new Uint32Array(a);\n  b[0] = 0xa1;\n  b[1] = 0xb2;\n  b[2] = 0xc3;\n  b[3] = 0xd4;\n  if (c[0] === 0xd4c3b2a1) {\n    return true;\n  }\n  if (c[0] === 0xa1b2c3d4) {\n    return false;\n  }\n  throw new Error(\"Failed to determin endianness\");\n};\n\nColor = isLittleEndian() ? ABGRColor : RGBAColor;\n\nmodifyWordWidth = function(value, current, target) {\n  var newValue;\n  newValue = 0;\n  if (target > current) {\n    newValue = value << (target - current);\n  } else {\n    newValue = value >> (current - target);\n  }\n  return newValue & ((1 << target) - 1);\n};\n\nmodifySignificantOctet = function(a, dimension, lower, upper) {\n  var color, i, j, k, ref, ref1, ref2, ref3;\n  switch (dimension) {\n    case COMPONENT_RED:\n      break;\n    case COMPONENT_GREEN:\n      for (i = j = ref = lower, ref1 = upper; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n        color = a[i];\n        a[i] = quantizedGreen(color) << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | quantizedRed(color) << QUANTIZE_WORD_WIDTH | quantizedBlue(color);\n      }\n      break;\n    case COMPONENT_BLUE:\n      for (i = k = ref2 = lower, ref3 = upper; ref2 <= ref3 ? k <= ref3 : k >= ref3; i = ref2 <= ref3 ? ++k : --k) {\n        color = a[i];\n        a[i] = quantizedBlue(color) << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | quantizedGreen(color) << QUANTIZE_WORD_WIDTH | quantizedRed(color);\n      }\n      break;\n  }\n};\n\nquantizeFromRgb888 = function(color) {\n  var b, g, r;\n  r = modifyWordWidth(Color.red(color), 8, QUANTIZE_WORD_WIDTH);\n  g = modifyWordWidth(Color.green(color), 8, QUANTIZE_WORD_WIDTH);\n  b = modifyWordWidth(Color.blue(color), 8, QUANTIZE_WORD_WIDTH);\n  return r << (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) | g << QUANTIZE_WORD_WIDTH | b;\n};\n\napproximateToRgb888 = function(r, g, b) {\n  var color;\n  if (!((g != null) && (b != null))) {\n    color = r;\n    r = quantizedRed(color);\n    g = quantizedGreen(color);\n    b = quantizedBlue(color);\n  }\n  return [modifyWordWidth(r, QUANTIZE_WORD_WIDTH, 8), modifyWordWidth(g, QUANTIZE_WORD_WIDTH, 8), modifyWordWidth(b, QUANTIZE_WORD_WIDTH, 8)];\n};\n\nquantizedRed = function(color) {\n  return color >> (QUANTIZE_WORD_WIDTH + QUANTIZE_WORD_WIDTH) & QUANTIZE_WORD_MASK;\n};\n\nquantizedGreen = function(color) {\n  return color >> QUANTIZE_WORD_WIDTH & QUANTIZE_WORD_MASK;\n};\n\nquantizedBlue = function(color) {\n  return color & QUANTIZE_WORD_MASK;\n};\n\nmodule.exports = ColorCutQuantizer = (function() {\n  function ColorCutQuantizer(data, opts) {\n    var c, color, distinctColorCount, distinctColorIndex, i, j, k, l, m, quantizedColor, ref, ref1, ref2, ref3;\n    this.opts = opts;\n    this.hist = new Uint32Array(1 << (QUANTIZE_WORD_WIDTH * 3));\n    this.pixels = new Uint32Array(data.length);\n    for (i = j = 0, ref = data.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {\n      this.pixels[i] = quantizedColor = quantizeFromRgb888(data[i]);\n      this.hist[quantizedColor]++;\n    }\n    distinctColorCount = 0;\n    for (color = k = 0, ref1 = this.hist.length - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; color = 0 <= ref1 ? ++k : --k) {\n      if (this.hist[color] > 0) {\n        distinctColorCount++;\n      }\n    }\n    this.colors = new Uint32Array(distinctColorCount);\n    distinctColorIndex = 0;\n    for (color = l = 0, ref2 = this.hist.length - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; color = 0 <= ref2 ? ++l : --l) {\n      if (this.hist[color] > 0) {\n        this.colors[distinctColorIndex++] = color;\n      }\n    }\n    if (distinctColorCount <= this.opts.colorCount) {\n      this.quantizedColors = [];\n      for (i = m = 0, ref3 = this.colors.length - 1; 0 <= ref3 ? m <= ref3 : m >= ref3; i = 0 <= ref3 ? ++m : --m) {\n        c = this.colors[i];\n        this.quantizedColors.push(new Swatch(approximateToRgb888(c), this.hist[c]));\n      }\n    } else {\n      this.quantizedColors = this.quantizePixels(this.opts.colorCount);\n    }\n  }\n\n  ColorCutQuantizer.prototype.getQuantizedColors = function() {\n    return this.quantizedColors;\n  };\n\n  ColorCutQuantizer.prototype.quantizePixels = function(maxColors) {\n    var pq;\n    pq = new PriorityQueue({\n      comparator: Vbox.comparator\n    });\n    pq.queue(new Vbox(this.colors, this.hist, 0, this.colors.length - 1));\n    this.splitBoxes(pq, maxColors);\n    return this.generateAverageColors(pq);\n  };\n\n  ColorCutQuantizer.prototype.splitBoxes = function(queue, maxSize) {\n    var vbox;\n    while (queue.length < maxSize) {\n      vbox = queue.dequeue();\n      if (vbox != null ? vbox.canSplit() : void 0) {\n        queue.queue(vbox.splitBox());\n        queue.queue(vbox);\n      } else {\n        return;\n      }\n    }\n  };\n\n  ColorCutQuantizer.prototype.generateAverageColors = function(vboxes) {\n    var colors;\n    colors = [];\n    while (vboxes.length > 0) {\n      colors.push(vboxes.dequeue().getAverageColor());\n    }\n    return colors;\n  };\n\n  return ColorCutQuantizer;\n\n})();\n\nVbox = (function() {\n  Vbox.comparator = function(lhs, rhs) {\n    return lhs.getVolume() - rhs.getVolume();\n  };\n\n  function Vbox(colors1, hist, lowerIndex, upperIndex) {\n    this.colors = colors1;\n    this.hist = hist;\n    this.lowerIndex = lowerIndex;\n    this.upperIndex = upperIndex;\n    this.fitBox();\n  }\n\n  Vbox.prototype.getVolume = function() {\n    return (this.maxRed - this.minRed + 1) * (this.maxGreen - this.minGreen + 1) * (this.maxBlue - this.minBlue + 1);\n  };\n\n  Vbox.prototype.canSplit = function() {\n    return this.getColorCount() > 1;\n  };\n\n  Vbox.prototype.getColorCount = function() {\n    return 1 + this.upperIndex - this.lowerIndex;\n  };\n\n  Vbox.prototype.fitBox = function() {\n    var b, color, count, g, i, j, r, ref, ref1;\n    this.minRed = this.minGreen = this.minBlue = Number.MAX_VALUE;\n    this.maxRed = this.maxGreen = this.maxBlue = Number.MIN_VALUE;\n    this.population = 0;\n    count = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      color = this.colors[i];\n      count += this.hist[color];\n      r = quantizedRed(color);\n      g = quantizedGreen(color);\n      b = quantizedBlue(color);\n      if (r > this.maxRed) {\n        this.maxRed = r;\n      }\n      if (r < this.minRed) {\n        this.minRed = r;\n      }\n      if (g > this.maxGreen) {\n        this.maxGreen = g;\n      }\n      if (g < this.minGreen) {\n        this.minGreen = g;\n      }\n      if (b > this.maxBlue) {\n        this.maxRed = b;\n      }\n      if (b < this.minBlue) {\n        this.minRed = b;\n      }\n    }\n    return this.population = count;\n  };\n\n  Vbox.prototype.splitBox = function() {\n    var newBox, splitPoint;\n    if (!this.canSplit()) {\n      throw new Error(\"Cannot split a box with only 1 color\");\n    }\n    splitPoint = this.findSplitPoint();\n    newBox = new Vbox(this.colors, this.hist, splitPoint + 1, this.upperIndex);\n    this.upperIndex = splitPoint;\n    this.fitBox();\n    return newBox;\n  };\n\n  Vbox.prototype.getLongestColorDimension = function() {\n    var blueLength, greenLength, redLength;\n    redLength = this.maxRed - this.minRed;\n    greenLength = this.maxGreen - this.minGreen;\n    blueLength = this.maxBlue - this.minBlue;\n    if (redLength >= greenLength && redLength >= blueLength) {\n      return COMPONENT_RED;\n    }\n    if (greenLength >= redLength && greenLength >= blueLength) {\n      return COMPONENT_GREEN;\n    }\n    return COMPONENT_BLUE;\n  };\n\n  Vbox.prototype.findSplitPoint = function() {\n    var count, i, j, longestDimension, midPoint, ref, ref1;\n    longestDimension = this.getLongestColorDimension();\n    modifySignificantOctet(this.colors, longestDimension, this.lowerIndex, this.upperIndex);\n    sort(this.colors, this.lowerIndex, this.upperIndex + 1);\n    modifySignificantOctet(this.colors, longestDimension, this.lowerIndex, this.upperIndex);\n    midPoint = this.population / 2;\n    count = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      count += this.hist[this.colors[i]];\n      if (count >= midPoint) {\n        return i;\n      }\n    }\n    return this.lowerIndex;\n  };\n\n  Vbox.prototype.getAverageColor = function() {\n    var blueMean, blueSum, color, colorPopulation, greenMean, greenSum, i, j, redMean, redSum, ref, ref1, totalPopulation;\n    redSum = greenSum = blueSum = 0;\n    totalPopulation = 0;\n    for (i = j = ref = this.lowerIndex, ref1 = this.upperIndex; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n      color = this.colors[i];\n      colorPopulation = this.hist[color];\n      totalPopulation += colorPopulation;\n      redSum += colorPopulation * quantizedRed(color);\n      greenSum += colorPopulation * quantizedGreen(color);\n      blueSum += colorPopulation * quantizedBlue(color);\n    }\n    redMean = Math.round(redSum / totalPopulation);\n    greenMean = Math.round(greenSum / totalPopulation);\n    blueMean = Math.round(blueSum / totalPopulation);\n    return new Swatch(approximateToRgb888(redMean, greenMean, blueMean), totalPopulation);\n  };\n\n  return Vbox;\n\n})();\n","var MMCQ, PQueue, RSHIFT, SIGBITS, Swatch, VBox, getColorIndex, ref, util;\n\nref = util = require('../../util'), getColorIndex = ref.getColorIndex, SIGBITS = ref.SIGBITS, RSHIFT = ref.RSHIFT;\n\nSwatch = require('../../swatch');\n\nVBox = require('./vbox');\n\nPQueue = require('./pqueue');\n\nmodule.exports = MMCQ = (function() {\n  MMCQ.DefaultOpts = {\n    maxIterations: 1000,\n    fractByPopulations: 0.75\n  };\n\n  function MMCQ(opts) {\n    this.opts = util.defaults(opts, this.constructor.DefaultOpts);\n  }\n\n  MMCQ.prototype.quantize = function(pixels, opts) {\n    var color, colorCount, hist, pq, pq2, shouldIgnore, swatches, v, vbox;\n    if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n      throw new Error(\"Wrong MMCQ parameters\");\n    }\n    shouldIgnore = function() {\n      return false;\n    };\n    if (Array.isArray(opts.filters) && opts.filters.length > 0) {\n      shouldIgnore = function(r, g, b, a) {\n        var f, i, len, ref1;\n        ref1 = opts.filters;\n        for (i = 0, len = ref1.length; i < len; i++) {\n          f = ref1[i];\n          if (!f(r, g, b, a)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    vbox = VBox.build(pixels, shouldIgnore);\n    hist = vbox.hist;\n    colorCount = Object.keys(hist).length;\n    pq = new PQueue(function(a, b) {\n      return a.count() - b.count();\n    });\n    pq.push(vbox);\n    this._splitBoxes(pq, this.opts.fractByPopulations * opts.colorCount);\n    pq2 = new PQueue(function(a, b) {\n      return a.count() * a.volume() - b.count() * b.volume();\n    });\n    pq2.contents = pq.contents;\n    this._splitBoxes(pq2, opts.colorCount - pq2.size());\n    swatches = [];\n    this.vboxes = [];\n    while (pq2.size()) {\n      v = pq2.pop();\n      color = v.avg();\n      if (!(typeof shouldIgnore === \"function\" ? shouldIgnore(color[0], color[1], color[2], 255) : void 0)) {\n        this.vboxes.push(v);\n        swatches.push(new Swatch(color, v.count()));\n      }\n    }\n    return swatches;\n  };\n\n  MMCQ.prototype._splitBoxes = function(pq, target) {\n    var colorCount, iteration, maxIterations, ref1, vbox, vbox1, vbox2;\n    colorCount = 1;\n    iteration = 0;\n    maxIterations = this.opts.maxIterations;\n    while (iteration < maxIterations) {\n      iteration++;\n      vbox = pq.pop();\n      if (!vbox.count()) {\n        continue;\n      }\n      ref1 = vbox.split(), vbox1 = ref1[0], vbox2 = ref1[1];\n      pq.push(vbox1);\n      if (vbox2) {\n        pq.push(vbox2);\n        colorCount++;\n      }\n      if (colorCount >= target || iteration > maxIterations) {\n        return;\n      }\n    }\n  };\n\n  return MMCQ;\n\n})();\n","var PQueue;\n\nmodule.exports = PQueue = (function() {\n  function PQueue(comparator) {\n    this.comparator = comparator;\n    this.contents = [];\n    this.sorted = false;\n  }\n\n  PQueue.prototype._sort = function() {\n    this.contents.sort(this.comparator);\n    return this.sorted = true;\n  };\n\n  PQueue.prototype.push = function(o) {\n    this.contents.push(o);\n    return this.sorted = false;\n  };\n\n  PQueue.prototype.peek = function(index) {\n    if (!this.sorted) {\n      this._sort();\n    }\n    if (index == null) {\n      index = this.contents.length - 1;\n    }\n    return this.contents[index];\n  };\n\n  PQueue.prototype.pop = function() {\n    if (!this.sorted) {\n      this._sort();\n    }\n    return this.contents.pop();\n  };\n\n  PQueue.prototype.size = function() {\n    return this.contents.length;\n  };\n\n  PQueue.prototype.map = function(f) {\n    if (!this.sorted) {\n      this._sort();\n    }\n    return this.contents.map(f);\n  };\n\n  return PQueue;\n\n})();\n","var RSHIFT, SIGBITS, VBox, getColorIndex, ref, util;\n\nref = util = require('../../util'), getColorIndex = ref.getColorIndex, SIGBITS = ref.SIGBITS, RSHIFT = ref.RSHIFT;\n\nmodule.exports = VBox = (function() {\n  VBox.build = function(pixels, shouldIgnore) {\n    var a, b, bmax, bmin, g, gmax, gmin, hist, hn, i, index, n, offset, r, rmax, rmin;\n    hn = 1 << (3 * SIGBITS);\n    hist = new Uint32Array(hn);\n    rmax = gmax = bmax = 0;\n    rmin = gmin = bmin = Number.MAX_VALUE;\n    n = pixels.length / 4;\n    i = 0;\n    while (i < n) {\n      offset = i * 4;\n      i++;\n      r = pixels[offset + 0];\n      g = pixels[offset + 1];\n      b = pixels[offset + 2];\n      a = pixels[offset + 3];\n      if (shouldIgnore(r, g, b, a)) {\n        continue;\n      }\n      r = r >> RSHIFT;\n      g = g >> RSHIFT;\n      b = b >> RSHIFT;\n      index = getColorIndex(r, g, b);\n      hist[index] += 1;\n      if (r > rmax) {\n        rmax = r;\n      }\n      if (r < rmin) {\n        rmin = r;\n      }\n      if (g > gmax) {\n        gmax = g;\n      }\n      if (g < gmin) {\n        gmin = g;\n      }\n      if (b > bmax) {\n        bmax = b;\n      }\n      if (b < bmin) {\n        bmin = b;\n      }\n    }\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, hist);\n  };\n\n  function VBox(r1, r2, g1, g2, b1, b2, hist1) {\n    this.r1 = r1;\n    this.r2 = r2;\n    this.g1 = g1;\n    this.g2 = g2;\n    this.b1 = b1;\n    this.b2 = b2;\n    this.hist = hist1;\n  }\n\n  VBox.prototype.invalidate = function() {\n    delete this._count;\n    delete this._avg;\n    return delete this._volume;\n  };\n\n  VBox.prototype.volume = function() {\n    if (this._volume == null) {\n      this._volume = (this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1);\n    }\n    return this._volume;\n  };\n\n  VBox.prototype.count = function() {\n    var c, hist;\n    if (this._count == null) {\n      hist = this.hist;\n      c = 0;\n      \n      for (var r = this.r1; r <= this.r2; r++) {\n        for (var g = this.g1; g <= this.g2; g++) {\n          for (var b = this.b1; b <= this.b2; b++) {\n            var index = getColorIndex(r, g, b);\n            c += hist[index];\n          }\n        }\n      }\n      ;\n      this._count = c;\n    }\n    return this._count;\n  };\n\n  VBox.prototype.clone = function() {\n    return new VBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.hist);\n  };\n\n  VBox.prototype.avg = function() {\n    var bsum, gsum, hist, mult, ntot, rsum;\n    if (this._avg == null) {\n      hist = this.hist;\n      ntot = 0;\n      mult = 1 << (8 - SIGBITS);\n      rsum = gsum = bsum = 0;\n      \n      for (var r = this.r1; r <= this.r2; r++) {\n        for (var g = this.g1; g <= this.g2; g++) {\n          for (var b = this.b1; b <= this.b2; b++) {\n            var index = getColorIndex(r, g, b);\n            var h = hist[index];\n            ntot += h;\n            rsum += (h * (r + 0.5) * mult);\n            gsum += (h * (g + 0.5) * mult);\n            bsum += (h * (b + 0.5) * mult);\n          }\n        }\n      }\n      ;\n      if (ntot) {\n        this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n      } else {\n        this._avg = [~~(mult * (this.r1 + this.r2 + 1) / 2), ~~(mult * (this.g1 + this.g2 + 1) / 2), ~~(mult * (this.b1 + this.b2 + 1) / 2)];\n      }\n    }\n    return this._avg;\n  };\n\n  VBox.prototype.split = function() {\n    var accSum, bw, d, doCut, gw, hist, i, j, maxd, maxw, ref1, reverseSum, rw, splitPoint, sum, total, vbox;\n    hist = this.hist;\n    if (!this.count()) {\n      return null;\n    }\n    if (this.count() === 1) {\n      return [this.clone()];\n    }\n    rw = this.r2 - this.r1 + 1;\n    gw = this.g2 - this.g1 + 1;\n    bw = this.b2 - this.b1 + 1;\n    maxw = Math.max(rw, gw, bw);\n    accSum = null;\n    sum = total = 0;\n    maxd = null;\n    switch (maxw) {\n      case rw:\n        maxd = 'r';\n        accSum = new Uint32Array(this.r2 + 1);\n        \n        for (var r = this.r1; r <= this.r2; r++) {\n          sum = 0\n          for (var g = this.g1; g <= this.g2; g++) {\n            for (var b = this.b1; b <= this.b2; b++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[r] = total;\n        }\n        ;\n        break;\n      case gw:\n        maxd = 'g';\n        accSum = new Uint32Array(this.g2 + 1);\n        \n        for (var g = this.g1; g <= this.g2; g++) {\n          sum = 0\n          for (var r = this.r1; r <= this.r2; r++) {\n            for (var b = this.b1; b <= this.b2; b++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[g] = total;\n        }\n        ;\n        break;\n      case bw:\n        maxd = 'b';\n        accSum = new Uint32Array(this.b2 + 1);\n        \n        for (var b = this.b1; b <= this.b2; b++) {\n          sum = 0\n          for (var r = this.r1; r <= this.r2; r++) {\n            for (var g = this.g1; g <= this.g2; g++) {\n              var index = getColorIndex(r, g, b);\n              sum += hist[index];\n            }\n          }\n          total += sum;\n          accSum[b] = total;\n        }\n        ;\n    }\n    splitPoint = -1;\n    reverseSum = new Uint32Array(accSum.length);\n    for (i = j = 0, ref1 = accSum.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n      d = accSum[i];\n      if (splitPoint < 0 && d > total / 2) {\n        splitPoint = i;\n      }\n      reverseSum[i] = total - d;\n    }\n    vbox = this;\n    doCut = function(d) {\n      var c2, d1, d2, dim1, dim2, left, right, vbox1, vbox2;\n      dim1 = d + \"1\";\n      dim2 = d + \"2\";\n      d1 = vbox[dim1];\n      d2 = vbox[dim2];\n      vbox1 = vbox.clone();\n      vbox2 = vbox.clone();\n      left = splitPoint - d1;\n      right = d2 - splitPoint;\n      if (left <= right) {\n        d2 = Math.min(d2 - 1, ~~(splitPoint + right / 2));\n        d2 = Math.max(0, d2);\n      } else {\n        d2 = Math.max(d1, ~~(splitPoint - 1 - left / 2));\n        d2 = Math.min(vbox[dim2], d2);\n      }\n      while (!accSum[d2]) {\n        d2++;\n      }\n      c2 = reverseSum[d2];\n      while (!c2 && accSum[d2 - 1]) {\n        c2 = reverseSum[--d2];\n      }\n      vbox1[dim2] = d2;\n      vbox2[dim1] = d2 + 1;\n      return [vbox1, vbox2];\n    };\n    return doCut(maxd);\n  };\n\n  VBox.prototype.contains = function(p) {\n    var b, g, r;\n    r = p[0] >> RSHIFT;\n    g = p[1] >> RSHIFT;\n    b = p[2] >> RSHIFT;\n    return r >= this.r1 && r <= this.r2 && g >= this.g1 && g <= this.g2 && b >= this.b1 && b <= this.b2;\n  };\n\n  return VBox;\n\n})();\n","var Quantizer;\n\nmodule.exports = Quantizer = (function() {\n  function Quantizer() {}\n\n  Quantizer.prototype.initialize = function(pixels, opts) {};\n\n  Quantizer.prototype.getQuantizedColors = function() {};\n\n  return Quantizer;\n\n})();\n\nmodule.exports.Baseline = require('./baseline');\n\nmodule.exports.NoCopy = require('./nocopy');\n\nmodule.exports.ColorCut = require('./color-cut');\n\nmodule.exports.MMCQ = require('./mmcq');\n","var MMCQ, MMCQImpl, Quantizer, Swatch,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nMMCQImpl = require('./impl/mmcq');\n\nmodule.exports = MMCQ = (function(superClass) {\n  extend(MMCQ, superClass);\n\n  function MMCQ() {\n    return MMCQ.__super__.constructor.apply(this, arguments);\n  }\n\n  MMCQ.prototype.initialize = function(pixels, opts) {\n    var mmcq;\n    this.opts = opts;\n    mmcq = new MMCQImpl();\n    return this.swatches = mmcq.quantize(pixels, this.opts);\n  };\n\n  MMCQ.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return MMCQ;\n\n})(Quantizer);\n","var NoCopyQuantizer, Quantizer, Swatch, quantize,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nSwatch = require('../swatch');\n\nQuantizer = require('./index');\n\nquantize = require('../../vendor-mod/quantize');\n\nmodule.exports = NoCopyQuantizer = (function(superClass) {\n  extend(NoCopyQuantizer, superClass);\n\n  function NoCopyQuantizer() {\n    return NoCopyQuantizer.__super__.constructor.apply(this, arguments);\n  }\n\n  NoCopyQuantizer.prototype.initialize = function(pixels, opts) {\n    var cmap;\n    this.opts = opts;\n    cmap = quantize(pixels, this.opts);\n    return this.swatches = cmap.vboxes.map((function(_this) {\n      return function(vbox) {\n        return new Swatch(vbox.color, vbox.vbox.count());\n      };\n    })(this));\n  };\n\n  NoCopyQuantizer.prototype.getQuantizedColors = function() {\n    return this.swatches;\n  };\n\n  return NoCopyQuantizer;\n\n})(Quantizer);\n","var Swatch, util;\n\nutil = require('./util');\n\n\n/*\n  From Vibrant.js by Jari Zwarts\n  Ported to node.js by AKFish\n\n  Swatch class\n */\n\nmodule.exports = Swatch = (function() {\n  Swatch.prototype.hsl = void 0;\n\n  Swatch.prototype.rgb = void 0;\n\n  Swatch.prototype.population = 1;\n\n  Swatch.prototype.yiq = 0;\n\n  function Swatch(rgb, population) {\n    this.rgb = rgb;\n    this.population = population;\n  }\n\n  Swatch.prototype.getHsl = function() {\n    if (!this.hsl) {\n      return this.hsl = util.rgbToHsl(this.rgb[0], this.rgb[1], this.rgb[2]);\n    } else {\n      return this.hsl;\n    }\n  };\n\n  Swatch.prototype.getPopulation = function() {\n    return this.population;\n  };\n\n  Swatch.prototype.getRgb = function() {\n    return this.rgb;\n  };\n\n  Swatch.prototype.getHex = function() {\n    return util.rgbToHex(this.rgb[0], this.rgb[1], this.rgb[2]);\n  };\n\n  Swatch.prototype.getTitleTextColor = function() {\n    this._ensureTextColors();\n    if (this.yiq < 200) {\n      return \"#fff\";\n    } else {\n      return \"#000\";\n    }\n  };\n\n  Swatch.prototype.getBodyTextColor = function() {\n    this._ensureTextColors();\n    if (this.yiq < 150) {\n      return \"#fff\";\n    } else {\n      return \"#000\";\n    }\n  };\n\n  Swatch.prototype._ensureTextColors = function() {\n    if (!this.yiq) {\n      return this.yiq = (this.rgb[0] * 299 + this.rgb[1] * 587 + this.rgb[2] * 114) / 1000;\n    }\n  };\n\n  return Swatch;\n\n})();\n","var DELTAE94, RSHIFT, SIGBITS;\n\nDELTAE94 = {\n  NA: 0,\n  PERFECT: 1,\n  CLOSE: 2,\n  GOOD: 10,\n  SIMILAR: 50\n};\n\nSIGBITS = 5;\n\nRSHIFT = 8 - SIGBITS;\n\nmodule.exports = {\n  clone: function(o) {\n    var _o, key, value;\n    if (typeof o === 'object') {\n      if (Array.isArray(o)) {\n        return o.map((function(_this) {\n          return function(v) {\n            return _this.clone(v);\n          };\n        })(this));\n      } else {\n        _o = {};\n        for (key in o) {\n          value = o[key];\n          _o[key] = this.clone(value);\n        }\n        return _o;\n      }\n    }\n    return o;\n  },\n  defaults: function() {\n    var _o, i, key, len, o, value;\n    o = {};\n    for (i = 0, len = arguments.length; i < len; i++) {\n      _o = arguments[i];\n      for (key in _o) {\n        value = _o[key];\n        if (o[key] == null) {\n          o[key] = this.clone(value);\n        }\n      }\n    }\n    return o;\n  },\n  hexToRgb: function(hex) {\n    var m;\n    m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (m != null) {\n      return [m[1], m[2], m[3]].map(function(s) {\n        return parseInt(s, 16);\n      });\n    }\n    return null;\n  },\n  rgbToHex: function(r, g, b) {\n    return \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);\n  },\n  rgbToHsl: function(r, g, b) {\n    var d, h, l, max, min, s;\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    h = void 0;\n    s = void 0;\n    l = (max + min) / 2;\n    if (max === min) {\n      h = s = 0;\n    } else {\n      d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0);\n          break;\n        case g:\n          h = (b - r) / d + 2;\n          break;\n        case b:\n          h = (r - g) / d + 4;\n      }\n      h /= 6;\n    }\n    return [h, s, l];\n  },\n  hslToRgb: function(h, s, l) {\n    var b, g, hue2rgb, p, q, r;\n    r = void 0;\n    g = void 0;\n    b = void 0;\n    hue2rgb = function(p, q, t) {\n      if (t < 0) {\n        t += 1;\n      }\n      if (t > 1) {\n        t -= 1;\n      }\n      if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n      }\n      if (t < 1 / 2) {\n        return q;\n      }\n      if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n      }\n      return p;\n    };\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      q = l < 0.5 ? l * (1 + s) : l + s - (l * s);\n      p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - (1 / 3));\n    }\n    return [r * 255, g * 255, b * 255];\n  },\n  rgbToXyz: function(r, g, b) {\n    var x, y, z;\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    r = r > 0.04045 ? Math.pow((r + 0.005) / 1.055, 2.4) : r / 12.92;\n    g = g > 0.04045 ? Math.pow((g + 0.005) / 1.055, 2.4) : g / 12.92;\n    b = b > 0.04045 ? Math.pow((b + 0.005) / 1.055, 2.4) : b / 12.92;\n    r *= 100;\n    g *= 100;\n    b *= 100;\n    x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n    y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n    z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n    return [x, y, z];\n  },\n  xyzToCIELab: function(x, y, z) {\n    var L, REF_X, REF_Y, REF_Z, a, b;\n    REF_X = 95.047;\n    REF_Y = 100;\n    REF_Z = 108.883;\n    x /= REF_X;\n    y /= REF_Y;\n    z /= REF_Z;\n    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n    L = 116 * y - 16;\n    a = 500 * (x - y);\n    b = 200 * (y - z);\n    return [L, a, b];\n  },\n  rgbToCIELab: function(r, g, b) {\n    var ref, x, y, z;\n    ref = this.rgbToXyz(r, g, b), x = ref[0], y = ref[1], z = ref[2];\n    return this.xyzToCIELab(x, y, z);\n  },\n  deltaE94: function(lab1, lab2) {\n    var L1, L2, WEIGHT_C, WEIGHT_H, WEIGHT_L, a1, a2, b1, b2, dL, da, db, xC1, xC2, xDC, xDE, xDH, xDL, xSC, xSH;\n    WEIGHT_L = 1;\n    WEIGHT_C = 1;\n    WEIGHT_H = 1;\n    L1 = lab1[0], a1 = lab1[1], b1 = lab1[2];\n    L2 = lab2[0], a2 = lab2[1], b2 = lab2[2];\n    dL = L1 - L2;\n    da = a1 - a2;\n    db = b1 - b2;\n    xC1 = Math.sqrt(a1 * a1 + b1 * b1);\n    xC2 = Math.sqrt(a2 * a2 + b2 * b2);\n    xDL = L2 - L1;\n    xDC = xC2 - xC1;\n    xDE = Math.sqrt(dL * dL + da * da + db * db);\n    if (Math.sqrt(xDE) > Math.sqrt(Math.abs(xDL)) + Math.sqrt(Math.abs(xDC))) {\n      xDH = Math.sqrt(xDE * xDE - xDL * xDL - xDC * xDC);\n    } else {\n      xDH = 0;\n    }\n    xSC = 1 + 0.045 * xC1;\n    xSH = 1 + 0.015 * xC1;\n    xDL /= WEIGHT_L;\n    xDC /= WEIGHT_C * xSC;\n    xDH /= WEIGHT_H * xSH;\n    return Math.sqrt(xDL * xDL + xDC * xDC + xDH * xDH);\n  },\n  rgbDiff: function(rgb1, rgb2) {\n    var lab1, lab2;\n    lab1 = this.rgbToCIELab.apply(this, rgb1);\n    lab2 = this.rgbToCIELab.apply(this, rgb2);\n    return this.deltaE94(lab1, lab2);\n  },\n  hexDiff: function(hex1, hex2) {\n    var rgb1, rgb2;\n    rgb1 = this.hexToRgb(hex1);\n    rgb2 = this.hexToRgb(hex2);\n    return this.rgbDiff(rgb1, rgb2);\n  },\n  DELTAE94_DIFF_STATUS: DELTAE94,\n  getColorDiffStatus: function(d) {\n    if (d < DELTAE94.NA) {\n      return \"N/A\";\n    }\n    if (d <= DELTAE94.PERFECT) {\n      return \"Perfect\";\n    }\n    if (d <= DELTAE94.CLOSE) {\n      return \"Close\";\n    }\n    if (d <= DELTAE94.GOOD) {\n      return \"Good\";\n    }\n    if (d < DELTAE94.SIMILAR) {\n      return \"Similar\";\n    }\n    return \"Wrong\";\n  },\n  SIGBITS: SIGBITS,\n  RSHIFT: RSHIFT,\n  getColorIndex: function(r, g, b) {\n    return (r << (2 * SIGBITS)) + (g << SIGBITS) + b;\n  }\n};\n","\n/*\n  From Vibrant.js by Jari Zwarts\n  Ported to node.js by AKFish\n\n  Color algorithm class that finds variations on colors in an image.\n\n  Credits\n  --------\n  Lokesh Dhakar (http://www.lokeshdhakar.com) - Created ColorThief\n  Google - Palette support library in Android\n */\nvar Builder, DefaultGenerator, Filter, Swatch, Vibrant, util,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nSwatch = require('./swatch');\n\nutil = require('./util');\n\nDefaultGenerator = require('./generator').Default;\n\nFilter = require('./filter');\n\nmodule.exports = Vibrant = (function() {\n  Vibrant.DefaultOpts = {\n    colorCount: 64,\n    quality: 5,\n    generator: new DefaultGenerator(),\n    Image: null,\n    Quantizer: require('./quantizer').MMCQ,\n    filters: []\n  };\n\n  Vibrant.from = function(src) {\n    return new Builder(src);\n  };\n\n  Vibrant.prototype.quantize = require('quantize');\n\n  Vibrant.prototype._swatches = [];\n\n  function Vibrant(sourceImage, opts) {\n    this.sourceImage = sourceImage;\n    if (opts == null) {\n      opts = {};\n    }\n    this.swatches = bind(this.swatches, this);\n    this.opts = util.defaults(opts, this.constructor.DefaultOpts);\n    this.generator = this.opts.generator;\n  }\n\n  Vibrant.prototype.getPalette = function(cb) {\n    var image;\n    return image = new this.opts.Image(this.sourceImage, (function(_this) {\n      return function(err, image) {\n        var error;\n        if (err != null) {\n          return cb(err);\n        }\n        try {\n          _this._process(image, _this.opts);\n          return cb(null, _this.swatches());\n        } catch (_error) {\n          error = _error;\n          return cb(error);\n        }\n      };\n    })(this));\n  };\n\n  Vibrant.prototype.getSwatches = function(cb) {\n    return this.getPalette(cb);\n  };\n\n  Vibrant.prototype._process = function(image, opts) {\n    var imageData, quantizer, swatches;\n    image.scaleDown(this.opts);\n    imageData = image.getImageData();\n    quantizer = new this.opts.Quantizer();\n    quantizer.initialize(imageData.data, this.opts);\n    swatches = quantizer.getQuantizedColors();\n    this.generator.generate(swatches);\n    return image.removeCanvas();\n  };\n\n  Vibrant.prototype.swatches = function() {\n    return {\n      Vibrant: this.generator.getVibrantSwatch(),\n      Muted: this.generator.getMutedSwatch(),\n      DarkVibrant: this.generator.getDarkVibrantSwatch(),\n      DarkMuted: this.generator.getDarkMutedSwatch(),\n      LightVibrant: this.generator.getLightVibrantSwatch(),\n      LightMuted: this.generator.getLightMutedSwatch()\n    };\n  };\n\n  return Vibrant;\n\n})();\n\nmodule.exports.Builder = Builder = (function() {\n  function Builder(src1, opts1) {\n    this.src = src1;\n    this.opts = opts1 != null ? opts1 : {};\n    this.opts.filters = util.clone(Vibrant.DefaultOpts.filters);\n  }\n\n  Builder.prototype.maxColorCount = function(n) {\n    this.opts.colorCount = n;\n    return this;\n  };\n\n  Builder.prototype.maxDimension = function(d) {\n    this.opts.maxDimension = d;\n    return this;\n  };\n\n  Builder.prototype.addFilter = function(f) {\n    if (typeof f === 'function') {\n      this.opts.filters.push(f);\n    }\n    return this;\n  };\n\n  Builder.prototype.removeFilter = function(f) {\n    var i;\n    if ((i = this.opts.filters.indexOf(f)) > 0) {\n      this.opts.filters.splice(i);\n    }\n    return this;\n  };\n\n  Builder.prototype.clearFilters = function() {\n    this.opts.filters = [];\n    return this;\n  };\n\n  Builder.prototype.quality = function(q) {\n    this.opts.quality = q;\n    return this;\n  };\n\n  Builder.prototype.useImage = function(image) {\n    this.opts.Image = image;\n    return this;\n  };\n\n  Builder.prototype.useGenerator = function(generator) {\n    this.opts.generator = generator;\n    return this;\n  };\n\n  Builder.prototype.useQuantizer = function(quantizer) {\n    this.opts.Quantizer = quantizer;\n    return this;\n  };\n\n  Builder.prototype.build = function() {\n    if (this.v == null) {\n      this.v = new Vibrant(this.src, this.opts);\n    }\n    return this.v;\n  };\n\n  Builder.prototype.getSwatches = function(cb) {\n    return this.build().getPalette(cb);\n  };\n\n  Builder.prototype.getPalette = function(cb) {\n    return this.build().getPalette(cb);\n  };\n\n  Builder.prototype.from = function(src) {\n    return new Vibrant(src, this.opts);\n  };\n\n  return Builder;\n\n})();\n\nmodule.exports.Util = util;\n\nmodule.exports.Swatch = Swatch;\n\nmodule.exports.Quantizer = require('./quantizer/');\n\nmodule.exports.Generator = require('./generator/');\n\nmodule.exports.Filter = require('./filter/');\n","/*\r\n * quantize.js Copyright 2008 Nick Rabinowitz\r\n * Ported to node.js by Olivier Lesnicki\r\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\r\n */\r\n\r\n// fill out a couple protovis dependencies\r\n/*\r\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\r\n * Copyright 2010 Stanford Visualization Group\r\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\r\n */\r\nif (!pv) {\r\n    var pv = {\r\n        map: function(array, f) {\r\n            var o = {};\r\n            return f ? array.map(function(d, i) {\r\n                o.index = i;\r\n                return f.call(o, d);\r\n            }) : array.slice();\r\n        },\r\n        naturalOrder: function(a, b) {\r\n            return a - b;\r\n        },\r\n        sum: function(array, f) {\r\n            var o = {};\r\n            return array.reduce(f ? function(p, d, i) {\r\n                o.index = i;\r\n                return p + f.call(o, d);\r\n            } : function(p, d) {\r\n                return p + d;\r\n            }, 0);\r\n        },\r\n        max: function(array, f) {\r\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Basic Javascript port of the MMCQ (modified median cut quantization)\r\n * algorithm from the Leptonica library (http://www.leptonica.com/).\r\n * Returns a color map you can use to map original pixels to the reduced\r\n * palette. Still a work in progress.\r\n *\r\n * @author Nick Rabinowitz\r\n * @example\r\n\r\n// array of pixels as [R,G,B] arrays\r\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\r\n                // etc\r\n                ];\r\nvar maxColors = 4;\r\n\r\nvar cmap = MMCQ.quantize(myPixels, maxColors);\r\nvar newPalette = cmap.palette();\r\nvar newPixels = myPixels.map(function(p) {\r\n    return cmap.map(p);\r\n});\r\n\r\n */\r\nvar MMCQ = (function() {\r\n    // private constants\r\n    var sigbits = 5,\r\n        rshift = 8 - sigbits,\r\n        maxIterations = 1000,\r\n        fractByPopulations = 0.75;\r\n\r\n    // get reduced-space color index for a pixel\r\n\r\n    function getColorIndex(r, g, b) {\r\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\r\n    }\r\n\r\n    // Simple priority queue\r\n\r\n    function PQueue(comparator) {\r\n        var contents = [],\r\n            sorted = false;\r\n\r\n        function sort() {\r\n            contents.sort(comparator);\r\n            sorted = true;\r\n        }\r\n\r\n        return {\r\n            push: function(o) {\r\n                contents.push(o);\r\n                sorted = false;\r\n            },\r\n            peek: function(index) {\r\n                if (!sorted) sort();\r\n                if (index === undefined) index = contents.length - 1;\r\n                return contents[index];\r\n            },\r\n            pop: function() {\r\n                if (!sorted) sort();\r\n                return contents.pop();\r\n            },\r\n            size: function() {\r\n                return contents.length;\r\n            },\r\n            map: function(f) {\r\n                return contents.map(f);\r\n            },\r\n            debug: function() {\r\n                if (!sorted) sort();\r\n                return contents;\r\n            }\r\n        };\r\n    }\r\n\r\n    // 3d color space box\r\n\r\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\r\n        var vbox = this;\r\n        vbox.r1 = r1;\r\n        vbox.r2 = r2;\r\n        vbox.g1 = g1;\r\n        vbox.g2 = g2;\r\n        vbox.b1 = b1;\r\n        vbox.b2 = b2;\r\n        vbox.histo = histo;\r\n    }\r\n    VBox.prototype = {\r\n        volume: function(force) {\r\n            var vbox = this;\r\n            if (!vbox._volume || force) {\r\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\r\n            }\r\n            return vbox._volume;\r\n        },\r\n        count: function(force) {\r\n            var vbox = this,\r\n                histo = vbox.histo;\r\n            if (!vbox._count_set || force) {\r\n                var npix = 0,\r\n                    i, j, k;\r\n                for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                            index = getColorIndex(i, j, k);\r\n                            npix += histo[index];\r\n                        }\r\n                    }\r\n                }\r\n                vbox._count = npix;\r\n                vbox._count_set = true;\r\n            }\r\n            return vbox._count;\r\n        },\r\n        copy: function() {\r\n            var vbox = this;\r\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\r\n        },\r\n        avg: function(force) {\r\n            var vbox = this,\r\n                histo = vbox.histo;\r\n            if (!vbox._avg || force) {\r\n                var ntot = 0,\r\n                    mult = 1 << (8 - sigbits),\r\n                    // mult = (8 - sigbits),\r\n                    rsum = 0,\r\n                    gsum = 0,\r\n                    bsum = 0,\r\n                    hval,\r\n                    i, j, k, histoindex;\r\n                for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                            histoindex = getColorIndex(i, j, k);\r\n                            hval = histo[histoindex];\r\n                            ntot += hval;\r\n                            rsum += (hval * (i + 0.5) * mult);\r\n                            gsum += (hval * (j + 0.5) * mult);\r\n                            bsum += (hval * (k + 0.5) * mult);\r\n                        }\r\n                    }\r\n                }\r\n                if (ntot) {\r\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\r\n                } else {\r\n                    //console.log('empty box');\r\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\r\n                }\r\n            }\r\n            return vbox._avg;\r\n        },\r\n        contains: function(pixel) {\r\n            var vbox = this,\r\n                rval = pixel[0] >> rshift;\r\n            gval = pixel[1] >> rshift;\r\n            bval = pixel[2] >> rshift;\r\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\r\n                gval >= vbox.g1 && gval <= vbox.g2 &&\r\n                bval >= vbox.b1 && bval <= vbox.b2);\r\n        }\r\n    };\r\n\r\n    // Color map\r\n\r\n    function CMap() {\r\n        this.vboxes = new PQueue(function(a, b) {\r\n            return pv.naturalOrder(\r\n                a.vbox.count() * a.vbox.volume(),\r\n                b.vbox.count() * b.vbox.volume()\r\n            )\r\n        });;\r\n    }\r\n    CMap.prototype = {\r\n        push: function(vbox) {\r\n            this.vboxes.push({\r\n                vbox: vbox,\r\n                color: vbox.avg()\r\n            });\r\n        },\r\n        palette: function() {\r\n            return this.vboxes.map(function(vb) {\r\n                return vb.color\r\n            });\r\n        },\r\n        size: function() {\r\n            return this.vboxes.size();\r\n        },\r\n        map: function(color) {\r\n            var vboxes = this.vboxes;\r\n            for (var i = 0; i < vboxes.size(); i++) {\r\n                if (vboxes.peek(i).vbox.contains(color)) {\r\n                    return vboxes.peek(i).color;\r\n                }\r\n            }\r\n            return this.nearest(color);\r\n        },\r\n        nearest: function(color) {\r\n            var vboxes = this.vboxes,\r\n                d1, d2, pColor;\r\n            for (var i = 0; i < vboxes.size(); i++) {\r\n                d2 = Math.sqrt(\r\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\r\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\r\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\r\n                );\r\n                if (d2 < d1 || d1 === undefined) {\r\n                    d1 = d2;\r\n                    pColor = vboxes.peek(i).color;\r\n                }\r\n            }\r\n            return pColor;\r\n        },\r\n        forcebw: function() {\r\n            // XXX: won't  work yet\r\n            var vboxes = this.vboxes;\r\n            vboxes.sort(function(a, b) {\r\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\r\n            });\r\n\r\n            // force darkest color to black if everything < 5\r\n            var lowest = vboxes[0].color;\r\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\r\n                vboxes[0].color = [0, 0, 0];\r\n\r\n            // force lightest color to white if everything > 251\r\n            var idx = vboxes.length - 1,\r\n                highest = vboxes[idx].color;\r\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\r\n                vboxes[idx].color = [255, 255, 255];\r\n        }\r\n    };\r\n\r\n\r\n    function getAll(pixels, shouldIgnore) {\r\n        var histosize = 1 << (3 * sigbits),\r\n            histo = new Uint32Array(histosize),\r\n            index, rval, gval, bval;\r\n        var rmin = 1000000,\r\n            rmax = 0,\r\n            gmin = 1000000,\r\n            gmax = 0,\r\n            bmin = 1000000,\r\n            bmax = 0;\r\n\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        } else {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        }\r\n\r\n        return {\r\n          histo: histo,\r\n          vbox: new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo)\r\n        };\r\n    }\r\n\r\n    // histo (1-d array, giving the number of pixels in\r\n    // each quantized region of color space), or null on error\r\n\r\n    function getHisto(pixels, shouldIgnore) {\r\n        var histosize = 1 << (3 * sigbits),\r\n            histo = new Uint32Array(histosize),\r\n            index, rval, gval, bval;\r\n\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n          }\r\n        } else {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              index = getColorIndex(rval, gval, bval);\r\n              histo[index]++;\r\n          }\r\n        }\r\n\r\n        return histo;\r\n    }\r\n\r\n    function vboxFromPixels(pixels, histo, shouldIgnore) {\r\n        var rmin = 1000000,\r\n            rmax = 0,\r\n            gmin = 1000000,\r\n            gmax = 0,\r\n            bmin = 1000000,\r\n            bmax = 0,\r\n            rval, gval, bval;\r\n        // find min/max\r\n        var pixelCount = pixels.length / 4,\r\n            i = 0;\r\n\r\n        // Yes, it matters\r\n        if (typeof shouldIgnore === 'function') {\r\n          while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              if (shouldIgnore(r, g, b, a)) continue;\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        } else {\r\n            while (i < pixelCount) {\r\n              offset = i * 4;\r\n              i++;\r\n              r = pixels[offset + 0];\r\n              g = pixels[offset + 1];\r\n              b = pixels[offset + 2];\r\n              a = pixels[offset + 3];\r\n              rval = r >> rshift;\r\n              gval = g >> rshift;\r\n              bval = b >> rshift;\r\n              if (rval < rmin) rmin = rval;\r\n              else if (rval > rmax) rmax = rval;\r\n              if (gval < gmin) gmin = gval;\r\n              else if (gval > gmax) gmax = gval;\r\n              if (bval < bmin) bmin = bval;\r\n              else if (bval > bmax) bmax = bval;\r\n          }\r\n        }\r\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\r\n    }\r\n\r\n    function medianCutApply(histo, vbox) {\r\n        if (!vbox.count()) return;\r\n\r\n        var rw = vbox.r2 - vbox.r1 + 1,\r\n            gw = vbox.g2 - vbox.g1 + 1,\r\n            bw = vbox.b2 - vbox.b1 + 1,\r\n            maxw = pv.max([rw, gw, bw]);\r\n        // only one pixel, no split\r\n        if (vbox.count() == 1) {\r\n            return [vbox.copy()]\r\n        }\r\n        /* Find the partial sum arrays along the selected axis. */\r\n        var total = 0,\r\n            partialsum,\r\n            lookaheadsum,\r\n            i, j, k, sum, index;\r\n        // var D = ['r', 'g', 'b'],\r\n        //   indexer = getColorIndex;\r\n        // if (maxw == gw) {\r\n        //   D = ['g', 'r', 'b'];\r\n        //   indexer = function(g, r, b) { return getColorIndex(r, g, b); };\r\n        // } else if (maxw == bw) {\r\n        //   indexer = function(b, r, g) { return getColorIndex(r, g, b); };\r\n        //   D = ['b', 'r', 'g'];\r\n        // }\r\n        // partialsum = new Uint32Array(vbox[D[0] + \"2\"] + 1);\r\n        // console.log(vbox[D[0] + \"2\"])\r\n        // for (i = vbox[D[0] + \"1\"]; i <= vbox[D[0] + \"2\"]; i++) {\r\n        //     sum = 0;\r\n        //     for (j = vbox[D[1] + \"1\"]; j <= vbox[D[1] + \"2\"]; j++) {\r\n        //         for (k = vbox[D[2] + \"1\"]; k <= vbox[D[2] + \"2\"]; k++) {\r\n        //             index = indexer(i, j, k);\r\n        //             sum += histo[index];\r\n        //         }\r\n        //     }\r\n        //     total += sum;\r\n        //     console.log(i + \"->\" + total)\r\n        //     partialsum[i] = total;\r\n        // }\r\n        var maxd = 'b';\r\n        if (maxw == rw) {\r\n            maxd = 'r';\r\n            partialsum = new Uint32Array(vbox.r2 + 1);\r\n            for (i = vbox.r1; i <= vbox.r2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.g1; j <= vbox.g2; j++) {\r\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                        index = getColorIndex(i, j, k);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        } else if (maxw == gw) {\r\n            maxd = 'g';\r\n            partialsum = new Uint32Array(vbox.g2 + 1);\r\n            for (i = vbox.g1; i <= vbox.g2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.r1; j <= vbox.r2; j++) {\r\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\r\n                        index = getColorIndex(j, i, k);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        } else { /* maxw == bw */\r\n            // maxd = 'b';\r\n            partialsum = new Uint32Array(vbox.b2 + 1);\r\n            for (i = vbox.b1; i <= vbox.b2; i++) {\r\n                sum = 0;\r\n                for (j = vbox.r1; j <= vbox.r2; j++) {\r\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\r\n                        index = getColorIndex(j, k, i);\r\n                        sum += histo[index];\r\n                    }\r\n                }\r\n                total += sum;\r\n                partialsum[i] = total;\r\n            }\r\n        }\r\n        var splitPoint = -1;\r\n        lookaheadsum = new Uint32Array(partialsum.length);\r\n        for (i = 0; i < partialsum.length; i++) {\r\n          var d = partialsum[i];\r\n          if (splitPoint < 0 && d > (total / 2)) splitPoint = i;\r\n          lookaheadsum[i] = total - d\r\n        }\r\n        // partialsum.forEach(function(d, i) {\r\n        //   if (splitPoint < 0 && d > (total / 2)) splitPoint = i\r\n        //     lookaheadsum[i] = total - d\r\n        // });\r\n\r\n        // console.log('cut')\r\n        function doCut(color) {\r\n            var dim1 = color + '1',\r\n                dim2 = color + '2',\r\n                left, right, vbox1, vbox2, d2, count2 = 0,\r\n                i = splitPoint;\r\n            vbox1 = vbox.copy();\r\n            vbox2 = vbox.copy();\r\n            left = i - vbox[dim1];\r\n            right = vbox[dim2] - i;\r\n            if (left <= right) {\r\n                d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\r\n                d2 = Math.max(0, d2);\r\n            } else {\r\n                d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\r\n                d2 = Math.min(vbox[dim2], d2);\r\n            }\r\n            // console.log(partialsum[d2])\r\n            // avoid 0-count boxes\r\n            while (!partialsum[d2]) d2++;\r\n            count2 = lookaheadsum[d2];\r\n            // console.log('-_-')\r\n            while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\r\n            // set dimensions\r\n            vbox1[dim2] = d2;\r\n            vbox2[dim1] = vbox1[dim2] + 1;\r\n            // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\r\n            return [vbox1, vbox2];\r\n\r\n        }\r\n        // determine the cut planes\r\n        return doCut(maxd);\r\n        // return maxw == rw ? doCut('r') :\r\n        //     maxw == gw ? doCut('g') :\r\n        //     doCut('b');\r\n    }\r\n\r\n    function quantize(pixels, opts) {\r\n        var maxcolors = opts.colorCount;\r\n        // short-circuit\r\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\r\n            // console.log('wrong number of maxcolors');\r\n            return false;\r\n        }\r\n\r\n        var hasFilters = Array.isArray(opts.filters) && opts.filters.length > 0;\r\n        function shouldIgnore(r, g, b, a) {\r\n          for (var i = 0; i < opts.filters.length; i++) {\r\n            var f = opts.filters[i];\r\n            if (!f(r, g, b, a)) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        }\r\n\r\n        var r = getAll(pixels, hasFilters ? houldIgnore : null);\r\n        // XXX: check color content and convert to grayscale if insufficient\r\n\r\n        // var histo = getHisto(pixels, hasFilters ? shouldIgnore : null),\r\n        var histo = r.histo,\r\n            histosize = 1 << (3 * sigbits);\r\n\r\n        // check that we aren't below maxcolors already\r\n        var nColors = Object.keys(histo).length;\r\n        if (nColors <= maxcolors) {\r\n            // XXX: generate the new colors from the histo and return\r\n        }\r\n\r\n        // get the beginning vbox from the colors\r\n        // var vbox = vboxFromPixels(pixels, histo, hasFilters ? shouldIgnore : null),\r\n        var vbox = r.vbox,\r\n            pq = new PQueue(function(a, b) {\r\n                return pv.naturalOrder(a.count(), b.count())\r\n            });\r\n        pq.push(vbox);\r\n\r\n        // inner function to do the iteration\r\n\r\n        function iter(lh, target) {\r\n            var ncolors = 1,\r\n                niters = 0,\r\n                vbox;\r\n            while (niters < maxIterations) {\r\n                vbox = lh.pop();\r\n                if (!vbox.count()) { /* just put it back */\r\n                    // lh.push(vbox); // Maybe not\r\n                    niters++;\r\n                    continue;\r\n                }\r\n                // do the cut\r\n                var vboxes = medianCutApply(histo, vbox),\r\n                    vbox1 = vboxes[0],\r\n                    vbox2 = vboxes[1];\r\n\r\n                if (!vbox1) {\r\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\r\n                    return;\r\n                }\r\n                lh.push(vbox1);\r\n                if (vbox2) { /* vbox2 can be null */\r\n                    lh.push(vbox2);\r\n                    ncolors++;\r\n                }\r\n                if (ncolors >= target) return;\r\n                if (niters++ > maxIterations) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // first set of colors, sorted by population\r\n        iter(pq, fractByPopulations * maxcolors);\r\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\r\n\r\n        // Re-sort by the product of pixel occupancy times the size in color space.\r\n        var pq2 = new PQueue(function(a, b) {\r\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\r\n        });\r\n        while (pq.size()) {\r\n            pq2.push(pq.pop());\r\n        }\r\n\r\n        // next set - generate the median cuts using the (npix * vol) sorting.\r\n        iter(pq2, maxcolors - pq2.size());\r\n\r\n        // calculate the actual colors\r\n        var cmap = new CMap();\r\n        while (pq2.size()) {\r\n            var v = pq2.pop(),\r\n              c = vbox.avg();\r\n            if (!hasFilters || !shouldIgnore(c[0], c[1], c[2], 255)) {\r\n              cmap.push(v);\r\n            }\r\n        }\r\n\r\n        return cmap;\r\n    }\r\n\r\n    return {\r\n        quantize: quantize,\r\n        getAll: getAll,\r\n        medianCutApply: medianCutApply\r\n    }\r\n})();\r\n\r\nmodule.exports = MMCQ.quantize\r\nmodule.exports.getAll = MMCQ.getAll\r\nmodule.exports.splitBox = MMCQ.medianCutApply\r\n","  /* globals require, module */\n\n  'use strict';\n\n  /**\n   * Module dependencies.\n   */\n\n  var pathtoRegexp = require('path-to-regexp');\n\n  /**\n   * Module exports.\n   */\n\n  module.exports = page;\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var location = ('undefined' !== typeof window) && (window.history.location || window.location);\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n\n  /**\n   * Decode URL components (query string, pathname, hash).\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\n   */\n  var decodeURLComponents = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * HashBang option\n   */\n\n  var hashbang = false;\n\n  /**\n   * Previous context, for capturing\n   * page exit events.\n   */\n\n  var prevContext;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {String|Function} path\n   * @param {Function} fn...\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(path);\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n  page.exits = [];\n\n  /**\n   * Current path being processed\n   * @type {String}\n   */\n  page.current = '';\n\n  /**\n   * Number of pages navigated to.\n   * @type {number}\n   *\n   *     page.len == 0;\n   *     page('/login');\n   *     page.len == 1;\n   */\n\n  page.len = 0;\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {String} path\n   * @api public\n   */\n\n  page.base = function(path) {\n    if (0 === arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options) {\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click) {\n      document.addEventListener(clickEvent, onclick, false);\n    }\n    if (true === options.hashbang) hashbang = true;\n    if (!dispatch) return;\n    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function() {\n    if (!running) return;\n    page.current = '';\n    page.len = 0;\n    running = false;\n    document.removeEventListener(clickEvent, onclick, false);\n    window.removeEventListener('popstate', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @param {Boolean} dispatch\n   * @return {Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    if (false !== dispatch) page.dispatch(ctx);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {String} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object} [state]\n   * @api public\n   */\n\n  page.back = function(path, state) {\n    if (page.len > 0) {\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      history.back();\n      page.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    }else{\n      setTimeout(function() {\n        page.show(base, state);\n      });\n    }\n  };\n\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {String} from - if param 'to' is undefined redirects to 'from'\n   * @param {String} [to]\n   * @api public\n   */\n  page.redirect = function(from, to) {\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page(from, function(e) {\n        setTimeout(function() {\n          page.replace(to);\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        page.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @return {Context}\n   * @api public\n   */\n\n\n  page.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) page.dispatch(ctx);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Object} ctx\n   * @api private\n   */\n\n  page.dispatch = function(ctx) {\n    var prev = prevContext,\n      i = 0,\n      j = 0;\n\n    prevContext = ctx;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled(ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n\n    if (hashbang) {\n      current = base + location.hash.replace('#!', '');\n    } else {\n      current = location.pathname + location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    location.href = ctx.canonicalPath;\n  }\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  page.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return page.exit('*', path);\n    }\n\n    var route = new Route(path);\n    for (var i = 1; i < arguments.length; ++i) {\n      page.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {str} URL component to decode\n   */\n  function decodeURLEncodedURIComponent(val) {\n    if (typeof val !== 'string') { return val; }\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = parts[0];\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    page.len++;\n    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @param {String} path\n   * @param {Object} options.\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(this.path,\n      this.keys = [],\n      options.sensitive,\n      options.strict);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {String} path\n   * @param {Object} params\n   * @return {Boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  var onpopstate = (function () {\n    var loaded = false;\n    if ('undefined' === typeof window) {\n      return;\n    }\n    if (document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else {\n        page.show(location.pathname + location.hash, undefined, undefined, false);\n      }\n    };\n  })();\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n\n    if (1 !== which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n\n\n    // ensure link\n    var el = e.target;\n    while (el && 'A' !== el.nodeName) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName) return;\n\n\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;\n\n\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    if (el.target) return;\n\n    // x-origin\n    if (!sameOrigin(el.href)) return;\n\n\n\n    // rebuild path\n    var path = el.pathname + el.search + (el.hash || '');\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n\n    if (path.indexOf(base) === 0) {\n      path = path.substr(base.length);\n    }\n\n    if (hashbang) path = path.replace('#!', '');\n\n    if (base && orig === path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null === e.which ? e.button : e.which;\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return (href && (0 === href.indexOf(origin)));\n  }\n\n  page.sameOrigin = sameOrigin;\n","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! https://mths.be/punycode v1.4.0 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n\n// fill out a couple protovis dependencies\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nif (!pv) {\n    var pv = {\n        map: function(array, f) {\n            var o = {};\n            return f ? array.map(function(d, i) {\n                o.index = i;\n                return f.call(o, d);\n            }) : array.slice();\n        },\n        naturalOrder: function(a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function(array, f) {\n            var o = {};\n            return array.reduce(f ? function(p, d, i) {\n                o.index = i;\n                return p + f.call(o, d);\n            } : function(p, d) {\n                return p + d;\n            }, 0);\n        },\n        max: function(array, f) {\n            return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    }\n}\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\nvar MMCQ = (function() {\n    // private constants\n    var sigbits = 5,\n        rshift = 8 - sigbits,\n        maxIterations = 1000,\n        fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n\n    function PQueue(comparator) {\n        var contents = [],\n            sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function(o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function(index) {\n                if (!sorted) sort();\n                if (index === undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function() {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function() {\n                return contents.length;\n            },\n            map: function(f) {\n                return contents.map(f);\n            },\n            debug: function() {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function(force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0,\n                    i, j, k;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            index = getColorIndex(i, j, k);\n                            npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function() {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function(force) {\n            var vbox = this,\n                histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0,\n                    mult = 1 << (8 - sigbits),\n                    rsum = 0,\n                    gsum = 0,\n                    bsum = 0,\n                    hval,\n                    i, j, k, histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                            histoindex = getColorIndex(i, j, k);\n                            hval = histo[histoindex] || 0;\n                            ntot += hval;\n                            rsum += (hval * (i + 0.5) * mult);\n                            gsum += (hval * (j + 0.5) * mult);\n                            bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum / ntot), ~~ (gsum / ntot), ~~ (bsum / ntot)];\n                } else {\n                    //console.log('empty box');\n                    vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~ (mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~ (mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function(pixel) {\n            var vbox = this,\n                rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                gval >= vbox.g1 && gval <= vbox.g2 &&\n                bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n\n    function CMap() {\n        this.vboxes = new PQueue(function(a, b) {\n            return pv.naturalOrder(\n                a.vbox.count() * a.vbox.volume(),\n                b.vbox.count() * b.vbox.volume()\n            )\n        });;\n    }\n    CMap.prototype = {\n        push: function(vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function() {\n            return this.vboxes.map(function(vb) {\n                return vb.color\n            });\n        },\n        size: function() {\n            return this.vboxes.size();\n        },\n        map: function(color) {\n            var vboxes = this.vboxes;\n            for (var i = 0; i < vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function(color) {\n            var vboxes = this.vboxes,\n                d1, d2, pColor;\n            for (var i = 0; i < vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function() {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function(a, b) {\n                return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\n            });\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0, 0, 0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length - 1,\n                highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255, 255, 255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits),\n            histo = new Array(histosize),\n            index, rval, gval, bval;\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin = 1000000,\n            rmax = 0,\n            gmin = 1000000,\n            gmax = 0,\n            bmin = 1000000,\n            bmax = 0,\n            rval, gval, bval;\n        // find min/max\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax) bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1,\n            gw = vbox.g2 - vbox.g1 + 1,\n            bw = vbox.b2 - vbox.b1 + 1,\n            maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()]\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0,\n            partialsum = [],\n            lookaheadsum = [],\n            i, j, k, sum, index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i, j, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j, i, k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        } else { /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j, k, i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function(d, i) {\n            lookaheadsum[i] = total - d\n        });\n\n        function doCut(color) {\n            var dim1 = color + '1',\n                dim2 = color + '2',\n                left, right, vbox1, vbox2, d2, count2 = 0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~ (i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~ (i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n                    // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n            doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n            // console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels),\n            histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function() {\n            nColors++\n        });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo),\n            pq = new PQueue(function(a, b) {\n                return pv.naturalOrder(a.count(), b.count())\n            });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n\n        function iter(lh, target) {\n            var ncolors = 1,\n                niters = 0,\n                vbox;\n            while (niters < maxIterations) {\n                vbox = lh.pop();\n                if (!vbox.count()) { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox),\n                    vbox1 = vboxes[0],\n                    vbox2 = vboxes[1];\n\n                if (!vbox1) {\n                    // console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) { /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n                    // console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n        // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function(a, b) {\n            return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors - pq2.size());\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    }\n})();\n\nmodule.exports = MMCQ.quantize\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      xhr.onload = function() {\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n","import page from 'page';\nimport fetch from 'whatwg-fetch';\nimport Tabs from './js/tabs.js';\nimport Vibrant from 'node-vibrant';\nimport FigureBg from './js/figure-bg.js';\nimport imgFill from './js/vendor/imgfill.js';\n// import particlesJS from 'particles.js';\n\n\n\nfunction ToggleNav() {\n\tconst navToggle = document.querySelector('.js-navToggle');\n\tconst MobileNav = document.querySelector('.MobileNav');\n\tconst navToggleClose = document.querySelector('.js-navToggleClose');\n\t\n\tnavToggle.addEventListener('click', function(evt) {\n\t\tevt.preventDefault();\n\t\tMobileNav.classList.add('is-active');\n\t}, false);\n\n\tnavToggleClose.addEventListener('click', function(evt) {\n\t\tevt.preventDefault();\n\t\tMobileNav.classList.remove('is-active');\n\t}, false);\n}\n\n\n// Call Function\n\nToggleNav();\nFigureBg();\n\nimgFill('.imgFill', '.imgFillSrc');\n\n\n\n\n// // Vanilla\n// document.addEventListener('DOMContentLoaded', function() {\n// \tparticlesJS.load('particles-js', '../asset/js/particlesjs-config1.json', function() {console.log('callback - particles.js config loaded');});\n// })","import Vibrant from 'node-vibrant';\n\nconst FigureBg = () => {\n  const Figures = Array.from(document.querySelectorAll('.Figure--slideDown'));\n  for (let Figure of Figures) {\n    const imgSrc = Figure.querySelector('img').getAttribute('src');\n    const FigCaption = Figure.querySelector('figcaption');\n\n    const bgColor = new Vibrant(imgSrc);\n    bgColor.getPalette(( err, palette ) => {\n      if (err) {\n        FigCaption.style.backgroundColor('#ffffff');\n      } else {\n        const hexColor = palette.Vibrant.rgb.join();\n        const bodyColor = palette.Vibrant.getTitleTextColor();\n        FigCaption.style.backgroundColor = 'rgba(' + hexColor + ', 1)';\n        FigCaption.style.color = bodyColor;\n      }\n    });\n  }\n};\n\nexport default FigureBg;\n","\nconst childHidden = (el) => {\n  const elHidden = document.querySelectorAll(el);\n  for (let i = 0; i < elHidden.length; i++) {\n    elHidden[i].style.display = 'none';\n  }\n};\n\n\nconst Tabs = () => {\n  const Tab = document.querySelector('.Tab');\n  const TabAchor = Tab.querySelector('.TabAchor');\n  const TabContent = Tab.querySelector('.TabContent');\n\n\n}\n\nexport default Tabs;\n","'use strict';\n\n// usage:\n// imgFill(target, imgSrc)\n// require es6\n\n\n\nconst setCSS = (element) => {\n  let CSS = {\n    backgroundSize: \"cover\",\n    backgroundPosition: \"center\",\n    backgroundRepeat: \"no-repeat\"\n  };\n  // create multiple CSS Property\n  for (let i in CSS) {\n    element.style[i] = CSS[i];\n  }\n};\n\nconst imgFill = (target, srcClass) => {\n  let imgConts = Array.from(document.querySelectorAll(target));\n  for (let img of imgConts) {\n\n    // define image source class\n    let imgSrc = img.querySelector(srcClass);\n\n    // Get image source url\n    let imgSrcURL = imgSrc.getAttribute('src');\n\n    // hide source images\n    imgSrc.style.display = 'none';\n    // Set Multiple CSS Property\n    img.style.backgroundImage = 'url(' + imgSrcURL + ')';\n    setCSS(img);\n  }\n};\n\nexport default imgFill;"]}